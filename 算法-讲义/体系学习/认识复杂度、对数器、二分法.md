# 认识复杂度、对数器、二分法

## 复杂度

- 评估算法优劣的核心指标是什么?

  > 时间复杂度（流程决定）
  >
  > 额外空间复杂度（流程决定）
  >
  > 常数项时间（实现细节决定）

- 什么是时间复杂度?时间复杂度怎么估算?

  > 常数时间的操作
  >
  > 确定算法流程的总操作数量与样本数量之间的表达式关系
  >
  > 只看表达式最高阶项的部分

- 常见的常数时间的操作

  > ·常见的算术运算(+、-、*、/、%等)
  >
  > ·常见的位运算(>>、>>>、<<、、&、^等)
  >
  > ·赋值、比较、自增、自减操作等
  >
  > ·数组寻址操作

 总之，执行时间固定的操作都是常数时间的操作。
 反之，执行时间不固定的操作，都不是常数时间的操作。

- 如何确定算法流程的总操作数量与样本数量之间的表达式关系?

  > 1，想象该算法流程所处理的数据状况，要按照最差情况来。
  >
  > 2，把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作。
  >
  > 3，如果数据量为N，看看基本动作的数量和N是什么关系。

- 如何确定算法流程的时间复杂度?

  > 当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。
  >
  > 记为∶O(忽略掉系数的高阶项)

- 时间复杂度的意义

  > 抹掉了好多东西，只剩下了一个最高阶项啊…那这个东西有什么意义呢?
  >
  > 时间复杂度的意义在于:
  >
  > 当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的;每一项的系数是什么，不是最重要的。真正重要的就是最高阶项是什么。
  >
  > 这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与数据量有关，与过程之外的优化无关。

- 算法流程的常数项

  > 我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。
  >
  > 难道同样时间复杂度的流程，在实际运行时候就一样的好吗?
  >
  > 当然不是。
  >
  > 时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。

- 常见的时间复杂度(我们陆续都会见到的)排名从好到差∶

  > O(1)
  >
  > O(logN)
  >
  > O(N)
  >
  > O(N*logN)
  >
  > O(N^2) O(N^3)… O(N^K)
  >
  > O(2^N) O(3^N)… O(K^N)
  >
  > O(N!)

- 算法和数据结构学习的大脉络

  > 1）知道怎么算的算法
  >
  > 2）知道怎么试的算法
  >
  > 我们所有的题目讲解，对于大脉络的实践贯穿始终

- 注意

  > 1，算法的过程，和具体的语言是无关的。
  >
  > 2，想分析一个算法流程的时间复杂度的前提，是对该流程非常熟悉
  >
  > 3，一定要确保在拆分算法流程时，拆分出来的所有行为都是常数时间的操作。
  >
  > 这意味着你写算法时，对自己的用过的每一个系统api，都非常的熟悉。否则会影响你对时间复杂度的估算。



- 额外空间复杂度

  > 你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。
  >
  > 作为输入参数的空间，不算额外空间。
  >
  > 作为输出结果的空间，也不算额外空间。
  >
  > 因为这些都是必要的、和现实目标有关的。所以都不算。
  >
  > 但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。

- 算法流程的常数项的比拼方式

  > 放弃理论分析，生成随机数据直接测
  >
  > 为什么不去理论分析?
  >
  > 不是不能纯分析，而是没必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快,慢之分的。
  >
  > 比如，位运算的常数时间远小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。
  >
  > 所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。

## 对数器

认识对数器

> 你在网上找到了某个公司的面试题，你想了好久，感觉自己会做，但是你找不到在线测试,你好心烦..
>
> 你和朋友交流面试题，你想了好久，感觉自己会做，但是你找不到在线测试，你好心烦.
>
> 你在网上做笔试，但是前几个测试用例都过了，突然一个巨大无比数据量来了，结果你的代码报错了，如此大的数据量根本看不出哪错了，你好心烦…

构建自定义的数组排序
<details>
  <summary>排序代码</summary>
  <p> - 生成数据及生成排序结果</p>
  <pre><code>// for test
	public static void comparator(int[] arr) {
		Arrays.sort(arr);
	}
	// for test
	public static int[] generateRandomArray(int maxSize, int maxValue) {
		// Math.random()   [0,1)  
		// Math.random() * N  [0,N)
		// (int)(Math.random() * N)  [0, N-1]
		int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
		for (int i = 0; i < arr.length; i++) {
			// [-? , +?]
			arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
		}
		return arr;
	}
	// for test
	public static int[] copyArray(int[] arr) {
		if (arr == null) {
			return null;
		}
		int[] res = new int[arr.length];
		for (int i = 0; i < arr.length; i++) {
			res[i] = arr[i];
		}
		return res;
	}
	// for test
	public static boolean isEqual(int[] arr1, int[] arr2) {
		if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
			return false;
		}
		if (arr1 == null && arr2 == null) {
			return true;
		}
		if (arr1.length != arr2.length) {
			return false;
		}
		for (int i = 0; i < arr1.length; i++) {
			if (arr1[i] != arr2[i]) {
				return false;
			}
		}
		return true;
	}
	// for test
	public static void printArray(int[] arr) {
		if (arr == null) {
			return;
		}
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}
	// for test
	public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 100;
		int maxValue = 100;
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			int[] arr1 = generateRandomArray(maxSize, maxValue);
			int[] arr2 = copyArray(arr1);
			// selectionSort(arr1); // 你实现的方法
			comparator(arr2);
			if (!isEqual(arr1, arr2)) {
				succeed = false;
				printArray(arr1);
				printArray(arr2);
				break;
			}
		}
		System.out.println(succeed ? "Nice!" : "Fucking fucked!");
		int[] arr = generateRandomArray(maxSize, maxValue);
		printArray(arr);
		selectionSort(arr);
		printArray(arr);
	}   </code>  </pre>
  </details>






## 二分法

- 认识二分法

  > 经常见到的类型是在一个有序数组上，开展二分搜索
  >
  > 但有序真的是所有问题求解时使用二分的必要条件吗?
  >
  > 不
  >
  > 只要能正确构建左右两侧的淘汰逻辑，你就可以二分。

- 认识二分法

  > 1）在一个有序数组中，找某个数是否存在
  >
  > 2）在一个有序数组中，找>=某个数最左侧的位置
  >
  > 3）在一个有序数组中，找<=某个数最右侧的位置
  >
  > 4）局部最小值问题



## 问题集合

### SelectionSort

- 链接：<a href="https://leetcode.cn/problems/sort-an-array/description/">升序排列测试链接</a>

- 内容：

  > 给你一个整数数组 `nums`，请你将该数组升序排列。
  >
  > **示例 1：**
  >
  > ```java
  > 输入：nums = [5,2,3,1]
  > 输出：[1,2,3,5]
  > ```
  >
  > **示例 2：**
  >
  > ```java
  > 输入：nums = [5,1,1,2,0,0]
  > 输出：[0,0,1,1,2,5]
  > ```

- 思路：

  > 每次找到最小值的下标位置，放到第一个位置。
  >
  > 例：5,1,1,2,0,0
  >
  > | 第i次排序 | 第i次排序的结果 |
  > | --------- | --------------- |
  > | 1         | 0,1,1,2,5,0     |
  > | 2         | 0,0,1,2,5,1     |
  > | 3         | 0,0,1,2,5,1     |
  > | 4         | 0,0,1,1,5,2     |
  > | 5         | 0,0,1,1,2,5     |

- 代码：

  <details>
  <summary>排序代码</summary>
  <p> - 选择排序</p>
  <pre><code> // 选择0~n-1的最小值，与0互换
    // 选择1~n-1的最小值，与1互换
    // ...
    // 选择n-2~n-1的最小值，与n-2互换
    public void selectionSort(int[] nums){
        if (nums == null || nums.length < 2) {
            return;
        }
        int n = nums.length;
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i+1; j < n; j++) {
                if(nums[j] < nums[minIndex]){
                    minIndex = j;
                }
            }
            swap(nums,minIndex,i);
        }
    }
    public void swap(int[] nums,int i,int j){
        if(i == j) return;
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }  </code>  </pre>
  </details>
  
  
### BubbleSort

- 链接：<a href="https://leetcode.cn/problems/sort-an-array/description/">升序排列测试链接</a>

- 内容：

  > 给你一个整数数组 `nums`，请你将该数组升序排列。
  >
  > **示例 1：**
  >
  > ```java
  > 输入：nums = [5,2,3,1]
  > 输出：[1,2,3,5]
  > ```
  >
  > **示例 2：**
  >
  > ```java
  > 输入：nums = [5,1,1,2,0,0]
  > 输出：[0,0,1,1,2,5]
  > ```

- 思路：

  > 每两个相邻的值比较，大的放后面，一直比较，直到最后。
  >
  > 例：5,1,3,2,6,1
  >
  > | 第i次排序 | 第i次排序的结果 |
  > | --------- | --------------- |
  > | 1         | 1,3,2,5,1,6     |
  > | 2         | 1,2,3,1,5,6     |
  > | 3         | 1,2,1,3,5,6     |
  > | 4         | 1,1,2,3,5,6     |
  > | 5         | 1,1,2,3,5,6     |

- 代码：
   <details>
  <summary>排序代码</summary>
  <p> - 冒泡排序</p>
  <pre><code> public void bubbleSort(int[] nums){
        if (nums == null || nums.length < 2) {
            return;
        }
        int n = nums.length;
        boolean isSwap = false;
        for (int i = 0; i < n - 1; i++) {
            isSwap = false;
            for (int j = 1; j < n-i; j++) {
                if(nums[j] < nums[j-1]){
                    swap(nums,j,j+1);
                    {isSwap = true;}
                }
            }
            if(!isSwap){
                return;
            }
        }
    }
    public void swap(int[] nums,int i,int j){
        if(i == j) return;
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }  </code>  </pre>
  </details>

### InsertionSort

- 链接：<a href="https://leetcode.cn/problems/sort-an-array/description/">升序排列测试链接</a>

- 内容：

  > 给你一个整数数组 `nums`，请你将该数组升序排列。
  >
  > **示例 1：**
  >
  > ```java
  > 输入：nums = [5,2,3,1]
  > 输出：[1,2,3,5]
  > ```
  >
  > **示例 2：**
  >
  > ```java
  > 输入：nums = [5,1,1,2,0,0]
  > 输出：[0,0,1,1,2,5]
  > ```

- 思路：

  > 当前值与之前已排序好的值相比较，确定最终要放的位置。
  >
  > 例：5,1,3,2,6,1
  >
  > | 第i次排序 | 第i次排序的结果 |
  > | --------- | --------------- |
  > | 1         | 1,5,3,2,6,1     |
  > | 2         | 1,3,5,2,6,1     |
  > | 3         | 1,2,3,5,6,1     |
  > | 4         | 1,2,3,5,6,1     |
  > | 5         | 1,1,2,3,5,6     |

- 代码：

  <details>
  <summary>排序代码</summary>
  <p> - 插入排序</p>
  <pre><code> public void insertionSort(int[] nums){
          if (nums == null || nums.length < 2) {
              return;
          }
          int n = nums.length;
          for (int i = 1; i < n; i++) {
              int cur = nums[i];
              int j = i;
              while (j >= 1 && nums[j-1] > cur){
                  nums[j] = nums[j-1];
                  j--;
              }
              nums[j] = cur;
          }
      }
      public void swap(int[] nums,int i,int j){
          if(i == j) return;
          int temp = nums[i];
          nums[i] = nums[j];
          nums[j] = temp;
      }  </code>  </pre>
  </details>

### BSExist

- 链接： <a href="https://leetcode.cn/problems/binary-search/description/">是否存在数字</a>

- 内容：

  > 给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。
  > **示例 1:**
  >
  > ```
  > 输入: nums = [-1,0,3,5,9,12], target = 9
  > 输出: 4
  > 解释: 9 出现在 nums 中并且下标为 4
  > ```
  >
  > **示例 2:**
  >
  > ```
  > 输入: nums = [-1,0,3,5,9,12], target = 2
  > 输出: -1
  > 解释: 2 不存在 nums 中因此返回 -1
  > ```

- 思路：

  > L,R的中间值m，nums[m]与target比较，若大，则去[L,m-1]里，若小，则去[m+1,R]里，相等，则返回mid。
  >
  > 直到L>R越界还没有返回，则返回-1

- 代码：

<details>
  <summary>二分查找</summary>
  <p> - 是否存在</p>
  <pre><code>    public int search(int[] nums, int target) {
        if(nums == null || nums.length < 1){
            return -1;
        }
        int L = 0, R = nums.length - 1;
        while (L <= R) {
            int mid = (R - L) / 2 + L;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] > target){
                R = mid - 1;
            }else{
                L = mid + 1;
            }
        }
        return -1;
    } </code>  </pre>
  </details>

### BSNearLeft

- 链接： <a href="https://leetcode.cn/problems/search-insert-position/description/">>=target的最左侧 </a>

- 内容：

  > 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
  >
  > 请必须使用时间复杂度为 `O(log n)` 的算法。
  >
  > **示例 1:**
  >
  > ```
  > 输入: nums = [1,3,5,6], target = 5
  > 输出: 2
  > ```
  >
  > **示例 2:**
  >
  > ```
  > 输入: nums = [1,3,5,6], target = 2
  > 输出: 1
  > ```
  >
  > **示例 3:**
  >
  > ```
  > 输入: nums = [1,3,5,6], target = 7
  > 输出: 4
  > ```

- 思路：

  > L,R的中间值m，nums[m]与target比较，若大于等于target，则去[L,m-1]里，并记录mid的值，若小，则去[m+1,R]里。
  >
  > 直到L>R越界返回记录的值

- 代码：

<details>
  <summary>二分查找</summary>
  <p> - 大于等于target的最左位置，若不存在，则返回target要插入的位置</p>
  <pre><code>    public int searchInsert(int[] nums, int target) {
        if(nums == null || nums.length < 1) return 0;
        int L = 0,R = nums.length - 1,ans = nums.length;
        while (L <= R) {
            int mid = (R - L)/2 + L;
            if(nums[mid] >= target){
                ans = mid;
                R = mid - 1;
            }else{
                L = mid + 1;
            }
        }
        return ans;
    } </code>  </pre>
  </details>

### BSNearRight

- 链接：暂无

- 内容：

  > 给定一个排序数组和一个目标值，在数组中找到<=目标值的最右侧的位置
  >
  > 请必须使用时间复杂度为 `O(log n)` 的算法。

- 思路：

  > L,R的中间值m，nums[m]与target比较，若大于等于target，则去[L,m-1]里，并记录mid的值，若小，则去[m+1,R]里。
  >
  > 直到L>R越界返回记录的值

- 代码：

<details>
  <summary>二分查找</summary>
  <p> - 小于等于target的最右位置，若不存在，则返回-1</p>
  <pre><code>    public static int nearestIndex(int[] nums, int target) {
        if(nums == null || nums.length < 1) return -1;
        int L = 0, R = nums.length - 1, ans = -1;
        while (L <= R) {
            int mid = (R - L)/2 + L;
            if(nums[mid] <= target){
                ans = mid;
                L = mid + 1;
            }else{
                R = mid - 1;
            }
        }
        return ans;
    }</code>  </pre>
  </details>

### BSAwesome

- 链接：暂无

- 内容：

  > 对无序数组二分法求局部最小，求低谷值（返回一个即可）
  >
  > 同样的，因为题目给出了边界值(左右边界看做无穷大)，所以一定会出现低谷值
  >
  > arr[0] < arr[1] ：则低谷值就是 arr[0]；
  >
  > arr[N - 1] < arr[N - 2] ：则低谷值就是最后一个元素；
  >
  > arr[i - 1] > arr[i] < arr[i + 1] ：则低谷值为 arr[i]
  >
  > 特定条件： 对于任意两个相邻位置，都不相等

- 思路：

  > 二分查找，先判断左右边界是否满足，若满足则返回
  >
  > 查看mid位置是否满足，若满足则返回，否则，查看与L,R的关系，缩减L,R范围直到满足

- 代码：

<details>
  <summary>二分查找</summary>
  <p> - 局部最小值的位置，小于左右两侧的值</p>
  <pre><code>        public static int getLessIndex(int[] arr) {
        if(arr == null || arr.length < 2) return -1;
        if(arr[0] < arr[1] || arr[arr.length - 1] < arr[arr.length - 2]){
            return arr[0] - arr[1] < 0 ? 0 : arr.length - 1;
        }
        int L = 1,R = arr.length - 2;
        while (L <= R) {
            int mid = (R - L)/2 + L;
            if(arr[mid] > arr[mid - 1]){
                R = mid - 1;
            }else if(arr[mid] > arr[mid + 1]){
                L = mid + 1;
            }else{
                return mid;
            }
        }
        return L;
    }</code>  </pre>
  </details>