# 异或运算相关面试题

## 异或内容

- 认识异或运算

  > 异或运算︰相同为0，不同为1
  >
  > 同或运算∶相同以1，不同为0
  >
  > 能长时间记住的概率接近0%
  >
  > 所以，异或运算就记成无进位相加!

## 问题集合

### SwapNum

- 链接：暂无

- 内容：

  > 如何不用额外变量交换两个数
  >

- 思路：

  > 异或操作
  >
  > **假设原n与m值为n'及m'**
  >
  > | 操作    | n                          | m                |
  > | ------- | -------------------------- | ---------------- |
  > | n = n^m | **n' ^ m'**                | m'               |
  > | m=n^m   | n' ^ m'                    | **n' ^ m' ^ m'** |
  > | n=n^m   | **n' ^ m' ^ n' ^ m' ^ m'** | n' ^ m' ^ m'     |
  > | 化简    | m'                         | n'               |
  >
  > 即可把原n与m的值互换

- 代码：

  <details>
  <summary>交换代码</summary>
  <p> - 不使用额外空间交换两值</p>
  <pre><code>     public static void swap(int n,int m){
          n = n^m;
          m = n^m;
          n = n^m;
      } </code>  </pre>
  </details>

### OneOddTime

- 链接：<a href="https://leetcode.cn/problems/single-number/description/">1个出现奇数次的数字</a> (此题加强)

- 内容：

  > —个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数

- 思路：

  > 异或操作
  >
  > **假设原n与m值为n'及m'**
  >
  > | 操作    | n                          | m                |
  > | ------- | -------------------------- | ---------------- |
  > | n = n^m | **n' ^ m'**                | m'               |
  > | m=n^m   | n' ^ m'                    | **n' ^ m' ^ m'** |
  > | n=n^m   | **n' ^ m' ^ n' ^ m' ^ m'** | n' ^ m' ^ m'     |
  > | 化简    | m'                         | n'               |
  >
  > 即可把原n与m的值互换

- 代码：

  <details>
  <summary>交换代码</summary>
  <p> - 不使用额外空间交换两值</p>
  <pre><code>         public static int oneOddTimes(int[] nums){
          int ans = 0;
          for (int i = 0; i < nums.length; i++) {
              ans ^= nums[i];
          }
          return ans;
      } </code>  </pre>
  </details>

### RightOneInBit

- 链接：暂无

- 内容：

  > 怎么把一个int类型的数，提取出最右侧的1来

- 思路：

  > 异或操作
  >
  > 任意一个数字的负数在电脑底层表现为
  >
  > -a = (a的所有二进制位取反+1)
  >
  > 这天然保证了一个正数a与负数-a在二进制位上的最后一个1的位置index
  >
  > **0~index-1位置上所有的二进制位数字都不同**
  >
  > **index~31位置上所有的二进制位数字都相等，且index位上为1，其余皆为0**
  >
  > 要提取int类型的最右的侧的1来，即 **a & (-a)**即可

- 代码：

  <details>
  <summary>二进制位最右侧的1代码</summary>
  <p> - 提取二进制位最右侧的1</p>
  <pre><code>     private static int rightOne(int num){
          return num & (-num);
      } </code>  </pre>
  </details>

### TwoOddTimes

- 链接：暂无

- 内容：

  > —个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数

- 思路：

  > 1. 首先将数组所有的数据异或的结果记为eor ，此eor等价于odd1 ^ odd2
  > 2. 既然odd1不等于odd2，eor天然不等于0，提取出最右侧的1来（RightOneInBit）记为rightOne
  > 3. **根据rightOne 与nums[i]异或的结果（不为0就为2的某次方(>0)）可分为两组，得其中一组的异或值eor1**，这里是使用了分组思路，所有的nums中的数据只可能影响odd1或odd2一个值
  > 4. 根据eor和eor1可得eor2
  > 5. eor1与eor2即为odd1和odd2

- 代码：

  <details>
  <summary>两个只出现奇数次的数字</summary>
  <p> - 返回两个只出现奇数次的数字</p>
  <pre><code>     public static int[] twoOddTimes(int[] arr){
          if(arr == null || arr.length < 2) return new int[]{-1,-1};
          int eor = 0;
          for (int i = 0; i < arr.length; i++) {
              eor ^= arr[i];
          }
          int rightOne = eor & (-eor);
          int eor1 = 0;
          for (int i = 0; i < arr.length; i++) {
              if((rightOne & arr[i]) != 0){
                  eor1 ^= arr[i];
              }
          }
          return new int[]{eor1,eor ^ eor1};
      } </code>  </pre>
  </details>

### KM

- 链接：<a href="https://leetcode.cn/problems/single-number-ii/description/ ">一个出现k次的数字</a> (本题为其加强版)

- 内容：

  >  输入一定能够保证，数组中所有的数都出现了M次，只有一种数出现了K次
  >
  >  1 <= K < M
  >
  >  返回这种数

- 思路：

  > 思路1：使用map记录数字及其出现的次数，最后返回出现K次的数字
  >
  > 思路2：
  >
  > 1. 使用长度为32的数组count，记录数组arr中的数字的每一位上1的个数
  > 2. 只有count[i] % M == K的位置上，这个数字在这个位置上有1
  > 3. 从二进制位上得到这个数

- 代码：

  <details>
  <summary>1个只出现K次的数字</summary>
  <p> - 返回1个只出现K次的数字</p>
  <pre><code>     public static int km(int[] arr,int K,int M){
          if(arr == null || arr.length < K ) return -1;
          int[] count = new int[32];
          for (int i = 0; i < arr.length; i++) {
              int cur = arr[i];
              for (int j = 0; j < 32; j++) {
                  count[j] += (cur >> j) & 1;
              }
          }
          int ans = 0;
          for (int i = 0; i < 32; i++) {
              if(count[i] % M != 0){
                  ans |= 1 << i;
              }
          }
          return ans;
      } </code>  </pre>
  </details>