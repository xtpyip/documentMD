# 图

## 基础内容

- 图的内容
  ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class16/graph.png)
  
- 图的代码统一风格

  - 节点

    ```java
    // 点结构的描述
    public class Node {
    	public int value; // 当前节点的值
    	public int in; // 以此节点为终的数量
    	public int out; // 以此节点为始的数量
    	public ArrayList<Node> nexts; // 此节点指向的节点集合
    	public ArrayList<Edge> edges; // 以此节点为头的边的集合
    
    	public Node(int value) {
    		this.value = value;
    		in = 0;
    		out = 0;
    		nexts = new ArrayList<>();
    		edges = new ArrayList<>();
    	}
    }
    ```

  - 边

    ```java
    public class Edge {
    	public int weight; // 有权重的边
    	public Node from; // 有向图有指向
    	public Node to;
    	public Edge(int weight, Node from, Node to) {
    		this.weight = weight;
    		this.from = from;
    		this.to = to;
    	}
    }
    ```

  - 图

    ```java
    public class Graph {
    	public HashMap<Integer, Node> nodes; // 点的集合
    	public HashSet<Edge> edges; // 边的集合
    	public Graph() {
    		nodes = new HashMap<>();
    		edges = new HashSet<>();
    	}
    }
    ```

  - 构建图例

    ```java
    public class GraphGenerator {
    	// matrix 所有的边
    	// N*3 的矩阵
    	// [weight, from节点上面的值，to节点上面的值]
    	// 
    	// [ 5 , 0 , 7]
    	// [ 3 , 0,  1]
    	// 
    	public static Graph createGraph(int[][] matrix) {
    		Graph graph = new Graph();
    		for (int i = 0; i < matrix.length; i++) {
    			 // 拿到每一条边， matrix[i] 
    			int weight = matrix[i][0];
    			int from = matrix[i][1];
    			int to = matrix[i][2];
    			if (!graph.nodes.containsKey(from)) {
    				graph.nodes.put(from, new Node(from));
    			}
    			if (!graph.nodes.containsKey(to)) {
    				graph.nodes.put(to, new Node(to));
    			}
    			Node fromNode = graph.nodes.get(from);
    			Node toNode = graph.nodes.get(to);
    			Edge newEdge = new Edge(weight, fromNode, toNode);
    			fromNode.nexts.add(toNode);
    			fromNode.out++;
    			toNode.in++;
    			fromNode.edges.add(newEdge);
    			graph.edges.add(newEdge);
    		}
    		return graph;
    	}
    }
    ```


## 问题集合

### BFS-DFS

- 链接：<a href="#">暂无</a>

- 内容：

  > 图的宽度优先遍历和深度优先遍历
  >
  
- 思路：

  > 队列与栈实现

- 代码：

  <details>
    <summary>宽度优先遍历</summary>
    <p> - 队列实现代码</p>
    <pre><code> // 从node出发，进行宽度优先遍历
      public static void bfs(Node start) {
          if(start == null) return;
          Queue<Node> queue = new LinkedList<>();
          Set<Node> set = new HashSet<>();
          queue.add(start);
          set.add(start);
          while (!queue.isEmpty()) {
              Node poll = queue.poll();
              System.out.println(poll.value);
              for (Node next : poll.nexts) {
                  if(!set.contains(next)){
                      queue.add(next);
                      set.add(next);
                  }
              }
          }
      }</code>  </pre>
    </details>
  
  <details>
    <summary>深度优先遍历</summary>
    <p> - 栈实现代码</p>
    <pre><code> // 从node出发，进行深度优先遍历
      public static void dfs(Node start) {
          if(start == null) return;
          Stack<Node> stack = new Stack<>();
          Set<Node> set = new HashSet<>();
          stack.add(start);
          set.add(start);
          System.out.println(start.value);
          while (!stack.isEmpty()) {
              Node cur = stack.pop();
              for (Node next : cur.nexts) {
                  if (!set.contains(next)) {
                      stack.push(cur);
                      stack.push(next);
                      set.add(next);
                      System.out.println(next.value);
                      break;
                  }
              }
          }
      }</code>  </pre>
    </details>

### TopologicalOrder

- 链接：<a href="https://www.lintcode.com/problem/127/">图的拓扑排序</a>

- 内容：

  > **描述**
  >
  > 给定一个有向图，图节点的拓扑排序定义如下:
  >
  > - 对于图中的每一条有向边 `A -> B` , 在拓扑排序中A一定在B之前.
  > - 拓扑排序中的第一个节点可以是图中的任何一个没有其他节点指向它的节点.
  >
  > 针对给定的有向图找到任意一种拓扑排序的顺序.
  >
  > **样例 1：**
  >
  > 输入：
  >
  > ```
  > graph = {0,1,2,3#1,4#2,4,5#3,4,5#4#5}
  > ```
  >
  > 输出：
  >
  > ```
  > [0, 1, 2, 3, 4, 5]
  > ```
  >
  > 解释：
  >
  > 图如下所示:
  >
  > ![91cf07d2-b7ea-11e9-bb77-0242ac110002.jpg](https://media-cn.lintcode.com/new_storage_v2/public/202211/6da9543e-4e23-4ff1-a33e-e99f380c1b40.jpg)
  >
  > 拓扑排序可以为:
  > [0, 1, 2, 3, 4, 5]
  > [0, 2, 3, 1, 5, 4]
  > ...
  > 您只需要返回给定图的任何一种拓扑顺序

- 思路：

  > 宽度优先与深度优先

- 代码：

  <details>
    <summary>宽度优先</summary>
    <p> - 0入度队列出队实现</p>
    <pre><code> public static ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
          ArrayList<DirectedGraphNode> ans = new ArrayList<>();
          // 得到所有的节点
          // 获取所有的节点的入度
          HashMap<DirectedGraphNode, Integer> map = new HashMap<>();
          for (DirectedGraphNode cur : graph) {
              map.put(cur, 0);
          }
          for (DirectedGraphNode cur : graph) {
              for (DirectedGraphNode next : cur.neighbors) {
                  map.put(next, map.get(next) + 1);
              }
          }
          // 入度为0
          Queue<DirectedGraphNode> zeroQueue = new LinkedList<>();
          for (DirectedGraphNode node : map.keySet()) {
              if(map.get(node) == 0){
                  zeroQueue.add(node);
              }
          }
          // 入度为0出队
          while (!zeroQueue.isEmpty()) {
              DirectedGraphNode cur = zeroQueue.poll();
              ans.add(cur);
              for (DirectedGraphNode next : cur.neighbors) {
                  int in = map.get(next) - 1;
                  map.put(next,in);
                  if(in == 0){
                      zeroQueue.add(next);
                  }
              }
          }
          return ans;
      }</code>  </pre>
    </details>

  <details>
    <summary>深度优先深度排序</summary>
    <p> - 记录节点从尾到头所在的深度（尾为0）</p>
    <pre><code> public static class Record{
          public DirectedGraphNode node;
          public int deep;
          public Record(DirectedGraphNode n,int o){node = n;deep = o;}
      }
      public static ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
          HashMap<DirectedGraphNode, Record> order = new HashMap<>();
          for (DirectedGraphNode cur : graph) {
              f(cur,order);
          }
          ArrayList<Record> recordArr = new ArrayList<>();
          for (Record r : order.values()) {
              recordArr.add(r);
          }
          recordArr.sort((o1,o2)->{return o2.deep - o1.deep;});
          ArrayList<DirectedGraphNode> ans = new ArrayList<DirectedGraphNode>();
          for (Record r : recordArr) {
              ans.add(r.node);
          }
          return ans;
      }
      public static Record f(DirectedGraphNode cur, HashMap<DirectedGraphNode, Record> order) {
          if(order.containsKey(cur)) return order.get(cur);
          int follow = 0;
          for (DirectedGraphNode neighbor : cur.neighbors) {
              follow = Math.max(follow,f(neighbor,order).deep);
          }
          Record ans = new Record(cur, follow + 1);
          order.put(cur,ans);
          return ans;
      }</code>  </pre>
    </details>

  <details>
    <summary>深度优先节点数量排序</summary>
    <p> - 记录当前节点以根到最后出度为0的节点的数量</p>
    <pre><code> public static class Record {
  		public DirectedGraphNode node;
  		public long nodes;
  		public Record(DirectedGraphNode n, long o) {
  			node = n;
  			nodes = o;
  		}
  	}
  	public static class MyComparator implements Comparator<Record> {
  		@Override
  		public int compare(Record o1, Record o2) {
  			return o1.nodes == o2.nodes ? 0 : (o1.nodes > o2.nodes ? -1 : 1);
  		}
  	}
  	public static ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
  		HashMap<DirectedGraphNode, Record> order = new HashMap<>();
  		for (DirectedGraphNode cur : graph) {
  			f(cur, order);
  		}
  		ArrayList<Record> recordArr = new ArrayList<>();
  		for (Record r : order.values()) {
  			recordArr.add(r);
  		}
  		recordArr.sort(new MyComparator());
  		ArrayList<DirectedGraphNode> ans = new ArrayList<DirectedGraphNode>();
  		for (Record r : recordArr) {
  			ans.add(r.node);
  		}
  		return ans;
  	}
  	// 当前来到cur点，请返回cur点所到之处，所有的点次！
  	// 返回（cur，点次）
  	// 缓存！！！！！order   
  	//  key : 某一个点的点次，之前算过了！
  	//  value : 点次是多少
  	public static Record f(DirectedGraphNode cur, HashMap<DirectedGraphNode, Record> order) {
  		if (order.containsKey(cur)) {
  			return order.get(cur);
  		}
  		// cur的点次之前没算过！
  		long nodes = 0;
  		for (DirectedGraphNode next : cur.neighbors) {
  			nodes += f(next, order).nodes;
  		}
  		Record ans = new Record(cur, nodes + 1);
  		order.put(cur, ans);
  		return ans;
  	}</code>  </pre>
    </details>

  <details>
    <summary>拓扑排序一般流程</summary>
    <p> - 入度为0节点出队</p>
    <pre><code> // directed graph and no loop
      public static List<Node> sortedTopology(Graph graph) {
          HashMap<Node, Integer> map = new HashMap<>();
          Queue<Node> zeroInQueue = new LinkedList<>();
          for (Node node : graph.nodes.values()) {
              map.put(node,node.in);
              if(node.in == 0) zeroInQueue.add(node);
          }
          ArrayList<Node> result = new ArrayList<>();
          while (!zeroInQueue.isEmpty()) {
              Node cur = zeroInQueue.poll();
              result.add(cur);
              for (Node next : cur.nexts) {
                  map.put(next,map.get(next)-1);
                  if(map.get(next) == 0){
                      zeroInQueue.add(next);
                  }
              }
          }
          return result;
      }</code>  </pre>
    </details>

### Kruskal

- 链接：<a href="#">暂无</a>

- 内容：

  > 克鲁斯卡尔（kruskal）算法通常用于求出一个连通图中的最小生成树

- 思路：

  > 并查集+小根堆
  >
  > 当前边的两个端点不是同一个连通集时，添加，否则，跳过

- 代码：

  <details>
    <summary>并查集+小根堆</summary>
    <p> - 实现代码</p>
    <pre><code> //undirected graph only
      // Union-Find Set
      public static class UnionFind {
          // key 某一个节点， value key节点往上的节点
          private HashMap<Node, Node> fatherMap;
          // key 某一个集合的代表节点, value key所在集合的节点个数
          private HashMap<Node, Integer> sizeMap;
          public UnionFind() {
              fatherMap = new HashMap<Node, Node>();
              sizeMap = new HashMap<Node, Integer>();
          }
          public void makeSets(Collection<Node> nodes) {
              fatherMap.clear();
              sizeMap.clear();
              for (Node node : nodes) {
                  fatherMap.put(node, node);
                  sizeMap.put(node, 1);
              }
          }
          private Node findFather(Node n) {
              Stack<Node> path = new Stack<>();
              while(n != fatherMap.get(n)) {
                  path.add(n);
                  n = fatherMap.get(n);
              }
              while(!path.isEmpty()) {
                  fatherMap.put(path.pop(), n);
              }
              return n;
          }
          public boolean isSameSet(Node a, Node b) {
              return findFather(a) == findFather(b);
          }
          public void union(Node a, Node b) {
              if (a == null || b == null) {
                  return;
              }
              Node aDai = findFather(a);
              Node bDai = findFather(b);
              if (aDai != bDai) {
                  int aSetSize = sizeMap.get(aDai);
                  int bSetSize = sizeMap.get(bDai);
                  if (aSetSize <= bSetSize) {
                      fatherMap.put(aDai, bDai);
                      sizeMap.put(bDai, aSetSize + bSetSize);
                      sizeMap.remove(aDai);
                  } else {
                      fatherMap.put(bDai, aDai);
                      sizeMap.put(aDai, aSetSize + bSetSize);
                      sizeMap.remove(bDai);
                  }
              }
          }
      }
      public static Set<Edge> kruskalMST(Graph graph){
          UnionFind uf = new UnionFind();
          uf.makeSets(graph.nodes.values());
          // 从小到大依次把边弹出
          PriorityQueue<Edge> queue = new PriorityQueue<>((a, b) -> {
              return a.weight - b.weight;
          });
          for (Edge edge : graph.edges) {
              queue.add(edge);
          }
          Set<Edge> result = new HashSet<>();
          while (!queue.isEmpty()) {
              Edge cur = queue.poll();
              if(!uf.isSameSet(cur.from,cur.to)){
                  uf.union(cur.from,cur.to);
                  result.add(cur);
              }
          }
          return result;
      }</code>  </pre>
    </details>

### Prim

- 链接：<a href="#">暂无</a>

- 内容：

  > Prim算法求出一个连通图中的最小生成树

- 思路：

  > 优先级队列，每次添加不构成回路的边

- 代码：

  <details>
    <summary>优先级队列</summary>
    <p> - 最小生成树及最小生成树的值实现代码</p>
    <pre><code>// undirected graph only
      public static Set<Edge> primMST(Graph graph) {
          PriorityQueue<Edge> queue = new PriorityQueue<>((a, b) -> {
              return a.weight - b.weight;
          });
          HashSet<Node> set = new HashSet<>();// 已经在生成树中的点
          HashSet<Edge> result = new HashSet<>(); // 解锁的所有邻近边
          for (Node node : graph.nodes.values()) { // 以当前节点出发
              set.add(node);
              for (Edge edge : node.edges) {
                  queue.add(edge);
              }
              // 弹出最小的边
              while (!queue.isEmpty()) {
                  Edge cur = queue.poll();
                  if(!set.contains(cur.to)){ // 新解锁的点
                      set.add(cur.to);
                      result.add(cur);
                      for (Edge nextEdge : cur.to.edges) {
                          queue.add(nextEdge);
                      }
                  }
              }
          }
          return result;
      }
      // 请保证graph是连通图
      // graph[i][j]表示点i到点j的距离，如果是系统最大值代表无路
      // 返回值是最小连通图的路径之和
      public static int prim(int[][] graph) {
          int size = graph.length;
          int[] distances = new int[size];
          boolean[] visit = new boolean[size];
          visit[0] = true;
          for (int i = 0; i < size; i++) {
              distances[i] = graph[0][i];
          }
          int sum = 0;
          for (int i = 1; i < size; i++) {
              int minPath = Integer.MAX_VALUE;
              int minIndex = -1;
              for (int j = 0; j < size; j++) {
                  if (!visit[j] && distances[j] < minPath) {
                      minPath = distances[j];
                      minIndex = j;
                  }
              }
              if (minIndex == -1) {
                  return sum;
              }
              visit[minIndex] = true; // 每次确定一个最小值
              sum += minPath;
              for (int j = 0; j < size; j++) { // 确定的最小值对其他节点是否有很好的通路
                  if (!visit[j] && distances[j] > graph[minIndex][j]) {
                      distances[j] = graph[minIndex][j];
                  }
              }
          }
          return sum;
      }</code>  </pre>
    </details>

### NetworkDelayTime

- 链接：<a href="https://leetcode.cn/problems/network-delay-time/description/">测试链接</a>

- 内容：

  > 有 `n` 个网络节点，标记为 `1` 到 `n`。
  >
  > 给你一个列表 `times`，表示信号经过 **有向** 边的传递时间。 `times[i] = (ui, vi, wi)`，其中 `ui` 是源节点，`vi` 是目标节点， `wi` 是一个信号从源节点传递到目标节点的时间。
  >
  > 现在，从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1` 。
  >
  >  
  >
  > **示例 1：**
  >
  > ![img](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)
  >
  > ```
  > 输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
  > 输出：2
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：times = [[1,2,1]], n = 2, k = 1
  > 输出：1
  > ```
  >
  > **示例 3：**
  >
  > ```
  > 输入：times = [[1,2,1]], n = 2, k = 2
  > 输出：-1
  > ```

- 思路：

  > 思路一：小根堆+屏蔽已添加过的点
  >
  > 思路二：加强堆

- 代码：

  <details>
    <summary>小根堆+屏蔽已添加过的点</summary>
    <p> - 最长接收信息时间</p>
    <pre><code>public static int networkDelayTime1(int[][] times, int n, int k) {
  		ArrayList<ArrayList<int[]>> nexts = new ArrayList<>();
  		for (int i = 0; i <= n; i++) {
  			nexts.add(new ArrayList<>());
  		}
  		for (int[] delay : times) {
  			nexts.get(delay[0]).add(new int[] { delay[1], delay[2] });
  		}
  		PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[1] - b[1]);
  		heap.add(new int[] { k, 0 });
  		boolean[] used = new boolean[n + 1];
  		int num = 0;
  		int max = 0;
  		while (!heap.isEmpty() && num < n) {
  			int[] record = heap.poll();
  			int cur = record[0];
  			int delay = record[1];
  			if (used[cur]) {
  				continue;
  			}
  			used[cur] = true;
  			num++;
  			max = Math.max(max, delay);
  			for (int[] next : nexts.get(cur)) {
  				if (!used[next[0]]) {
  					heap.add(new int[] { next[0], delay + next[1] });
  				}
  			}
  		}
  		return num < n ? -1 : max;
  	}</code>  </pre>
    </details>
  
  <details>
    <summary>加强堆</summary>
    <p> - 最长接收信息时间</p>
    <pre><code>public static int networkDelayTime2(int[][] times, int n, int k) {
  		ArrayList<ArrayList<int[]>> nexts = new ArrayList<>();
  		for (int i = 0; i <= n; i++) {
  			nexts.add(new ArrayList<>());
  		}
  		for (int[] delay : times) {
  			nexts.get(delay[0]).add(new int[] { delay[1], delay[2] });
  		}
  		Heap heap = new Heap(n);
  		heap.add(k, 0);
  		int num = 0;
  		int max = 0;
  		while (!heap.isEmpty()) {
  			int[] record = heap.poll();
  			int cur = record[0];
  			int delay = record[1];
  			num++;
  			max = Math.max(max, delay);
  			for (int[] next : nexts.get(cur)) {
  				heap.add(next[0], delay + next[1]);
  			}
  		}
  		return num < n ? -1 : max;
  	}
  	// 加强堆
  	public static class Heap {
  		public boolean[] used;
  		public int[][] heap;
  		public int[] hIndex;
  		public int size;
  		public Heap(int n) {
  			used = new boolean[n + 1];
  			heap = new int[n + 1][2];
  			hIndex = new int[n + 1];
  			Arrays.fill(hIndex, -1);
  			size = 0;
  		}
  		public void add(int cur, int delay) {
  			if (used[cur]) {
  				return;
  			}
  			if (hIndex[cur] == -1) {
  				heap[size][0] = cur;
  				heap[size][1] = delay;
  				hIndex[cur] = size;
  				heapInsert(size++);
  			} else {
  				int hi = hIndex[cur];
  				if (delay <= heap[hi][1]) {
  					heap[hi][1] = delay;
  					heapInsert(hi);
  				}
  			}
  		}
  		public int[] poll() {
  			int[] ans = heap[0];
  			swap(0, --size);
  			heapify(0);
  			used[ans[0]] = true;
  			hIndex[ans[0]] = -1;
  			return ans;
  		}
  		public boolean isEmpty() {
  			return size == 0;
  		}
  		private void heapInsert(int i) {
  			int parent = (i - 1) / 2;
  			while (heap[i][1] < heap[parent][1]) {
  				swap(i, parent);
  				i = parent;
  				parent = (i - 1) / 2;
  			}
  		}
  		private void heapify(int i) {
  			int l = (i * 2) + 1;
  			while (l < size) {
  				int smallest = l + 1 < size && heap[l + 1][1] < heap[l][1] ? (l + 1) : l;
  				smallest = heap[smallest][1] < heap[i][1] ? smallest : i;
  				if (smallest == i) {
  					break;
  				}
  				swap(smallest, i);
  				i = smallest;
  				l = (i * 2) + 1;
  			}
  		}
  		private void swap(int i, int j) {
  			int[] o1 = heap[i];
  			int[] o2 = heap[j];
  			int o1hi = hIndex[o1[0]];
  			int o2hi = hIndex[o2[0]];
  			heap[i] = o2;
  			heap[j] = o1;
  			hIndex[o1[0]] = o2hi;
  			hIndex[o2[0]] = o1hi;
  		}
  	}</code>  </pre>
    </details>

### Dijkstra

- 链接：<a href="#">暂无</a>

- 内容：

  > 克鲁斯卡尔（kruskal）算法通常用于求出一个连通图中的最小生成树

- 思路：

  > 思路一：常规思路
  >
  > ​	以当前节点出发，先得到到所有节点的距离，得到最小的那个节点距离的节点
  >
  > ​	以此节点为跳板，尝试更新剩余节点的距离，再得到未使用的最小距离的节点
  >
  > ​	重复
  >
  > ​	直到所有的节点都被更新完全
  >
  > 思路二：加强堆
  >
  > ​	得到未使用的最小距离的节点，直接调用后删除节点，更新剩余节点的距离

- 代码：

  <details>
    <summary>常规思路</summary>
    <p> - 实现代码</p>
    <pre><code>public static HashMap<Node, Integer> dijkstra1(Node from) {
  		HashMap<Node, Integer> distanceMap = new HashMap<>();
  		distanceMap.put(from, 0);
  		// 打过对号的点
  		HashSet<Node> selectedNodes = new HashSet<>();
  		Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
  		while (minNode != null) {
  			//  原始点  ->  minNode(跳转点)   最小距离distance
  			int distance = distanceMap.get(minNode);
  			for (Edge edge : minNode.edges) {
  				Node toNode = edge.to;
  				if (!distanceMap.containsKey(toNode)) {
  					distanceMap.put(toNode, distance + edge.weight);
  				} else { // toNode 
  					distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));
  				}
  			}
  			selectedNodes.add(minNode);
  			minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
  		}
  		return distanceMap;
  	}
  	public static Node getMinDistanceAndUnselectedNode(HashMap<Node, Integer> distanceMap, HashSet<Node> touchedNodes) {
  		Node minNode = null;
  		int minDistance = Integer.MAX_VALUE;
  		for (Map.Entry<Node, Integer> entry : distanceMap.entrySet()) {
  			Node node = entry.getKey();
  			int distance = entry.getValue();
  			if (!touchedNodes.contains(node) && distance < minDistance) {
  				minNode = node;
  				minDistance = distance;
  			}
  		}
  		return minNode;
  	}</code>  </pre>
    </details>

  <details>
    <summary>加强堆</summary>
    <p> - 实现代码</p>
    <pre><code>	public static class NodeRecord {
  		public Node node;
  		public int distance;
  		public NodeRecord(Node node, int distance) {
  			this.node = node;
  			this.distance = distance;
  		}
  	}
  	public static class NodeHeap {
  		private Node[] nodes; // 实际的堆结构
  		// key 某一个node， value 上面堆中的位置
  		private HashMap<Node, Integer> heapIndexMap;
  		// key 某一个节点， value 从源节点出发到该节点的目前最小距离
  		private HashMap<Node, Integer> distanceMap;
  		private int size; // 堆上有多少个点
  		public NodeHeap(int size) {
  			nodes = new Node[size];
  			heapIndexMap = new HashMap<>();
  			distanceMap = new HashMap<>();
  			size = 0;
  		}
  		public boolean isEmpty() {
  			return size == 0;
  		}
  		// 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance
  		// 判断要不要更新，如果需要的话，就更新
  		public void addOrUpdateOrIgnore(Node node, int distance) {
  			if (inHeap(node)) {
  				distanceMap.put(node, Math.min(distanceMap.get(node), distance));
  				insertHeapify(heapIndexMap.get(node));
  			}
  			if (!isEntered(node)) {
  				nodes[size] = node;
  				heapIndexMap.put(node, size);
  				distanceMap.put(node, distance);
  				insertHeapify(size++);
  			}
  		}
  		public NodeRecord pop() {
  			NodeRecord nodeRecord = new NodeRecord(nodes[0], distanceMap.get(nodes[0]));
  			swap(0, size - 1);
  			heapIndexMap.put(nodes[size - 1], -1);
  			distanceMap.remove(nodes[size - 1]);
  			// free C++同学还要把原本堆顶节点析构，对java同学不必
  			nodes[size - 1] = null;
  			heapify(0, --size);
  			return nodeRecord;
  		}
  		private void insertHeapify(int index) {
  			while (distanceMap.get(nodes[index]) < distanceMap.get(nodes[(index - 1) / 2])) {
  				swap(index, (index - 1) / 2);
  				index = (index - 1) / 2;
  			}
  		}
  		private void heapify(int index, int size) {
  			int left = index * 2 + 1;
  			while (left < size) {
  				int smallest = left + 1 < size && distanceMap.get(nodes[left + 1]) < distanceMap.get(nodes[left])
  						? left + 1
  						: left;
  				smallest = distanceMap.get(nodes[smallest]) < distanceMap.get(nodes[index]) ? smallest : index;
  				if (smallest == index) {
  					break;
  				}
  				swap(smallest, index);
  				index = smallest;
  				left = index * 2 + 1;
  			}
  		}
  		private boolean isEntered(Node node) {
  			return heapIndexMap.containsKey(node);
  		}
  		private boolean inHeap(Node node) {
  			return isEntered(node) && heapIndexMap.get(node) != -1;
  		}
  		private void swap(int index1, int index2) {
  			heapIndexMap.put(nodes[index1], index2);
  			heapIndexMap.put(nodes[index2], index1);
  			Node tmp = nodes[index1];
  			nodes[index1] = nodes[index2];
  			nodes[index2] = tmp;
  		}
  	}
  	// 改进后的dijkstra算法
  	// 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回
  	public static HashMap<Node, Integer> dijkstra2(Node head, int size) {
  		NodeHeap nodeHeap = new NodeHeap(size);
  		nodeHeap.addOrUpdateOrIgnore(head, 0);
  		HashMap<Node, Integer> result = new HashMap<>();
  		while (!nodeHeap.isEmpty()) {
  			NodeRecord record = nodeHeap.pop();
  			Node cur = record.node;
  			int distance = record.distance;
  			for (Edge edge : cur.edges) {
  				nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);
  			}
  			result.put(cur, distance);
  		}
  		return result;
  	}</code>  </pre>
    </details>