# 线段树

## 基本内容

- 线段树

  >  **线段树（Segment Tree）**是一种常用的数据结构，用于解决涉及区间查询的问题。
  >
  > 它主要用于在数组或列表等数据结构上支持以下两类查询操作：
  >
  > 1. 区间查询：查询某个区间内的统计信息，例如求和、最大值、最小值等。
  >2. 区间更新：修改数组中某个区间元素的值，并相应地更新线段树中的信息。

## 问题集合

### SegmentTree

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class31/Code01_SegmentTree.java">测试链接</a>

- 内容：

  > 线段树的实现
  
- 思路：

  > 使用数组来存储信息，并懒住信息不往下发
  >
  > **集区间更新，区间添加，区间查询三位一体线段树实现**
  
- 代码：

  <details>
  <summary>segmentTree</summary>
  <p> - 线段树的实现</p>
  <pre><code>public static class SegmentTree {
  		// 默认下标从1开始
  		private int MAXN;
  		private int[] arr; // arr[]为原序列的信息从0开始，但在arr里是从1开始的
  		private int[] sum; // sum[]模拟线段树维护区间和
  		private int[] lazy; // lazy[]为累加和懒惰标记
  		private int[] change; // change[]为更新的值
  		private boolean[] update; // update[]为更新慵懒标记
  		public SegmentTree(int[] origin){
  			MAXN = origin.length + 1;
  			arr = new int[MAXN];
  			sum = new int[MAXN << 2];
  			lazy = new int[MAXN << 2];
  			change = new int[MAXN << 2];
  			update = new boolean[MAXN << 2];
  			for (int i = 1; i < MAXN; i++) {
  				arr[i] = origin[i - 1];
  			}
  		}
  		private void pushUp(int rt) {
  			sum[rt] = sum[rt << 1]+sum[rt << 1 | 1]; // 向上封装sum信息（求的是sum）
  		}
  		// 之前的，所有懒增加，和懒更新，从父范围，发给左右两个子范围
  		// 分发策略是什么
  		// ln表示左子树元素结点个数，rn表示右子树结点个数
  		private void pushDown(int rt, int ln, int rn) {
  			if(update[rt]){ // rt有更新信息，优先处理更新信息
  				update[rt << 1] = true;
  				update[rt << 1 | 1] = true;
  				change[rt << 1] = change[rt]; // 左右子树的更新信息
  				change[rt << 1 | 1] = change[rt];
  				lazy[rt << 1] = 0;  // 左右子树的懒信息
  				lazy[rt << 1 | 1] = 0;
  				sum[rt << 1] = change[rt] * ln; // 左右子树节点的数量*要更新的值
  				sum[rt << 1 | 1] = change[rt] * rn;
  				update[rt] = false; // 更新完毕
  			}
  			if(lazy[rt] != 0){ // 如果区间更新操作之后还有区间添加操作的话，要在原始更新后进行额外添加信息
  				lazy[rt << 1] += lazy[rt];  // 下放到左右子树的懒信息
  				lazy[rt << 1 | 1] += lazy[rt];
  				sum[rt << 1] += lazy[rt] * ln; // 左右子树节点的数量*要更新的值
  				sum[rt << 1 | 1] += lazy[rt] * rn;
  				lazy[rt] = 0; // 懒信息下放完毕
  			}
  		}
  		// 在初始化阶段，先把sum数组，填好
  		// 在arr[l~r]范围上，去build，1~N，
  		// rt : 这个范围在sum中的下标
  		public void build(int l, int r, int rt) {
  			if(l == r){
  				sum[rt] = arr[l];
  				return;
  			}
  			int mid =((r - l) >> 1) + l;
  			build(l,mid,rt << 1); // 把左子树的信息加好
  			build(mid+1,r,rt << 1 | 1); // 把右子树的信息加好
  			pushUp(rt); // 把左右子树的信息及当前信息加好
  		}
  		// L~R  所有的值变成C
  		// l~r  rt
  		public void update(int L, int R, int C, int l, int r, int rt) {
  			// 当l,r包含了L，R范围
  			if(L <= l && r <= R){
  				// 内部的值要全部更新
  				// 清除懒信息
  				update[rt] = true;
  				change[rt] = C;
  				sum[rt] = (r - l + 1) * C;
  				lazy[rt] = 0;
  				return;
  			}
  			// 当前任务l,r有一部分与L,R重合
  			int mid = ((r - l) >> 1) + l;
  			// 将所有的懒信息下发
  			pushDown(rt,mid - l + 1, r - mid);
  			if(L <= mid){
  				update(L,R,C,l,mid,rt << 1); // 左子树更新
  			}
  			if(mid < R){
  				update(L,R,C,mid+1,r,rt << 1 | 1); // 右子树更新
  			}
  			pushUp(rt); // 收上来的信息更新
  		}
  		// L~R, C 任务！
  		// rt，l~r
  		public void add(int L, int R, int C, int l, int r, int rt) {
  			if(L <= l && r <= R){
  				// 这个添加任务包含了当前区间,更新sum与下发的懒信息
  				sum[rt] += C * (r - l + 1);
  				lazy[rt] += C;
  				return;
  			}
  			// 没有全包
  			int mid = ((r - l) >> 1) + l;
  			pushDown(rt,mid - l + 1,r - mid); // 将更新与懒信息下放
  			if(L <= mid){
  				add(L,R,C,l,mid,rt << 1);
  			}
  			if(R > mid){
  				add(L,R,C,mid+1,r,rt << 1 | 1);
  			}
  			pushUp(rt); // 将收上来的信息进行更新
  		}
  		// 1~6 累加和是多少？ 1~8 rt
  		public long query(int L, int R, int l, int r, int rt) {
  			if(L <= l &&  r <= R){
  				return sum[rt];
  			}
  			int mid = ((r - l) >> 1) + l;
  			pushDown(rt,mid - l + 1,r - mid);
  			long ans = 0L;
  			if(L <= mid){
  				ans += query(L,R,l,mid,rt << 1);
  			}
  			if(mid < R){
  				ans += query(L,R,mid + 1,r,rt << 1 | 1);
  			}
  			return ans;
  		}
  	}</code>  </pre>
  </details>

### FallingSquares

- 链接：<a href="https://leetcode.cn/problems/falling-squares/description/">测试链接</a>

- 内容：

  > 在二维平面上的 x 轴上，放置着一些方块。
  >
  > 给你一个二维整数数组 `positions` ，其中 `positions[i] = [lefti, sideLengthi]` 表示：第 `i` 个方块边长为 `sideLengthi` ，其左侧边与 x 轴上坐标点 `lefti` 对齐。
  >
  > 每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 **另一个正方形的顶边** 或者是 **x 轴上** 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。
  >
  > 在每个方块掉落后，你必须记录目前所有已经落稳的 **方块堆叠的最高高度** 。
  >
  > 返回一个整数数组 `ans` ，其中 `ans[i]` 表示在第 `i` 块方块掉落后堆叠的最高高度。
  >
  > **示例 1：**
  >
  > ![img](https://assets.leetcode.com/uploads/2021/04/28/fallingsq1-plane.jpg)
  >
  > ```
  > 输入：positions = [[1,2],[2,3],[6,1]]
  > 输出：[2,5,5]
  > 解释：
  > 第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 2 。
  > 第 2 个方块掉落后，最高的堆叠由方块 1 和 2 组成，堆叠的最高高度为 5 。
  > 第 3 个方块掉落后，最高的堆叠仍然由方块 1 和 2 组成，堆叠的最高高度为 5 。
  > 因此，返回 [2, 5, 5] 作为答案。
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：positions = [[100,100],[200,100]]
  > 输出：[100,100]
  > 解释：
  > 第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 100 。
  > 第 2 个方块掉落后，最高的堆叠可以由方块 1 组成也可以由方块 2 组成，堆叠的最高高度为 100 。
  > 因此，返回 [100, 100] 作为答案。
  > 注意，方块 2 擦过方块 1 的右侧边，但不会算作在方块 1 上着陆。
  > ```

- 思路：

  > 线段树实现
  >
  > 从题意可知其涉及到了**区间查询，区间更新操作，区间求和改为了区间最大值**
  >
  > 并且使用了映射来减少空间的消耗

- 代码：

  <details>
  <summary>segmentTree</summary>
  <p> - 每次的最大值</p>
  <pre><code>public List<Integer> fallingSquares(int[][] positions) {
          // 为了防止贴边，我们把positions[i]的所在x轴区间改为positions[i][0]~positions[i][0]+positions[i][1]-1
          // index用于节省空间，将100，199，200，299直接映射为1，2，3，4，只需要使用5*4的max空间
          // 在100~199之间进行更新等价于在1~2之间进行更新
          HashMap<Integer, Integer> map = index(positions);
          int N = map.size();
          SegmentTree segmentTree = new SegmentTree(N);
          int max = 0;
          List<Integer> res = new ArrayList<>();
          // 每落一个正方形，收集一下，所有东西组成的图像，最高高度是什么
          for (int[] arr : positions) {
              int L = map.get(arr[0]);
              int R = map.get(arr[0] + arr[1] - 1);
              int height = segmentTree.query(L, R, 1, N, 1) + arr[1];
              max = Math.max(max, height);
              res.add(max);
              segmentTree.update(L, R, height, 1, N, 1);
          }
          return res;
      }
      public static HashMap<Integer,Integer> index(int[][] positions){
          TreeSet<Integer> pos = new TreeSet<>();
          for (int[] arr : positions) {
              pos.add(arr[0]);
              pos.add(arr[0] + arr[1] - 1);
          }
          HashMap<Integer, Integer> map = new HashMap<>();
          int count = 0;
          for (Integer index : pos) {
              map.put(index,++count);
          }
          return map;
      }
      public static class SegmentTree{
          int MAXN;
          int[] max;
          int[] arr;
          int[] change;
          boolean[] update;
          public SegmentTree(int N){
              MAXN = N + 1;
              arr = new int[MAXN];
              max = new int[MAXN << 2];
              change = new int[MAXN << 2];
              update = new boolean[MAXN << 2];
          }
          public void pushUp(int rt){
              max[rt] = Math.max(max[rt << 1] , max[rt << 1 | 1]);
          }
          public void pushDown(int rt){
              if(update[rt]){
                  update[rt << 1] = true;
                  update[rt << 1 | 1] = true;
                  change[rt << 1] = change[rt];
                  change[rt << 1 | 1] = change[rt];
                  max[rt << 1] = change[rt];
                  max[rt << 1 | 1] = change[rt];
                  update[rt] = false;
              }
          }
          public void update(int L,int R,int C,int l,int r,int rt){
              if(L <= l && r <= R){
                  update[rt] = true;
                  change[rt] = C;
                  max[rt] = C;
                  return;
              }
              int mid = ((r - l) >> 1) + l;
              pushDown(rt);
              if(L <= mid){
                  update(L,R,C,l,mid,rt << 1);
              }
              if(mid < R){
                  update(L,R,C,mid+1,r,rt << 1 | 1);
              }
              pushUp(rt);
          }
          public int query(int L,int R,int l,int r,int rt){
              if(L <= l && r <= R){
                  return max[rt];
              }
              int mid = ((r - l) >> 1) + l;
              pushDown(rt);
              int ans = 0;
              if(L <= mid) ans = Math.max(ans,query(L,R,l,mid,rt << 1));
              if(mid < R) ans = Math.max(ans,query(L,R,mid + 1,r,rt << 1 | 1));
              return ans;
          }
      }</code>  </pre>
  </details>
