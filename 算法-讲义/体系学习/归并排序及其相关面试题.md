# 归并排序及其相关面试题

## 归并排序

- 基础内容

  > 归并排序（Merge sort）是建立在归并操作上的一种有效的[排序算法](https://so.csdn.net/so/search?q=排序算法&spm=1001.2101.3001.7020)，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。

- 归并思路

  > 归并排序算法有两个基本的操作，一个是分，也就是把原数组划分成两个子数组的过程。另一个是治，它将两个有序数组合并成一个更大的有序数组。
  >
  > 将待排序的线性表不断地切分成若干个子表，直到每个子表只包含一个元素，这时，可以认为只包含一个元素的子表是有序表。
  > 将子表两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。

- 解题流程

  ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class04/mergeSort.png)

## 问题集合

### MergeSort

- 链接：<a href="https://leetcode.cn/problems/sort-an-array/description/">升序排列测试链接</a>

- 内容：

  > 给你一个整数数组 `nums`，请你将该数组升序排列。
  >
  > **示例 1：**
  >
  > ```java
  > 输入：nums = [5,2,3,1]
  > 输出：[1,2,3,5]
  > ```
  >
  > **示例 2：**
  >
  > ```java
  > 输入：nums = [5,1,1,2,0,0]
  > 输出：[0,0,1,1,2,5]
  > ```

- 思路：

  > 思路一：递归，分治
  >
  > 思路二：迭代

  ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class04/mergeSort.png)

  ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class04/mergeSort2.png)

- 代码：

  <details>
  <summary>递归排序代码</summary>
  <p> - 归并排序</p>
  <pre><code>	public static void mergeSort1(int[] arr) {
          if(arr == null || arr.length < 2) return;
          process(arr,0,arr.length - 1);
      }
      public static void process(int[] arr,int L,int R){
          if(L == R){
              return;
          }
          int mid = (R - L)/2 + L;
          process(arr,L,mid);
          process(arr,mid + 1,R);
          merge(arr,L,mid,R);
      }
      public static void merge(int[] arr,int L,int M,int R){
          int[] help = new int[R - L + 1];
          int p1 = L,p2 = M + 1,i = 0;
          while (p1 <= M && p2 <= R) {
              if(arr[p1] <= arr[p2]){
                  help[i++] = arr[p1++];
              }else{
                  help[i++] = arr[p2++];
              }
          }
          while (p1 <= M){
              help[i++] = arr[p1++];
          }
          while (p2 <= R){
              help[i++] = arr[p2++];
          }
          for (int j = 0; j < help.length; j++) {
              arr[L + j] = help[j];
          }
      }  </code>  </pre>
  </details>
  <details>
  <summary>迭代排序代码</summary>
  <p> - 归并排序</p>
  <pre><code>	public static void mergeSort2(int[] arr) {
          if(arr == null || arr.length < 2) return;
          int N = arr.length;
          int mergeSize = 1;
          while (mergeSize < N){
              int L = 0;
              while (L < N){
                  if(mergeSize >= N - L){
                      break;
                  }
                  int M = L + mergeSize - 1;
                  int R = M + Math.min(mergeSize,N - M - 1);
                  merge(arr,L,M,R);
                  L = R + 1;
              }
              // 防止溢出
              if(mergeSize > N / 2){
                  break;
              }
              mergeSize <<= 1;
          }
      }
      public static void merge(int[] arr,int L,int M,int R){
          int[] help = new int[R - L + 1];
          int p1 = L,p2 = M + 1,i = 0;
          while (p1 <= M && p2 <= R) {
              if(arr[p1] <= arr[p2]){
                  help[i++] = arr[p1++];
              }else{
                  help[i++] = arr[p2++];
              }
          }
          while (p1 <= M){
              help[i++] = arr[p1++];
          }
          while (p2 <= R){
              help[i++] = arr[p2++];
          }
          for (int j = 0; j < help.length; j++) {
              arr[L + j] = help[j];
          }
      }</code>  </pre>
  </details>

### SmallSum

- 链接：暂无

- 内容：

  > 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。
  >
  > 求一个数组的小和。
  >
  > 例子：
  >
  > [1,3,4,2,5]
  >
  >   1左边比1小的数，没有；
  >
  >   3左边比3小的数，1；
  >
  >   4左边比4小的数，1、3；
  >
  >   2左边比2小的数，1；
  >
  >   5左边比5小的数，1、3、4、2；
  >
  > 所以小和为1+1+3+1+1+3+4+2=16

- 思路：

  > 思路一：双重for循环 时间复杂度O(N^2)
  >
  > 思路二：归并 时间复杂度O(logN)

  ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class04/mergeSort.png)

  | 分治(治) | 对应数据           | 小和产生者                                         |
  | -------- | ------------------ | -------------------------------------------------- |
  | 第一次   | 8-4  5-7  1-3  6-2 | 5,7 1,3                                            |
  | 第二次   | 4,8-5,7 1,3-2,6    | 4,5 4,7 1,2 1,6 3,6                                |
  | 第三次   | 4,5,7,8 - 1,2,3,6  | 4,6 5,6                                            |
  | 默认     | 8,4,5,7,1,3,6,2    | 4,5  4,6  4,7  5,7  5,6  1,3  1,6  1,2  3,6 (暴力) |

- 代码：

  <details>
  <summary>递归排序求小和代码</summary>
  <p> - 归并排序</p>
  <pre><code>	public static int smallSum(int[] arr) {
          if(arr == null || arr.length < 2) return 0;
          return process(arr,0,arr.length - 1);
      }
      // arr[L..R]既要排好序，也要求小和返回
      // 所有merge时，产生的小和，累加
      // 左 排序   merge
      // 右 排序  merge
      // merge
      public static int process(int[] arr, int l, int r) {
         if(l == r) return 0;
         int mid = (r - l) / 2 + l;
         return process(arr,l,mid)
                 +process(arr,mid+1,r)
                 +merge(arr,l,mid,r);
      }
      public static int merge(int[] arr, int L, int M, int R) {
          int i = 0,smallSum = 0,p1 = L,p2 = M + 1;
          int[] help = new int[R - L + 1];
          while (p1 <= M && p2 <= R) {
              smallSum += arr[p1] < arr[p2] ? (R - p2 + 1) * arr[p1] : 0;
              help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
          }
          while (p1 <= M) {
              help[i++] = arr[p1++] ;
          }
          while (p2 <= R) {
              help[i++] = arr[p2++];
          }
          for (int j = 0; j < help.length; j++) {
              arr[L + j] = help[j];
          }
          return smallSum;
      }  </code>  </pre>
  </details>

### ReversePairs

- 链接：<a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/">逆序对的数量</a>

- 内容：

  > 在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 `record`，返回其中存在的「交易逆序对」总数。
  >
  > **示例 1:**
  >
  > ```
  > 输入：record = [9, 7, 5, 4, 6]
  > 输出：8
  > 解释：交易中的逆序对为 (9, 7), (9, 5), (9, 4), (9, 6), (7, 5), (7, 4), (7, 6), (5, 4)。
  > ```
  >
- 思路：

  > 思路一：双重for循环 时间复杂度O(N^2)
  >
  > 思路二：归并 时间复杂度O(logN)

  ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class04/mergeSort.png)

  | 分治(治) | 对应数据           | 逆序对产生者(与小和产生相反)                                 |
  | -------- | ------------------ | ------------------------------------------------------------ |
  | 第一次   | 8-4  5-7  1-3  6-2 | 8,4  6,2                                                     |
  | 第二次   | 4,8-5,7 1,3-2,6    | 8,5  8,7 3,2                                                 |
  | 第三次   | 4,5,7,8 - 1,2,3,6  | 4,1  4,2  4,3  5,1  5,2  5,3  7,1  7,2  7,3  7,6  8,1  8,2  8,3  8,6 |
  | 默认     | 8,4,5,7,1,3,6,2    | 8,4  8,5  8,6  8,7  8,1  8,3  8,6  8,2  4,1  4,3  4,2  5,1  5,3  5,2  7,1  7,3  7,6  7,2  3,2  6,2 (暴力) |

- 代码：

  <details>
  <summary>递归排序求逆序对数量代码</summary>
  <p> - 归并排序</p>
  <pre><code>	public int reversePairs(int[] record) {
          if(record == null || record.length < 2) return 0;
          return process(record,0,record.length - 1);
      }
      // arr[L..R]既要排好序，也要求小和返回
      // 所有merge时，产生的小和，累加
      // 左 排序   merge
      // 右 排序  merge
      // merge
      public static int process(int[] arr, int l, int r) {
          if(l == r) return 0;
          int mid = (r - l) / 2 + l;
          return process(arr,l,mid)
                  +process(arr,mid+1,r)
                  +merge(arr,l,mid,r);
      }
      public static int merge(int[] arr, int L, int M, int R) {
          int i = R - L + 1,reversePair = 0,p1 = M,p2 = R;
          int[] help = new int[R - L + 1];
          while (p1 >= L && p2 >= M + 1) {
              reversePair += arr[p1] > arr[p2] ? p2 - M : 0;
              help[--i] = arr[p1] > arr[p2] ? arr[p1--] : arr[p2--];
          }
          while (p1 >= L) {
              help[--i] = arr[p1--];
          }
          while (p2 >= M + 1) {
              help[--i] = arr[p2--];
          }
          for (int j = 0; j < help.length; j++) {
              arr[L + j] = help[j];
          }
          return reversePair;
      }  </code>  </pre>
  </details>

### BiggerThanRightTwice

- 链接：<a href="https://leetcode.cn/problems/reverse-pairs/description/">翻转对的数量</a>

- 内容：

  > 给定一个数组 `nums` ，如果 `i < j` 且 `nums[i] > 2*nums[j]` 我们就将 `(i, j)` 称作一个**重要翻转对**。
  >
  > 你需要返回给定数组中的重要翻转对的数量。
  >
  > **示例 1:**
  >
  > ```
  > 输入: [1,3,2,3,1]
  > 输出: 2
  > ```
  >
  > **示例 2:**
  >
  > ```
  > 输入: [2,4,3,5,1]
  > 输出: 3
  > ```
  
- 思路：

  > 思路一：双重for循环 时间复杂度O(N^2)
  >
  > 思路二：归并 时间复杂度O(logN)

  ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class04/mergeSort.png)

  | 分治(治) | 对应数据           | 翻转对产生者(与逆序对产生类似)                               |
  | -------- | ------------------ | ------------------------------------------------------------ |
  | 第一次   | 8-4  5-7  1-3  6-2 | 6,2                                                          |
  | 第二次   | 4,8-5,7 1,3-2,6    | 无                                                           |
  | 第三次   | 4,5,7,8 - 1,2,3,6  | 4,1    5,1  5,2    7,1  7,2  7,3   8,1  8,2  8,3             |
  | 默认     | 8,4,5,7,1,3,6,2    | 8,1  8,3    8,2  4,1   5,1   5,2  7,1  7,3   7,2   6,2 (暴力) |

- 代码：

    <details>
    <summary>递归排序求翻转对数量代码</summary>
    <p> - 归并排序</p>
    <pre><code>	public int reversePairs(int[] record) {
            if(record == null || record.length < 2) return 0;
            return process(record,0,record.length - 1);
        }
        // arr[L..R]既要排好序，也要求小和返回
        // 所有merge时，产生的小和，累加
        // 左 排序   merge
        // 右 排序  merge
        // merge
        public static int process(int[] arr, int l, int r) {
            if(l == r) return 0;
            int mid = (r - l) / 2 + l;
            return process(arr,l,mid)
                    +process(arr,mid+1,r)
                    +merge(arr,l,mid,r);
        }
        public static int merge(int[] arr, int L, int M, int R) {
            int i = R - L + 1,reversePair = 0,p1 = M,p2 = R;
            int[] help = new int[R - L + 1];
            while (p1 >= L && p2 >= M + 1) {
                reversePair += arr[p1] > arr[p2] ? p2 - M : 0;
                help[--i] = arr[p1] > arr[p2] ? arr[p1--] : arr[p2--];
            }
            while (p1 >= L) {
                help[--i] = arr[p1--];
            }
            while (p2 >= M + 1) {
                help[--i] = arr[p2--];
            }
            for (int j = 0; j < help.length; j++) {
                arr[L + j] = help[j];
            }
            return reversePair;
        }  </code>  </pre>
    </details>