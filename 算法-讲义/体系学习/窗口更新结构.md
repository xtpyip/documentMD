# 窗口更新结构

## 基础内容

- 定义

  > 滑动窗口法，也叫尺取法，可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。
  >
  > 由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。

- 一般流程

  > 1、我们在数组（字符串） S中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。
  >
  > 2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的数据符合要求
  >
  > 3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的数据不再符合要求。同时，每次增加 left，我们都要更新一轮结果。
  >
  > 4、重复第 2 和第 3 步，直到 right 到达S 的尽头。
  > 

## 问题集合

### SlidingWindowMaxArray

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class24/Code01_SlidingWindowMaxArray.java">测试链接</a>

- 内容：

  > 假设一个固定大小为W的窗口，依次划过arr,返回每一次滑出状况的最大值
  >
  > 例如,arr = [4,3,5,4,3,3,6,7],W = 3
  >
  > 返回∶[5.5,5,4,6,7]

- 思路：

  > 思路一：暴力尝试
  >
  > 思路二：滑动窗口（记录下标）

- 代码：

  <details>
  <summary>暴力尝试</summary>
  <p> - 最大值数组</p>
  <pre><code>// 暴力的对数器方法
      public static int[] right(int[] arr, int w) {
          if (arr == null || w < 1 || arr.length < w) {
              return null;
          }
          int N = arr.length;
          int[] res = new int[N - w + 1];
          int index = 0;
          int L = 0;
          int R = w - 1;
          while (R < N) {
              int max = arr[L];
              for (int i = L + 1; i <= R; i++) {
                  max = Math.max(max, arr[i]);
              }
              res[index++] = max;
              L++;
              R++;
          }
          return res;
      }</code>  </pre>
  </details>

  <details>
  <summary>滑动窗口</summary>
  <p> - 最大值数组</p>
  <pre><code>    public static int[] getMaxWindow(int[] arr, int w) {
          if(arr == null || w < 1 || arr.length < w) return null;
          int n = arr.length,index = 0;
          int[] ans = new int[n - w + 1];
          LinkedList<Integer> qMax = new LinkedList<>(); // 存储下标
          for (int R = 0; R < n; R++) {
              while (!qMax.isEmpty() && arr[qMax.peekLast()] <= arr[R]){
                  qMax.pollLast();
              }
              qMax.addLast(R);
              if(qMax.peekFirst() == R - w){ // L = 0 R = 3 w = 3=> 1,2,3为窗口，当L=R-w时L出队
                  qMax.pollFirst();
              }
              if(R >= w - 1){
                  ans[index++] = arr[qMax.peekFirst()];
              }
          }
          return ans;
      }</code>  </pre>
  </details>

### AllLessNumSubArray

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class24/Code02_AllLessNumSubArray.java">测试链接</a>

- 内容：

  > 给定一个整型数组arr，和一个整数num
  >
  > 某个arr中的子数组sub，如果想达标，必须满足∶sub中最大值- sub中最小值<= num,
  >
  > 返回arr中达标子数组的数量

- 思路：

  > 思路一：暴力尝试
  >
  > 思路二：滑动窗口

- 代码：

  <details>
  <summary>暴力尝试</summary>
  <p> - 最大值数组</p>
  <pre><code>	// 暴力的对数器方法
  	public static int right(int[] arr, int sum) {
  		if (arr == null || arr.length == 0 || sum < 0) {
  			return 0;
  		}
  		int N = arr.length;
  		int count = 0;
  		for (int L = 0; L < N; L++) {
  			for (int R = L; R < N; R++) {
  				int max = arr[L];
  				int min = arr[L];
  				for (int i = L + 1; i <= R; i++) {
  					max = Math.max(max, arr[i]);
  					min = Math.min(min, arr[i]);
  				}
  				if (max - min <= sum) {
  					count++;
  				}
  			}
  		}
  		return count;
  	}</code>  </pre>
  </details>

  <details>
  <summary>滑动窗口</summary>
  <p> - 最大值数组</p>
  <pre><code>public static int num(int[] arr, int sum) {
  		if (arr == null || arr.length == 0 || sum < 0) {
  			return 0;
  		}
  		int n = arr.length;
  		int ans = 0;
  		LinkedList<Integer> qMax = new LinkedList<>(); // 存放下标（最大值及其在之后指定区间内的最大值）
  		LinkedList<Integer> qMin = new LinkedList<>();
  		int R = 0;
  		for (int L = 0; L < n; L++) {
  			while (R < n){
  				while(!qMax.isEmpty() && arr[qMax.peekLast()] <= arr[R]){
  					qMax.pollLast();
  				}
  				qMax.addLast(R);
  				while (!qMin.isEmpty() && arr[qMin.peekLast()] >= arr[R]){
  					qMin.pollLast();
  				}
  				qMin.addLast(R);
  				// 以L~R当前区间的最大值与最小值之间是否满足条件
  				if(arr[qMax.peekFirst()] - arr[qMin.peekFirst()] > sum){
  					break;
  				}else{
  					R++;
  				}
  			}
  			ans += R - L;
  			if(qMax.peekFirst() == L){
  				qMax.pollFirst();
  			}
  			if(qMin.peekFirst() == L){
  				qMin.pollFirst();
  			}
  		}
  		return ans;
  	}</code>  </pre>
  </details>

### GasStation

- 链接：<a href="https://leetcode.cn/problems/gas-station/description/">测试链接</a>

- 内容：

  > 在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。
  >
  > 你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。
  >
  > 给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。
  >
  > **示例 1:**
  >
  > ```
  > 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
  > 输出: 3
  > 解释:
  > 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
  > 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
  > 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
  > 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
  > 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
  > 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
  > 因此，3 可为起始索引。
  > ```
  >
  > **示例 2:**
  >
  > ```
  > 输入: gas = [2,3,4], cost = [3,4,3]
  > 输出: -1
  > 解释:
  > 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
  > 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
  > 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
  > 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
  > 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
  > 因此，无论怎样，你都不可能绕环路行驶一周。
  > ```

- 思路：

  > 思路一：暴力尝试
  >
  > 思路二：滑动窗口
  >
  > 思路三：贪心

- 代码：

  <details>
  <summary>暴力尝试</summary>
  <p> - 出发点</p>
  <pre><code>	// 这个方法的时间复杂度O(N)，额外空间复杂度O(N)
  	public static int canCompleteCircuit(int[] gas, int[] cost) {
  		boolean[] good = goodArray(gas, cost);
  		for (int i = 0; i < gas.length; i++) {
  			if (good[i]) {
  				return i;
  			}
  		}
  		return -1;
  	}
  	public static boolean[] goodArray(int[] g, int[] c) {
  		int N = g.length;
  		int M = N << 1;
  		int[] arr = new int[M];
  		for (int i = 0; i < N; i++) {// 倍增
  			arr[i] = g[i] - c[i]; // 求每一个站的差额
  			arr[i + N] = g[i] - c[i];
  		}
  		for (int i = 1; i < M; i++) { // 前缀和
  			arr[i] += arr[i - 1];
  		}
  		// ... 在生成的前缀和数组中，以N为长度逐一进行尝试，O(N^2),略
  		return null;
  	}</code>  </pre>
  </details>

  <details>
  <summary>滑动窗口</summary>
  <p> - 开始出发点</p>
  <pre><code>	// 这个方法的时间复杂度O(N)，额外空间复杂度O(N)
  	public static int canCompleteCircuit(int[] gas, int[] cost) {
  		boolean[] good = goodArray(gas, cost);
  		for (int i = 0; i < gas.length; i++) {
  			if (good[i]) {
  				return i;
  			}
  		}
  		return -1;
  	}
  	public static boolean[] goodArray(int[] g, int[] c) {
  		int N = g.length;
  		int M = N << 1;
  		int[] arr = new int[M];
  		for (int i = 0; i < N; i++) {// 倍增
  			arr[i] = g[i] - c[i]; // 求每一个站的差额
  			arr[i + N] = g[i] - c[i];
  		}
  		for (int i = 1; i < M; i++) { // 前缀和
  			arr[i] += arr[i - 1];
  		}
  		// 举个例子说明一下
  		// 比如纯能数组(也就是燃料 - 距离之后)的数组 :
  		// 纯能数组 = 3, 2,-6, 2, 3,-4, 6
  		// 数组下标 = 0  1  2  3  4  5  6
  		// 客观上说:
  		// 0位置不是良好出发点
  		// 1位置不是良好出发点
  		// 2位置不是良好出发点
  		// 3位置是良好出发点
  		// 4位置不是良好出发点
  		// 5位置不是良好出发点
  		// 6位置是良好出发点
  		// 把数组增倍之后 : 
  		// arr   = 3, 2,-6, 2, 3,-4, 6, 3, 2,-6, 2, 3,-4, 6
  		// 然后计算前缀和 :
  		// arr   = 3, 5,-1, 1, 4, 0, 6, 9,11, 5, 7,10, 6,12
  		// index = 0  1  2  3  4  5  6  7  8  9 10 11 12 13
  		// 这些就是上面发生的过程
  		// 接下来生成长度为N的窗口
  		LinkedList<Integer> w = new LinkedList<>();
  		for (int i = 0; i < N; i++) {
  			while (!w.isEmpty() && arr[w.peekLast()] >= arr[i]) {
  				w.pollLast();
  			}
  			w.addLast(i);
  		}
  		// 上面的过程，就是先遍历N个数，然后建立窗口
  		// arr   =[3, 5,-1, 1, 4, 0, 6],9,11, 5, 7,10, 6,12
  		// index = 0  1  2  3  4  5  6  7  8  9 10 11 12 13
  		// w中的内容如下:
  		// index:  2 5 6
  		// value: -1 0 6
  		// 左边是头，右边是尾，从左到右严格变大
  		// 此时代表最原始的arr的这部分的数字: 
  		// 原始的值 = [3, 2,-6, 2, 3,-4, 6],3, 2,-6, 2, 3,-4, 6
  		// 原始下标 =  0  1  2  3  4  5  6  0  1  2  3  4  5  6
  		// 上面这个窗口中，累加和最薄弱的点，就是w中最左信息
  		// 也就是会累加出，-1这个值，所以会走不下去。
  		// 宣告了此时0位置不是良好出发点。
  		// 接下来的代码，就是依次考察每个点是不是良好出发点。
  		// 目前的信息是:
  		// 计算的前缀和 :
  		// arr   =[3, 5,-1, 1, 4, 0, 6],9,11, 5, 7,10, 6,12
  		// index = 0  1  2  3  4  5  6  7  8  9 10 11 12 13
  		// w中的内容如下:
  		// index:  2 5 6
  		// value: -1 0 6
  		// 此时代表最原始的arr的这部分的数字: 
  		// 原始的值 = [3, 2,-6, 2, 3,-4, 6],3, 2,-6, 2, 3,-4, 6
  		// 原始下标 =  0  1  2  3  4  5  6  0  1  2  3  4  5  6
  		// 现在让窗口往下移动
  		// 计算的前缀和 :
  		// arr   = 3,[5,-1, 1, 4, 0, 6, 9],11, 5, 7,10, 6,12
  		// index = 0  1  2  3  4  5  6  7   8  9 10 11 12 13
  		// w中的内容如下:
  		// index:  2 5 6 7
  		// value: -1 0 6 9
  		// 此时代表最原始的arr的这部分的数字: 
  		// 原始的值 =  3,[2,-6, 2, 3,-4, 6, 3],2,-6, 2, 3,-4, 6
  		// 原始下标 =  0  1  2  3  4  5  6  0  1  2  3  4  5  6
  		// 上面这个窗口中，累加和最薄弱的点，就是w中最左信息
  		// 但是w最左的值是-1啊！而这个窗口中最薄弱的累加和是-4啊。
  		// 对！所以最薄弱信息 = 窗口中的最左信息 - 窗口左侧刚出去的数(代码中的offset!)
  		// 所以，最薄弱信息 = -1 - 0位置的3(窗口左侧刚出去的数) = -4
  		// 看到了吗？最薄弱信息，依靠这种方式，加工出来了！
  		// 宣告了此时1位置不是良好出发点。
  		// 我们继续，让窗口往下移动
  		// 计算的前缀和 :
  		// arr   = 3, 5,[-1, 1, 4, 0, 6, 9,11], 5, 7,10, 6,12
  		// index = 0  1   2  3  4  5  6  7  8   9 10 11 12 13
  		// w中的内容如下:
  		// index:  2  5  6  7  8
  		// value: -1  0  6  9 11
  		// 此时代表最原始的arr的这部分的数字: 
  		// 原始的值 =  3, 2,[-6, 2, 3,-4, 6, 3, 2],-6, 2, 3,-4, 6
  		// 原始下标 =  0  1   2  3  4  5  6  0  1   2  3  4  5  6
  		// 上面这个窗口中，累加和最薄弱的点，就是w中最左信息
  		// 但是w最左的值是-1啊！而这个窗口中最薄弱的累加和是-6啊。
  		// 对！所以最薄弱信息 = 窗口中的最左信息 - 窗口左侧刚出去的数(代码中的offset!)
  		// 所以，最薄弱信息 = -1 - 1位置的5(窗口左侧刚出去的数) = -6
  		// 看到了吗？最薄弱信息，依靠这种方式，加工出来了！
  		// 宣告了此时2位置不是良好出发点。
  		// 我们继续，让窗口往下移动
  		// 计算的前缀和 :
  		// arr   = 3, 5, -1,[1, 4, 0, 6, 9,11, 5], 7,10, 6,12
  		// index = 0  1   2  3  4  5  6  7  8  9  10 11 12 13
  		// w中的内容如下:
  		// index:  5  9
  		// value:  0  5
  		// 没错，9位置的5进来，让6、7、8位置从w的尾部弹出了，
  		// 同时原来在w中的2位置已经过期了，所以也弹出了，因为窗口左边界已经划过2位置了
  		// 此时代表最原始的arr的这部分的数字: 
  		// 原始的值 =  3, 2, -6,[2, 3,-4, 6, 3, 2, -6],2, 3,-4, 6
  		// 原始下标 =  0  1   2  3  4  5  6  0  1   2  3  4  5  6
  		// 上面这个窗口中，累加和最薄弱的点，就是w中最左信息
  		// 但是w最左的值是0啊！而这个窗口中最薄弱的累加和是1啊
  		// 对！所以最薄弱信息 = 窗口中的最左信息 - 窗口左侧刚出去的数(代码中的offset!)
  		// 所以，最薄弱信息 = 0 - 2位置的-1(窗口左侧刚出去的数) = 1
  		// 看到了吗？最薄弱信息，依靠这种方式，加工出来了！
  		// 宣告了此时3位置是良好出发点。
  		// 往下同理
  		boolean[] ans = new boolean[N];
  		for (int offset = 0, i = 0, j = N; j < M; offset = arr[i++], j++) {
  			if (arr[w.peekFirst()] - offset >= 0) {
  				ans[i] = true;
  			}
  			if (w.peekFirst() == i) {
  				w.pollFirst();
  			}
  			while (!w.isEmpty() && arr[w.peekLast()] >= arr[j]) {
  				w.pollLast();
  			}
  			w.addLast(j);
  		}
  		return ans;
  	}</code>  </pre>
  </details>

  <details>
  <summary>贪心</summary>
  <p> - 开始出发点</p>
  <pre><code>	public static int canCompleteCircuit1(int[] gas, int[] cost) {
  		int n = gas.length;
  		int i = 0;
  		while (i < n) {
  			int sumOfGas = 0, sumOfCost = 0; // 油与耗费问题
  			int cnt = 0; // 到达的数量
  			while (cnt < n) { // 数量不足n时
  				int j = (i + cnt) % n; // 下一个位置，如果当前是n-1，下一个为0
  				sumOfGas += gas[j];
  				sumOfCost += cost[j];
  				if (sumOfCost > sumOfGas) { // 到达不了当前位置
  					break;
  				}
  				cnt++; // 能到达
  			}
  			if (cnt == n) { // 完成了一圈
  				return i;
  			} else {
  				// 贪心，i能到达i+100位置，i+1最多也只能到达i+100位置，因为沿途sumOfGas>=sumOfCost
  				i = i + cnt + 1;
  			}
  		}
  		return -1;
  	}</code>  </pre>
  </details>

### MinCoinsOnePaper

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class24/Code04_MinCoinsOnePaper.java">测试链接</a>

- 内容：

  > arr是货币数组，其中的值都是正数。
  >
  > 再给定一个正数aim。每个值都认为是一张货币，返回组成aim的最少货币数
  >
  > 注意︰
  >
  > 因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了

- 思路：

  > 思路一：暴力递归尝试
  >
  > 思路二：dp
  >
  > 思路三：dp 不优化 O(arr长度) + O(货币种数 * aim * 每种货币的平均张数)
  >
  > 思路四：滑动窗口

- 代码：

  <details>
  <summary>暴力递归尝试</summary>
  <p> - 最少货币数</p>
  <pre><code>	public static int minCoins(int[] arr, int aim) {
  		return process(arr, 0, aim);
  	}
  	public static int process(int[] arr, int index, int rest) {
  		if (rest < 0) {
  			return Integer.MAX_VALUE;
  		}
  		if (index == arr.length) {
  			return rest == 0 ? 0 : Integer.MAX_VALUE;
  		} else {
  			int p1 = process(arr, index + 1, rest);
  			int p2 = process(arr, index + 1, rest - arr[index]);
  			if (p2 != Integer.MAX_VALUE) {
  				p2++;
  			}
  			return Math.min(p1, p2);
  		}
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp</summary>
  <p> - 最少货币数</p>
  <pre><code>	// dp1时间复杂度为：O(arr长度 * aim)
  	public static int dp1(int[] arr, int aim) {
  		if (aim == 0) {
  			return 0;
  		}
  		int N = arr.length;
  		int[][] dp = new int[N + 1][aim + 1];
  		dp[N][0] = 0;
  		for (int j = 1; j <= aim; j++) {
  			dp[N][j] = Integer.MAX_VALUE;
  		}
  		for (int index = N - 1; index >= 0; index--) {
  			for (int rest = 0; rest <= aim; rest++) {
  				int p1 = dp[index + 1][rest];
  				int p2 = rest - arr[index] >= 0 ? dp[index + 1][rest - arr[index]] : Integer.MAX_VALUE;
  				if (p2 != Integer.MAX_VALUE) {
  					p2++;
  				}
  				dp[index][rest] = Math.min(p1, p2);
  			}
  		}
  		return dp[0][aim];
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp不优化</summary>
  <p> - 最少货币数</p>
  <pre><code>	// dp1时间复杂度为：O(arr长度 * aim)
  	public static int dp1(int[] arr, int aim) {
  		if (aim == 0) {
  			return 0;
  		}
  		int N = arr.length;
  		int[][] dp = new int[N + 1][aim + 1];
  		dp[N][0] = 0;
  		for (int j = 1; j <= aim; j++) {
  			dp[N][j] = Integer.MAX_VALUE;
  		}
  		for (int index = N - 1; index >= 0; index--) {
  			for (int rest = 0; rest <= aim; rest++) {
  				int p1 = dp[index + 1][rest];
  				int p2 = rest - arr[index] >= 0 ? dp[index + 1][rest - arr[index]] : Integer.MAX_VALUE;
  				if (p2 != Integer.MAX_VALUE) {
  					p2++;
  				}
  				dp[index][rest] = Math.min(p1, p2);
  			}
  		}
  		return dp[0][aim];
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp优化</summary>
  <p> - 最少货币数</p>
  <pre><code>	// dp3时间复杂度为：O(arr长度) + O(货币种数 * aim)
  	// 优化需要用到窗口内最小值的更新结构
  	public static int dp3(int[] arr, int aim) {
  		if (aim == 0) {
  			return 0;
  		}
  		// 得到info时间复杂度O(arr长度)
  		Info info = getInfo(arr);
  		int[] c = info.coins;
  		int[] z = info.zhangs;
  		int N = c.length;
  		int[][] dp = new int[N + 1][aim + 1];
  		dp[N][0] = 0;
  		for (int j = 1; j <= aim; j++) {
  			dp[N][j] = Integer.MAX_VALUE;
  		}
  		// 虽然是嵌套了很多循环，但是时间复杂度为O(货币种数 * aim)
  		// 因为用了窗口内最小值的更新结构
  		for (int i = N - 1; i >= 0; i--) {
  			for (int mod = 0; mod < Math.min(aim + 1, c[i]); mod++) {
  				// 当前面值 X
  				// mod mod + x mod + 2*x mod + 3 * x
  				LinkedList<Integer> w = new LinkedList<>();
  				w.add(mod);
  				dp[i][mod] = dp[i + 1][mod];
  				for (int r = mod + c[i]; r <= aim; r += c[i]) {
  					while (!w.isEmpty() && (dp[i + 1][w.peekLast()] == Integer.MAX_VALUE
  							|| dp[i + 1][w.peekLast()] + compensate(w.peekLast(), r, c[i]) >= dp[i + 1][r])) {
  						w.pollLast();
  					}
  					w.addLast(r);
  					int overdue = r - c[i] * (z[i] + 1);
  					if (w.peekFirst() == overdue) {
  						w.pollFirst();
  					}
  					if (dp[i + 1][w.peekFirst()] == Integer.MAX_VALUE) {
  						dp[i][r] = Integer.MAX_VALUE;
  					} else {
  						dp[i][r] = dp[i + 1][w.peekFirst()] + compensate(w.peekFirst(), r, c[i]);
  					}
  				}
  			}
  		}
  		return dp[0][aim];
  	}
  	public static int compensate(int pre, int cur, int coin) {
  		return (cur - pre) / coin;
  	}</code>  </pre>
  </details>