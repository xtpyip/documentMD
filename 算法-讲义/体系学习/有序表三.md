# 有序表三

## 基本内容

- AVL树

  > 平衡二叉树全称叫做 `平衡二叉搜索（排序）树`，简称 AVL树。英文：Balanced Binary Tree （BBT），注：二叉查找树(BST)
  >
  > AVL树本质上是一颗二叉查找树，但是它又具有以下特点：
  >
  > - 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，
  > - 左右两个子树 也都是一棵平衡二叉树。

- SBT

  > 每棵子树的大小，不小于其兄弟的子树的大小，也就是每棵叔叔树的大小，不小于任何侄子树的大小。

- 跳表

  > 对于单链表，即使是 存储的有序数据（即 有序链表），想在其中查找某个数据，也只能从头到尾遍历，查找效率低，时间复杂度是O(n)，如下图所示：
  >
  > ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class36/skipListMap1.png)
  >
  > 怎么才能提高查找效率呢？ 
  >
  > 为了提高查找效率，使用二分查找的思想，对有序链表建立一级“索引”。 每两个节点提取一个节点到索引层。 索引层中的每个节点 都包含两个指针，一个指向下一个节点，一个down指针，指向下一级节点。
  >
  > ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class36/skipListMap2.png)
  >
  > 假设要查找图中 18这个节点：
  >
  > 首先在一级索引层遍历，当遍历到14这个节点的时候，发现其下一个节点是23，则要查找的18就在14和23之间。 然后，通过14节点的 down 指针，下降到原始链表这一层，继续在原始链表中遍历。 此时，只需要在原始链表中，遍历两个节点，14和18,就找到18这个节点了。    查找18这个节点，在原始链表需要遍历10个节点，现在只需要遍历7个节点（一级索引层遍历5个节点，原始链表遍历2个节点）。 
  >
  > 从以上示例可以看出，加上一层索引之后，查找一个节点的遍历节点数减少了，效率提高了。如果再增加一级索引，那么效率会不会更高呢？
  >
  > 建立二级索引
  >
  > 与建立一级索引的方式类似，在第一级索引的基础上，每两个节点抽出一个节点到第二级索引，如下图：
  >
  > ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class36/skipListMap3.png)
  >
  >  现在如果要查找18节点，只需要遍历6个节点（二级索引层遍历3个节点，一级索引层1个节点，原始链表2个节点）。
  >
  > 通过建立索引的方式，对于数据量越大的有序链表，通过建立多级索引，查找效率提升会非常明显。
  >
  > 这种链表加多级索引的结构 就是 跳表。
  >

## 问题集合

### CountOfRangeSum

- 链接：<a href="https://leetcode.cn/problems/count-of-range-sum/description/">测试链接</a>

- 内容：

  > 给你一个整数数组 `nums` 以及两个整数 `lower` 和 `upper` 。求数组中，值位于范围 `[lower, upper]` （包含 `lower` 和 `upper`）之内的 **区间和的个数** 。
  >
  > **区间和** `S(i, j)` 表示在 `nums` 中，位置从 `i` 到 `j` 的元素之和，包含 `i` 和 `j` (`i` ≤ `j`)。
  >
  >  
  >
  > **示例 1：**
  >
  > ```
  > 输入：nums = [-2,5,-1], lower = -2, upper = 2
  > 输出：3
  > 解释：存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：nums = [0], lower = 0, upper = 0
  > 输出：1
  > ```
  
- 思路：

  > 思路一：归并排序(见<a href="http://8.130.177.90:8094/#/DetailArticle?aid=12">详情</a>)
  >
  > 思路二：改写sb树实现
  >
  > > example：[4,5,3,-1,5,7,4,0,4,6]  [6,9]
  > >
  > > ans = 以[0]位置为最后的子数组的数量+以[1]位置为最后的子数组的数量+...+以[n-1]位置为最后的子数组的数量
  > >
  > > 以[n-1]位置为最后的子数组的数量 = 以[0]为开始的子数组在[Sum_(n_1) - 9,Sum_(n-1) - 6]的数量
  > >
  > > ...
  > >
  > > 可以把原始问题转化为
  > >
  > > 当前i的值为arr[i]，求之前所有子数组的和在[Sum_(n_1) - 9,Sum_(n-1) - 6]区间的数量
  > >
  > > 为了使其方便，可以在前面添加一个0
  > >
  > > 如下表
  >
  > | 当前下标 | 当前值 | 以0开始的子数组的和        | 前缀和 | 要求的区间（变换） | 满足数量                                         |
  > | -------- | ------ | -------------------------- | ------ | ------------------ | ------------------------------------------------ |
  > | 0        | 4      | 0(开始就添加的)            | 4      | [-5,-2]            | 0(如果4在区间中，那么有一个数字0在，直接能得到1) |
  > | 1        | 5      | 0,4                        | 9      | [0,3]              | 1                                                |
  > | 2        | 3      | 0,4,9                      | 12     | [3,6]              | 1                                                |
  > | ...      | ...    | ...                        | ...    | ...                | ...                                              |
  > | n-1      | 6      | 0,4,9,12,11,16,23,27,27,31 | 37     | [28,31]            | 1                                                |
  >
  > >根据上述的流程，我们可以看出，我们要设计一个结构满足以下几个方面
  > >
  > >1、能够添加重复值
  > >
  > >2、可以计算<num的数量
  > >
  > >3、时间复杂度要尽量低
  > >
  > >使用改写sb树的方法
  > >
  > >如下代码，all表示以自己为根的节点的树的节点数量 (all - c.l.all - c.r.all) 为自己这个节点为5的数量
  > >
  > >满足1和3
  > >
  > >计算< num的数量
  > >
  > >​	c.key < num    ans+=c.all - c.r.all
  > >
  > >c.key == num ans += c.all - c.l.all -c.r.all
  > >
  > >c.key > num   c = c.left
  > >
  > >直到结束
  
- 代码：

  <details>
  <summary>改写SBT</summary>
  <p> - 区间和的个数</p>
  <pre><code>	public static class SBTNode {
          public long key; // 当前的key值
          public SBTNode l;
          public SBTNode r;
          public long size; // 不同key的size
          public long all; // 总的size
          public SBTNode(long k) {
              key = k;
              size = 1;
              all = 1;
          }
      }
      public static class SizeBalancedTreeSet {
          private SBTNode root;
          private HashSet<Long> set = new HashSet<>();
          private SBTNode rightRotate(SBTNode cur) {
              long same = cur.all - (cur.l != null ? cur.l.all : 0) - (cur.r != null ? cur.r.all : 0);
              SBTNode leftNode = cur.l;
              cur.l = leftNode.r;
              leftNode.r = cur;
              leftNode.size = cur.size;
              cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
              // all modify
              leftNode.all = cur.all;
              cur.all = (cur.l != null ? cur.l.all : 0) + (cur.r != null ? cur.r.all : 0) + same;
              return leftNode;
          }
          private SBTNode leftRotate(SBTNode cur) {
              long same = cur.all - (cur.l != null ? cur.l.all : 0) - (cur.r != null ? cur.r.all : 0);
              SBTNode rightNode = cur.r;
              cur.r = rightNode.l;
              rightNode.l = cur;
              rightNode.size = cur.size;
              cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
              // all modify
              rightNode.all = cur.all;
              cur.all = (cur.l != null ? cur.l.all : 0) + (cur.r != null ? cur.r.all : 0) + same;
              return rightNode;
          }
          private SBTNode maintain(SBTNode cur) {
              if (cur == null) {
                  return null;
              }
              long leftSize = cur.l != null ? cur.l.size : 0;
              long leftLeftSize = cur.l != null && cur.l.l != null ? cur.l.l.size : 0;
              long leftRightSize = cur.l != null && cur.l.r != null ? cur.l.r.size : 0;
              long rightSize = cur.r != null ? cur.r.size : 0;
              long rightLeftSize = cur.r != null && cur.r.l != null ? cur.r.l.size : 0;
              long rightRightSize = cur.r != null && cur.r.r != null ? cur.r.r.size : 0;
              if (leftLeftSize > rightSize) {
                  cur = rightRotate(cur);
                  cur.r = maintain(cur.r);
                  cur = maintain(cur);
              } else if (leftRightSize > rightSize) {
                  cur.l = leftRotate(cur.l);
                  cur = rightRotate(cur);
                  cur.l = maintain(cur.l);
                  cur.r = maintain(cur.r);
                  cur = maintain(cur);
              } else if (rightRightSize > leftSize) {
                  cur = leftRotate(cur);
                  cur.l = maintain(cur.l);
                  cur = maintain(cur);
              } else if (rightLeftSize > leftSize) {
                  cur.r = rightRotate(cur.r);
                  cur = leftRotate(cur);
                  cur.l = maintain(cur.l);
                  cur.r = maintain(cur.r);
                  cur = maintain(cur);
              }
              return cur;
          }
          private SBTNode add(SBTNode cur, long key, boolean contains) {
              if (cur == null) {
                  return new SBTNode(key);
              } else {
                  cur.all++;
                  if (key == cur.key) {
                      return cur;
                  } else { // 还在左滑或者右滑
                      if (!contains) {
                          cur.size++;
                      }
                      if (key < cur.key) {
                          cur.l = add(cur.l, key, contains);
                      } else {
                          cur.r = add(cur.r, key, contains);
                      }
                      return maintain(cur);
                  }
              }
          }
          public void add(long sum) {
              boolean contains = set.contains(sum);
              root = add(root, sum, contains);
              set.add(sum);
          }
          public long lessKeySize(long key) {
              SBTNode cur = root;
              long ans = 0;
              while (cur != null) {
                  if (key == cur.key) {
                      return ans + (cur.l != null ? cur.l.all : 0);
                  } else if (key < cur.key) {
                      cur = cur.l;
                  } else {
                      ans += cur.all - (cur.r != null ? cur.r.all : 0);
                      cur = cur.r;
                  }
              }
              return ans;
          }
          // > 7 8...
          // <8 ...<=7
          public long moreKeySize(long key) {
              return root != null ? (root.all - lessKeySize(key + 1)) : 0;
          }
      }
      public static int countRangeSum2(int[] nums, int lower, int upper) {
          // 黑盒，加入数字（前缀和），不去重，可以接受重复数字
          // < num , 有几个数？
          SizeBalancedTreeSet treeSet = new SizeBalancedTreeSet();
          long sum = 0;
          int ans = 0;
          treeSet.add(0);// 一个数都没有的时候，就已经有一个前缀和累加和为0，
          for (int i = 0; i < nums.length; i++) {
              sum += nums[i];
              // [sum - upper, sum - lower]
              // [10, 20] ?
              // < 10 ?  < 21 ?
              long a = treeSet.lessKeySize(sum - lower + 1);
              long b = treeSet.lessKeySize(sum - upper);
              ans += a - b;
              treeSet.add(sum);
          }
          return ans;
      }</code>  </pre>
  </details>

### SlidingWindowMedian

- 链接：<a href="https://leetcode.cn/problems/sliding-window-median/description/">测试链接</a>

- 内容：

  > 中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。
  >
  > 例如：
  >
  > - `[2,3,4]`，中位数是 `3`
  > - `[2,3]`，中位数是 `(2 + 3) / 2 = 2.5`
  >
  > 给你一个数组 *nums*，有一个长度为 *k* 的窗口从最左端滑动到最右端。窗口中有 *k* 个数，每次窗口向右移动 *1* 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。
  >
  > **示例：**
  >
  > 给出 *nums* = `[1,3,-1,-3,5,3,6,7]`，以及 *k* = 3。
  >
  > ```
  > 窗口位置                      中位数
  > ---------------               -----
  > [1  3  -1] -3  5  3  6  7       1
  >  1 [3  -1  -3] 5  3  6  7      -1
  >  1  3 [-1  -3  5] 3  6  7      -1
  >  1  3  -1 [-3  5  3] 6  7       3
  >  1  3  -1  -3 [5  3  6] 7       5
  >  1  3  -1  -3  5 [3  6  7]      6
  > ```
  >
  >  因此，返回该滑动窗口的中位数数组 `[1,-1,-1,3,5,6]`。

- 思路：

  > 思路一：队列实现(略)
  >
  > 思路二：改写sb树实现
  >
  > 我们可以创建一个结构，它满足以下要求
  >
  > 1、数据可重复
  >
  > 2、可以求出当前第几个位置的数字
  >
  > 3、复杂度较低
  >
  > 改写sb树
  >
  > ​     5,6
  >
  > 3,2     7,3
  >
  > 表示5有1个数，且左子树为2，右子树为3
  >
  > 若位置为4，则（6-3） = 3 ，位置4在右子树 -》以7为根的树找第1个节点

- 代码：

  <details>
  <summary>改写SBT</summary>
  <p> - 各个时候的中位数</p>
  <pre><code>	public static class SBTNode<K extends Comparable<K>> {
  		public K key;
  		public SBTNode<K> l;
  		public SBTNode<K> r;
  		public int size;
  		public SBTNode(K k) {
  			key = k;
  			size = 1;
  		}
  	}
  	public static class SizeBalancedTreeMap<K extends Comparable<K>> {
  		private SBTNode<K> root;
  		private SBTNode<K> rightRotate(SBTNode<K> cur) {
  			SBTNode<K> leftNode = cur.l;
  			cur.l = leftNode.r;
  			leftNode.r = cur;
  			leftNode.size = cur.size;
  			cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
  			return leftNode;
  		}
  		private SBTNode<K> leftRotate(SBTNode<K> cur) {
  			SBTNode<K> rightNode = cur.r;
  			cur.r = rightNode.l;
  			rightNode.l = cur;
  			rightNode.size = cur.size;
  			cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
  			return rightNode;
  		}
  		private SBTNode<K> maintain(SBTNode<K> cur) {
  			if (cur == null) {
  				return null;
  			}
  			int leftSize = cur.l != null ? cur.l.size : 0;
  			int leftLeftSize = cur.l != null && cur.l.l != null ? cur.l.l.size : 0;
  			int leftRightSize = cur.l != null && cur.l.r != null ? cur.l.r.size : 0;
  			int rightSize = cur.r != null ? cur.r.size : 0;
  			int rightLeftSize = cur.r != null && cur.r.l != null ? cur.r.l.size : 0;
  			int rightRightSize = cur.r != null && cur.r.r != null ? cur.r.r.size : 0;
  			if (leftLeftSize > rightSize) {
  				cur = rightRotate(cur);
  				cur.r = maintain(cur.r);
  				cur = maintain(cur);
  			} else if (leftRightSize > rightSize) {
  				cur.l = leftRotate(cur.l);
  				cur = rightRotate(cur);
  				cur.l = maintain(cur.l);
  				cur.r = maintain(cur.r);
  				cur = maintain(cur);
  			} else if (rightRightSize > leftSize) {
  				cur = leftRotate(cur);
  				cur.l = maintain(cur.l);
  				cur = maintain(cur);
  			} else if (rightLeftSize > leftSize) {
  				cur.r = rightRotate(cur.r);
  				cur = leftRotate(cur);
  				cur.l = maintain(cur.l);
  				cur.r = maintain(cur.r);
  				cur = maintain(cur);
  			}
  			return cur;
  		}
  		private SBTNode<K> findLastIndex(K key) {
  			SBTNode<K> pre = root;
  			SBTNode<K> cur = root;
  			while (cur != null) {
  				pre = cur;
  				if (key.compareTo(cur.key) == 0) {
  					break;
  				} else if (key.compareTo(cur.key) < 0) {
  					cur = cur.l;
  				} else {
  					cur = cur.r;
  				}
  			}
  			return pre;
  		}
  		private SBTNode<K> add(SBTNode<K> cur, K key) {
  			if (cur == null) {
  				return new SBTNode<K>(key);
  			} else {
  				cur.size++;
  				if (key.compareTo(cur.key) < 0) {
  					cur.l = add(cur.l, key);
  				} else {
  					cur.r = add(cur.r, key);
  				}
  				return maintain(cur);
  			}
  		}
  		private SBTNode<K> delete(SBTNode<K> cur, K key) {
  			cur.size--;
  			if (key.compareTo(cur.key) > 0) {
  				cur.r = delete(cur.r, key);
  			} else if (key.compareTo(cur.key) < 0) {
  				cur.l = delete(cur.l, key);
  			} else {
  				if (cur.l == null && cur.r == null) {
  					// free cur memory -> C++
  					cur = null;
  				} else if (cur.l == null && cur.r != null) {
  					// free cur memory -> C++
  					cur = cur.r;
  				} else if (cur.l != null && cur.r == null) {
  					// free cur memory -> C++
  					cur = cur.l;
  				} else {
  					SBTNode<K> pre = null;
  					SBTNode<K> des = cur.r;
  					des.size--;
  					while (des.l != null) {
  						pre = des;
  						des = des.l;
  						des.size--;
  					}
  					if (pre != null) {
  						pre.l = des.r;
  						des.r = cur.r;
  					}
  					des.l = cur.l;
  					des.size = des.l.size + (des.r == null ? 0 : des.r.size) + 1;
  					// free cur memory -> C++
  					cur = des;
  				}
  			}
  			return cur;
  		}
  		private SBTNode<K> getIndex(SBTNode<K> cur, int kth) {
  			if (kth == (cur.l != null ? cur.l.size : 0) + 1) {
  				return cur;
  			} else if (kth <= (cur.l != null ? cur.l.size : 0)) {
  				return getIndex(cur.l, kth);
  			} else {
  				return getIndex(cur.r, kth - (cur.l != null ? cur.l.size : 0) - 1);
  			}
  		}
  		public int size() {
  			return root == null ? 0 : root.size;
  		}
  		public boolean containsKey(K key) {
  			if (key == null) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			SBTNode<K> lastNode = findLastIndex(key);
  			return lastNode != null && key.compareTo(lastNode.key) == 0 ? true : false;
  		}
  		public void add(K key) {
  			if (key == null) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			SBTNode<K> lastNode = findLastIndex(key);
  			if (lastNode == null || key.compareTo(lastNode.key) != 0) {
  				root = add(root, key);
  			}
  		}
  		public void remove(K key) {
  			if (key == null) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			if (containsKey(key)) {
  				root = delete(root, key);
  			}
  		}
  		public K getIndexKey(int index) {
  			if (index < 0 || index >= this.size()) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			return getIndex(root, index + 1).key;
  		}
  	}
  	public static class Node implements Comparable<Node> {
  		public int index;
  		public int value;
  		public Node(int i, int v) {
  			index = i;
  			value = v;
  		}
  		@Override
  		public int compareTo(Node o) {
  			return value != o.value ? Integer.valueOf(value).compareTo(o.value)
  					: Integer.valueOf(index).compareTo(o.index);
  		}
  	}
  	public static double[] medianSlidingWindow(int[] nums, int k) {
  		SizeBalancedTreeMap<Node> map = new SizeBalancedTreeMap<>();
  		for (int i = 0; i < k - 1; i++) {
  			map.add(new Node(i, nums[i]));
  		}
  		double[] ans = new double[nums.length - k + 1];
  		int index = 0;
  		for (int i = k - 1; i < nums.length; i++) {
  			map.add(new Node(i, nums[i]));
  			if (map.size() % 2 == 0) {
  				Node upmid = map.getIndexKey(map.size() / 2 - 1);
  				Node downmid = map.getIndexKey(map.size() / 2);
  				ans[index++] = ((double) upmid.value + (double) downmid.value) / 2;
  			} else {
  				Node mid = map.getIndexKey(map.size() / 2);
  				ans[index++] = (double) mid.value;
  			}
  			map.remove(new Node(i - k + 1, nums[i - k + 1]));
  		}
  		return ans;
  	}</code>  </pre>
  </details>

### AddRemoveGetIndexGreat

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class37/Code03_AddRemoveGetIndexGreat.java">测试链接</a>

- 内容：

  > 实现arraylist并使其添加删除指定index的时间复杂度最小。
  
- 思路：

  > 使用改写sb树的方法
  >
  > sb树的左旋，右旋操作是不会改变sb树的中序遍历顺序的，这也是数组的顺序
  >
  > 在指定index中添加或删除后，sb树会进行补丁操作，但它的中序遍历顺序是不变的，这保证了通过下标来get时的准确性。

- 代码：

  <details>
  <summary>改写SBT</summary>
  <p> - 各个时候的中位数</p>
  <pre><code>	public static class SBTNode<K extends Comparable<K>> {
  		public K key;
  		public SBTNode<K> l;
  		public SBTNode<K> r;
  		public int size;
  		public SBTNode(K k) {
  			key = k;
  			size = 1;
  		}
  	}
  	public static class SizeBalancedTreeMap<K extends Comparable<K>> {
  		private SBTNode<K> root;
  		private SBTNode<K> rightRotate(SBTNode<K> cur) {
  			SBTNode<K> leftNode = cur.l;
  			cur.l = leftNode.r;
  			leftNode.r = cur;
  			leftNode.size = cur.size;
  			cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
  			return leftNode;
  		}
  		private SBTNode<K> leftRotate(SBTNode<K> cur) {
  			SBTNode<K> rightNode = cur.r;
  			cur.r = rightNode.l;
  			rightNode.l = cur;
  			rightNode.size = cur.size;
  			cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
  			return rightNode;
  		}
  		private SBTNode<K> maintain(SBTNode<K> cur) {
  			if (cur == null) {
  				return null;
  			}
  			int leftSize = cur.l != null ? cur.l.size : 0;
  			int leftLeftSize = cur.l != null && cur.l.l != null ? cur.l.l.size : 0;
  			int leftRightSize = cur.l != null && cur.l.r != null ? cur.l.r.size : 0;
  			int rightSize = cur.r != null ? cur.r.size : 0;
  			int rightLeftSize = cur.r != null && cur.r.l != null ? cur.r.l.size : 0;
  			int rightRightSize = cur.r != null && cur.r.r != null ? cur.r.r.size : 0;
  			if (leftLeftSize > rightSize) {
  				cur = rightRotate(cur);
  				cur.r = maintain(cur.r);
  				cur = maintain(cur);
  			} else if (leftRightSize > rightSize) {
  				cur.l = leftRotate(cur.l);
  				cur = rightRotate(cur);
  				cur.l = maintain(cur.l);
  				cur.r = maintain(cur.r);
  				cur = maintain(cur);
  			} else if (rightRightSize > leftSize) {
  				cur = leftRotate(cur);
  				cur.l = maintain(cur.l);
  				cur = maintain(cur);
  			} else if (rightLeftSize > leftSize) {
  				cur.r = rightRotate(cur.r);
  				cur = leftRotate(cur);
  				cur.l = maintain(cur.l);
  				cur.r = maintain(cur.r);
  				cur = maintain(cur);
  			}
  			return cur;
  		}
  		private SBTNode<K> findLastIndex(K key) {
  			SBTNode<K> pre = root;
  			SBTNode<K> cur = root;
  			while (cur != null) {
  				pre = cur;
  				if (key.compareTo(cur.key) == 0) {
  					break;
  				} else if (key.compareTo(cur.key) < 0) {
  					cur = cur.l;
  				} else {
  					cur = cur.r;
  				}
  			}
  			return pre;
  		}
  		private SBTNode<K> add(SBTNode<K> cur, K key) {
  			if (cur == null) {
  				return new SBTNode<K>(key);
  			} else {
  				cur.size++;
  				if (key.compareTo(cur.key) < 0) {
  					cur.l = add(cur.l, key);
  				} else {
  					cur.r = add(cur.r, key);
  				}
  				return maintain(cur);
  			}
  		}
  		private SBTNode<K> delete(SBTNode<K> cur, K key) {
  			cur.size--;
  			if (key.compareTo(cur.key) > 0) {
  				cur.r = delete(cur.r, key);
  			} else if (key.compareTo(cur.key) < 0) {
  				cur.l = delete(cur.l, key);
  			} else {
  				if (cur.l == null && cur.r == null) {
  					// free cur memory -> C++
  					cur = null;
  				} else if (cur.l == null && cur.r != null) {
  					// free cur memory -> C++
  					cur = cur.r;
  				} else if (cur.l != null && cur.r == null) {
  					// free cur memory -> C++
  					cur = cur.l;
  				} else {
  					SBTNode<K> pre = null;
  					SBTNode<K> des = cur.r;
  					des.size--;
  					while (des.l != null) {
  						pre = des;
  						des = des.l;
  						des.size--;
  					}
  					if (pre != null) {
  						pre.l = des.r;
  						des.r = cur.r;
  					}
  					des.l = cur.l;
  					des.size = des.l.size + (des.r == null ? 0 : des.r.size) + 1;
  					// free cur memory -> C++
  					cur = des;
  				}
  			}
  			return cur;
  		}
  		private SBTNode<K> getIndex(SBTNode<K> cur, int kth) {
  			if (kth == (cur.l != null ? cur.l.size : 0) + 1) {
  				return cur;
  			} else if (kth <= (cur.l != null ? cur.l.size : 0)) {
  				return getIndex(cur.l, kth);
  			} else {
  				return getIndex(cur.r, kth - (cur.l != null ? cur.l.size : 0) - 1);
  			}
  		}
  		public int size() {
  			return root == null ? 0 : root.size;
  		}
  		public boolean containsKey(K key) {
  			if (key == null) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			SBTNode<K> lastNode = findLastIndex(key);
  			return lastNode != null && key.compareTo(lastNode.key) == 0 ? true : false;
  		}
  		public void add(K key) {
  			if (key == null) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			SBTNode<K> lastNode = findLastIndex(key);
  			if (lastNode == null || key.compareTo(lastNode.key) != 0) {
  				root = add(root, key);
  			}
  		}
  		public void remove(K key) {
  			if (key == null) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			if (containsKey(key)) {
  				root = delete(root, key);
  			}
  		}
  		public K getIndexKey(int index) {
  			if (index < 0 || index >= this.size()) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			return getIndex(root, index + 1).key;
  		}
  	}
  	public static class Node implements Comparable<Node> {
  		public int index;
  		public int value;
  		public Node(int i, int v) {
  			index = i;
  			value = v;
  		}
  		@Override
  		public int compareTo(Node o) {
  			return value != o.value ? Integer.valueOf(value).compareTo(o.value)
  					: Integer.valueOf(index).compareTo(o.index);
  		}
  	}
  	public static double[] medianSlidingWindow(int[] nums, int k) {
  		SizeBalancedTreeMap<Node> map = new SizeBalancedTreeMap<>();
  		for (int i = 0; i < k - 1; i++) {
  			map.add(new Node(i, nums[i]));
  		}
  		double[] ans = new double[nums.length - k + 1];
  		int index = 0;
  		for (int i = k - 1; i < nums.length; i++) {
  			map.add(new Node(i, nums[i]));
  			if (map.size() % 2 == 0) {
  				Node upmid = map.getIndexKey(map.size() / 2 - 1);
  				Node downmid = map.getIndexKey(map.size() / 2);
  				ans[index++] = ((double) upmid.value + (double) downmid.value) / 2;
  			} else {
  				Node mid = map.getIndexKey(map.size() / 2);
  				ans[index++] = (double) mid.value;
  			}
  			map.remove(new Node(i - k + 1, nums[i - k + 1]));
  		}
  		return ans;
  	}</code>  </pre>
  </details>

### QueueReconstructionByHeight

- 链接：<a href="https://leetcode.cn/problems/sliding-window-median/description/">测试链接</a>

- 内容：

  > 假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。
  >
  > 请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。
  >
  > **示例 1：**
  >
  > ```
  > 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
  > 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
  > 解释：
  > 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
  > 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
  > 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
  > 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
  > 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
  > 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
  > 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
  > 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
  > ```

- 思路：

  > 思路一：辅助类排序+list
  >
  > 思路二：辅助类排序+sbT

- 代码：

  <details>
  <summary>辅助类排序+list</summary>
  <p> - 重建队列</p>
  <pre><code>public static int[][] reconstructQueue1(int[][] people) {
  		int N = people.length;
  		Unit[] units = new Unit[N];
  		for (int i = 0; i < N; i++) {
  			units[i] = new Unit(people[i][0], people[i][1]);
  		}
  		Arrays.sort(units, new UnitComparator());
  		ArrayList<Unit> arrList = new ArrayList<>();
  		for (Unit unit : units) {
  			arrList.add(unit.k, unit);
  		}
  		int[][] ans = new int[N][2];
  		int index = 0;
  		for (Unit unit : arrList) {
  			ans[index][0] = unit.h;
  			ans[index++][1] = unit.k;
  		}
  		return ans;
  	}
  	public static class Unit {
  		public int h;
  		public int k;
  		public Unit(int height, int greater) {
  			h = height;
  			k = greater;
  		}
  	}
  	public static class UnitComparator implements Comparator<Unit> {
  		@Override
  		public int compare(Unit o1, Unit o2) {
  			return o1.h != o2.h ? (o2.h - o1.h) : (o1.k - o2.k);
  		}
  	}</code>  </pre>
  </details>

  <details>
  <summary>辅助类排序+sbt</summary>
  <p> - 重建队列</p>
  <pre><code>public static int[][] reconstructQueue2(int[][] people) {
  		int N = people.length;
  		Unit[] units = new Unit[N];
  		for (int i = 0; i < N; i++) {
  			units[i] = new Unit(people[i][0], people[i][1]);
  		}
  		Arrays.sort(units, new UnitComparator());
  		SBTree tree = new SBTree();
  		for (int i = 0; i < N; i++) {
  			tree.insert(units[i].k, i);
  		}
  		LinkedList<Integer> allIndexes = tree.allIndexes();
  		int[][] ans = new int[N][2];
  		int index = 0;
  		for (Integer arri : allIndexes) {
  			ans[index][0] = units[arri].h;
  			ans[index++][1] = units[arri].k;
  		}
  		return ans;
  	}
      public static class SBTNode {
  		public int value;
  		public SBTNode l;
  		public SBTNode r;
  		public int size;
  		public SBTNode(int arrIndex) {
  			value = arrIndex;
  			size = 1;
  		}
  	}
      	public static class Unit {
  		public int h;
  		public int k;
  		public Unit(int height, int greater) {
  			h = height;
  			k = greater;
  		}
  	}
  	public static class UnitComparator implements Comparator<Unit> {
  		@Override
  		public int compare(Unit o1, Unit o2) {
  			return o1.h != o2.h ? (o2.h - o1.h) : (o1.k - o2.k);
  		}
  	}
  	public static class SBTree {
  		private SBTNode root;
  		private SBTNode rightRotate(SBTNode cur) {
  			SBTNode leftNode = cur.l;
  			cur.l = leftNode.r;
  			leftNode.r = cur;
  			leftNode.size = cur.size;
  			cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
  			return leftNode;
  		}
  		private SBTNode leftRotate(SBTNode cur) {
  			SBTNode rightNode = cur.r;
  			cur.r = rightNode.l;
  			rightNode.l = cur;
  			rightNode.size = cur.size;
  			cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
  			return rightNode;
  		}
  		private SBTNode maintain(SBTNode cur) {
  			if (cur == null) {
  				return null;
  			}
  			int leftSize = cur.l != null ? cur.l.size : 0;
  			int leftLeftSize = cur.l != null && cur.l.l != null ? cur.l.l.size : 0;
  			int leftRightSize = cur.l != null && cur.l.r != null ? cur.l.r.size : 0;
  			int rightSize = cur.r != null ? cur.r.size : 0;
  			int rightLeftSize = cur.r != null && cur.r.l != null ? cur.r.l.size : 0;
  			int rightRightSize = cur.r != null && cur.r.r != null ? cur.r.r.size : 0;
  			if (leftLeftSize > rightSize) {
  				cur = rightRotate(cur);
  				cur.r = maintain(cur.r);
  				cur = maintain(cur);
  			} else if (leftRightSize > rightSize) {
  				cur.l = leftRotate(cur.l);
  				cur = rightRotate(cur);
  				cur.l = maintain(cur.l);
  				cur.r = maintain(cur.r);
  				cur = maintain(cur);
  			} else if (rightRightSize > leftSize) {
  				cur = leftRotate(cur);
  				cur.l = maintain(cur.l);
  				cur = maintain(cur);
  			} else if (rightLeftSize > leftSize) {
  				cur.r = rightRotate(cur.r);
  				cur = leftRotate(cur);
  				cur.l = maintain(cur.l);
  				cur.r = maintain(cur.r);
  				cur = maintain(cur);
  			}
  			return cur;
  		}
  		private SBTNode insert(SBTNode root, int index, SBTNode cur) {
  			if (root == null) {
  				return cur;
  			}
  			root.size++;
  			int leftAndHeadSize = (root.l != null ? root.l.size : 0) + 1;
  			if (index < leftAndHeadSize) {
  				root.l = insert(root.l, index, cur);
  			} else {
  				root.r = insert(root.r, index - leftAndHeadSize, cur);
  			}
  			root = maintain(root);
  			return root;
  		}
  		private SBTNode get(SBTNode root, int index) {
  			int leftSize = root.l != null ? root.l.size : 0;
  			if (index < leftSize) {
  				return get(root.l, index);
  			} else if (index == leftSize) {
  				return root;
  			} else {
  				return get(root.r, index - leftSize - 1);
  			}
  		}
  		private void process(SBTNode head, LinkedList<Integer> indexes) {
  			if (head == null) {
  				return;
  			}
  			process(head.l, indexes);
  			indexes.addLast(head.value);
  			process(head.r, indexes);
  		}
  		public void insert(int index, int value) {
  			SBTNode cur = new SBTNode(value);
  			if (root == null) {
  				root = cur;
  			} else {
  				if (index <= root.size) {
  					root = insert(root, index, cur);
  				}
  			}
  		}
  		public int get(int index) {
  			SBTNode ans = get(root, index);
  			return ans.value;
  		}
  		public LinkedList<Integer> allIndexes() {
  			LinkedList<Integer> indexes = new LinkedList<>();
  			process(root, indexes);
  			return indexes;
  		}
  	}</code>  </pre>
  </details>
