# 并查集及其相关题目

## 基础内容

- 并查集

  > **定义**：
  > 并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。
  >
  > **主要构成：**
  > 并查集主要由一个整型数组pre[ ]和两个函数find( )、join( )构成。
  >
  > 数组 pre[ ] 记录了每个点的前驱节点是谁，函数 find(x) 用于查找指定节点 x 属于哪个集合，函数 join(x,y) 用于合并两个节点 x 和 y 。

## 问题集合

### FriendCircles(NumberOfProvinces)

- 链接：<a href="https://leetcode.cn/problems/number-of-provinces/description/">测试链接</a>

- 内容：

  > 有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。
  >
  > **省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
  >
  > 给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。
  >
  > 返回矩阵中 **省份** 的数量。
  >
  >  
  >
  > **示例 1：**
  >
  > ![img](https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg)
  >
  > ```
  > 输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
  > 输出：2
  > ```
  >
  > **示例 2：**
  >
  > ![img](https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg)
  >
  > ```
  > 输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
  > 输出：3
  > ```

- 思路：

  > 并查集

- 代码：

  <details>
    <summary>并查集</summary>
    <p> - 集合的数量</p>
    <pre><code> public static int findCircleNum(int[][] M) {
          int N = M.length;
          UnionFriend uf = new UnionFriend(N);
          for (int i = 0; i < N; i++) {
              for (int j = i+1; j < M[0].length; j++) {
                  if(M[i][j] == 1){
                      uf.union(i,j);
                  }
              }
          }
          return uf.size();
      }
      public static class UnionFriend{
          public static int[] parent;
          public static int[] size;
          public static int[] help;
          public UnionFriend(int length){
              parent = new int[length];
              size = new int[length];
              help = new int[length];
              init();
          }
          public void init(){
              for (int i = 0; i < parent.length; i++) {
                  parent[i] = i;
                  size[i] = 1;
              }
          }
          // 查找代表位置
          public  int find(int i){
              int helpIndex = 0;
              while (i != parent[i]){
                  help[helpIndex++] = i;
                  i = parent[i];
              }
              while (helpIndex > 0){
                  parent[help[--helpIndex]] = i;
              }
              return i;
          }
          // 合并
          public  void union(int x,int y){
              int xFather = find(x);
              int yFather = find(y);
              if(xFather != yFather){
                  int xSize = size[xFather];
                  int ySize = size[yFather];
                  if(xSize > ySize){
                      parent[yFather] = xFather;
                      size[xFather] = ySize + xSize;
                      size[yFather] = 0;
                  }else{
                      parent[xFather] = yFather;
                      size[yFather] = ySize + xSize;
                      size[xFather] = 0;
                  }
              }
          }
          // 集合数量
          public int size(){
              int res = 0;
              for (int i = 0; i < size.length; i++) {
                  res += size[i] == 0 ? 0 : 1;
              }
              return res;
          }
      }</code>  </pre>
    </details>

### NumberOfIsLands

- 链接：<a href="https://leetcode.cn/problems/number-of-islands/description/">测试链接</a>

- 内容：

  > 给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。
  >
  > 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
  >
  > 此外，你可以假设该网格的四条边均被水包围。
  >
  > **示例 1：**
  >
  > ```
  > 输入：grid = [
  >   ["1","1","1","1","0"],
  >   ["1","1","0","1","0"],
  >   ["1","1","0","0","0"],
  >   ["0","0","0","0","0"]
  > ]
  > 输出：1
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：grid = [
  >   ["1","1","0","0","0"],
  >   ["1","1","0","0","0"],
  >   ["0","0","1","0","0"],
  >   ["0","0","0","1","1"]
  > ]
  > 输出：3
  > ```

- 思路：

  > 思路一：感染法
  >
  > 思路二：并查集（二维转一维）

- 代码：

  <details>
    <summary>感染法</summary>
    <p> - 集合的数量</p>
    <pre><code> public int numIslands1(char[][] grid) {
          int n = grid.length,m = grid[0].length;
          int ans = 0;
          for (int i = 0; i < n; i++) {
              for (int j = 0; j < m; j++) {
                  if(grid[i][j] == '1'){
                      ans++;
                      inject(grid,i,j);
                  }
              }
          }
          return ans;
      }
      public static void inject(char[][] grid,int i,int j){
          if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != '1'){
              return;
          }
          grid[i][j] = '#';
          inject(grid,i-1,j);
          inject(grid,i,j-1);
          inject(grid,i+1,j);
          inject(grid,i,j+1);
      }</code>  </pre>
    </details>

  <details>
    <summary>并查集</summary>
    <p> - 集合的数量</p>
    <pre><code> public int numIslands2(char[][] grid) {
          int n = grid.length,m = grid[0].length;
          UnionFind uf = new UnionFind(grid);
          for (int i = 0; i < n - 1; i++) {
              for (int j = 0; j < m - 1; j++) {
                  if(grid[i][j] == '1' && grid[i][j+1] == '1'){
                      uf.union(i,j,i,j+1);
                  }
                  if(grid[i][j] == '1' && grid[i+1][j] == '1'){
                      uf.union(i,j,i+1,j);
                  }
              }
          }
          for (int i = 0; i < n - 1; i++) {
              if(grid[i][m-1] == '1' && grid[i+1][m-1] == '1') uf.union(i,m-1,i+1,m-1);
          }
          for (int i = 0; i < m - 1; i++) {
              if(grid[n-1][i] == '1' && grid[n-1][i+1] == '1') uf.union(n-1,i,n-1,i+1);
          }
          return uf.size();
      }
      public static class UnionFind{
          private static int[] parent;
          private static int[] size;
          private static int[] help;
          private static int col;
          private static int sets;
          public UnionFind(char[][] board) {
              col = board[0].length;
              sets = 0;
              int row = board.length;
              int len = row * col;
              parent = new int[len];
              size = new int[len];
              help = new int[len];
              for (int r = 0; r < row; r++) {
                  for (int c = 0; c < col; c++) {
                      if (board[r][c] == '1') {
                          int i = r * col + c;
                          parent[i] = i;
                          size[i] = 1;
                          sets++;
                      }
                  }
              }
          }
          // find
          public int find(int r,int c){
              int index = col * r + c;
              int hi = 0;
              while (index != parent[index]){
                  help[hi++] = index;
                  index = parent[index];
              }
              while (hi > 0){
                  parent[help[--hi]] = index;
              }
              return index;
          }
          // union
          public void union(int r1,int c1,int r2,int c2){
              int father1 = find(r1, c1);
              int father2 = find(r2, c2);
              if(father1 != father2){
                  int size1 = size[father1];
                  int size2 = size[father2];
                  if(size1 > size2){
                      parent[father2] = father1;
                      size[father1] = size1 + size2;
                      size[father2] = 0;
                  }else{
                      parent[father1] = father2;
                      size[father2] = size1 + size2;
                      size[father1] = 0;
                  }
                  sets--;
              }
          }
          public int size(){
              return sets;
          }
      }</code>  </pre>
    </details>

### NumberOfIsLandsII

- 链接：<a href="https://leetcode.cn/problems/number-of-islands-ii/">测试链接</a>

- 内容：

  > 假设你设计一个游戏，用一个 m 行 n 列的 2D 网格来存储你的游戏地图。
  >
  > 起始的时候，每个格子的地形都被默认标记为「水」。
  > 我们可以通过使用 addLand 进行操作，将位置 (row, col) 的「水」变成「陆地」。
  >
  > 你将会被给定一个列表，来记录所有需要被操作的位置，然后你需要返回计算出来 每次 addLand 操作后岛屿的数量。
  >
  > 注意：一个岛的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。
  > 你可以假设地图网格的四边均被无边无际的「水」所包围。
  >
  > 请仔细阅读下方示例与解析，更加深入了解岛屿的判定。
  >
  > ```java
  > 示例:
  > 输入: m = 3, n = 3, 
  > 	positions = [[0,0], [0,1], [1,2], [2,1]]
  > 输出: [1,1,2,3]
  > 解析:
  > 起初，二维网格 grid 被全部注入「水」。（0 代表「水」，1 代表「陆地」）
  > 0 0 0
  > 0 0 0
  > 0 0 0
  > 操作 #1：addLand(0, 0) 将 grid[0][0] 的水变为陆地。
  > 1 0 0
  > 0 0 0   Number of islands = 1
  > 0 0 0
  > 操作 #2：addLand(0, 1) 将 grid[0][1] 的水变为陆地。
  > 1 1 0
  > 0 0 0   岛屿的数量为 1
  > 0 0 0
  > 操作 #3：addLand(1, 2) 将 grid[1][2] 的水变为陆地。
  > 1 1 0
  > 0 0 1   岛屿的数量为 2
  > 0 0 0
  > 操作 #4：addLand(2, 1) 将 grid[2][1] 的水变为陆地。
  > 1 1 0
  > 0 0 1   岛屿的数量为 3
  > 0 1 0
  > ```
  >
  > 拓展：
  > 你是否能在 O(k log mn) 的时间复杂度程度内完成每次的计算？
  > （k 表示 positions 的长度）

- 思路：

  > 思路一：并查集
  >
  > 思路二：并查集优化

- 代码：

  <details>
    <summary>并查集</summary>
    <p> - 每次操作后集合的数量</p>
    <pre><code> public static List<Integer> numIslands21(int m,int n,int[][] positions){
          UnionFind1 uf = new UnionFind1(m, n);
          List<Integer> ans = new ArrayList<>();
          for (int i = 0; i < positions.length; i++) {
              ans.add(uf.connect(positions[i][0],positions[i][1]));
          }
          return ans;
      }
      public static class UnionFind1{
          private static int[] parent;
          private static int[] size;
          private static int[] help;
          private final int row;
          private final int col;
          private int sets;
          public UnionFind1(int m,int n){
              row = m;
              col = n;
              sets = 0;
              int len = m * n;
              parent = new int[len];
              size = new int[len];
              help = new int[len];
          }
          private int index(int r,int c){
              return r * col + c;
          }
          private int find(int i){
              int hi = 0;
              while (i != parent[i]) {
                  help[hi++] = i;
                  i = parent[i];
              }
              while (hi > 0) parent[help[--hi]] = i;
              return i;
          }
          private void union(int r1,int c1,int r2,int c2){
              if (r1 < 0 || r1 == row || r2 < 0 || r2 == row || c1 < 0 || c1 == col || c2 < 0 || c2 == col) {
                  return;
              }
              int i1 = index(r1, c1);
              int i2 = index(r2, c2);
              if (size[i1] == 0 || size[i2] == 0) {
                  return;
              }
              int f1 = find(i1);
              int f2 = find(i2);
              if (f1 != f2) {
                  if (size[f1] >= size[f2]) {
                      size[f1] += size[f2];
                      parent[f2] = f1;
                  } else {
                      size[f2] += size[f1];
                      parent[f1] = f2;
                  }
                  sets--;
              }
          }
          public int connect(int r, int c) {
              int index = index(r, c);
              if (size[index] == 0) {
                  parent[index] = index;
                  size[index] = 1;
                  sets++;
                  union(r - 1, c, r, c);
                  union(r + 1, c, r, c);
                  union(r, c - 1, r, c);
                  union(r, c + 1, r, c);
              }
              return sets;
          }
      }</code>  </pre>
    </details>

  <details>
    <summary>并查集优化</summary>
    <p> - 每次操作后集合的数量</p>
    <pre><code> public static List<Integer> numIslands22(int m, int n, int[][] positions) {
          UnionFind2 uf = new UnionFind2();
          List<Integer> ans = new ArrayList<>();
          for (int[] position : positions) {
              ans.add(uf.connect(position[0], position[1]));
          }
          return ans;
      }
      // UnionFind1中如果m*n比较大，会经历很重的初始化，而k比较小，怎么优化的方法
      public static class UnionFind2{
          private HashMap<String, String> parent;
          private HashMap<String, Integer> size;
          private ArrayList<String> help;
          private int sets;
          public UnionFind2() {
              parent = new HashMap<>();
              size = new HashMap<>();
              help = new ArrayList<>();
              sets = 0;
          }
          private String find(String cur) {
              while (!cur.equals(parent.get(cur))) {
                  help.add(cur);
                  cur = parent.get(cur);
              }
              for (String str : help) {
                  parent.put(str, cur);
              }
              help.clear();
              return cur;
          }
          private void union(String s1, String s2) {
              if (parent.containsKey(s1) && parent.containsKey(s2)) {
                  String f1 = find(s1);
                  String f2 = find(s2);
                  if (!f1.equals(f2)) {
                      int size1 = size.get(f1);
                      int size2 = size.get(f2);
                      String big = size1 >= size2 ? f1 : f2;
                      String small = big == f1 ? f2 : f1;
                      parent.put(small, big);
                      size.put(big, size1 + size2);
                      sets--;
                  }
              }
          }
          public int connect(int r, int c) {
              String key = String.valueOf(r) + "_" + String.valueOf(c);
              if (!parent.containsKey(key)) {
                  parent.put(key, key);
                  size.put(key, 1);
                  sets++;
                  String up = String.valueOf(r - 1) + "_" + String.valueOf(c);
                  String down = String.valueOf(r + 1) + "_" + String.valueOf(c);
                  String left = String.valueOf(r) + "_" + String.valueOf(c - 1);
                  String right = String.valueOf(r) + "_" + String.valueOf(c + 1);
                  union(up, key);
                  union(down, key);
                  union(left, key);
                  union(right, key);
              }
              return sets;
          }
      }</code>  </pre>
    </details>