# 资源限制类型解题套路

## 基本内容

### 资源限制类型技巧汇总

- 1)布隆过滤器用于集合的建立与查询，并可以节省大量空间
- 2)一致性哈希解决数据服务器的负载管理问题
- 3)利用并查集结构做岛问题的并行计算
- 4)哈希函数可以把数据按照种类均匀分流
- 5)位图解决某一范围上数字的出现情况，并可以节省大量空间
- 6)利用分段统计思想、并进一步节省大量空间
- 7)利用堆、外排序来做多个处理单元的结果合并

## 问题集合

### 题目一

- 内容：

  > 32位无符号整数的范围是0~4,294,967,295,现在有一个正好包含40亿个无符号整数的文件，可以使用最多1GB的内存，怎么找到出现次数最多的数?

- 思路：

  **哈希函数可以把数据按照种类均匀分流**

  > 分流：一个hash数据占用8字节的数据内存，key与value均为4字节。
  >
  > 那么1GB的内存最多只能有1GB/8B=1G=125,000,000（条）
  >
  > 最多只有1亿多条数据，但是hash表内部还有索引等占据的内存空间，这里直接保守估计只能存1千万条数据。
  >
  > 总共只有40亿个无符号整数，那可以使用这1千万条数据内存空间进行分流。
  >
  > 因为**hash函数的离散性与均匀性**，我们假设使用了一个hash函数对这源40亿个无符号整数进行数据处理，%400后的结果表示进入哪个桶中，（桶是只有一个的，但我们可以先找出所有在0中的桶后进行一些处理后记录其中出现次数最多的数，释放资源后，再把所有要进1中的数据同样处理...），**这样每个桶中估计刚好有1千万条数据**。
  >
  > 因为**同一个无符号整数使用同一个哈希函数得出的结果是一样的**，不会因这个整数所在的位置的不同。
  >
  > **从桶0记录出现最大的值及其数量，释放桶0资源，记录桶1与之前最大的值及其数量比较，直到结束。（桶0和桶1...是同一个内存空间，不过是在不同过程的不同称呼而已**）

- 进阶：**当一个哈希函数无法满足时，可以使用两个哈希函数对数据进行依次处理，过程同一个哈希函数。**

### 题目二

- 内容：

  > 32位无符号整数的范围是0~4,294,967,295,现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然存在没出现过的数。可以使用最多1GB的内存，怎么找到所有未出现过的数?

- 思路：

  **位图解决某一范围上数字的出现情况，并可以节省大量空间**

  > 我们可以联想一下布隆过滤器，它是把一个url(数字)映射到bit位上(一位或多位)，如果这些位上同时存在，则表明数据存在。
  >
  > 我们可以使用同样的方法，但不使用哈希函数，因为它有误判率
  >
  > 我们可以申请长度为4,294,967,296/32=134,217,728长度(向上取整)的int数组，这个长度为134,217,728，所占空间为536,870,912B空间，1GB所占1,000,000,000B空间，远远小于1GB空间。
  >
  > 我们**对任意一个无符号整数S的处理策略是，先定位S所在的数组下标i,i=S/32,再找到S对应的哪位k,k=S%32,对任意一个S，把arr[i]这个数据的k位，使用1<<(S%32)变成1(原先为0则变，原先为1则不变)**
  >
  > 把所有的数据全过一遍后，对于**位上为0的数据所代表的无符号整数即是没有的，收集所有。**

- 【进阶】

  > 内存限制为3KB，但是只用找到一个没出现过的数即可

- 【进阶】思路

  **利用分段统计思想、并进一步节省大量空间**

  > 3KB = 3000KB ,一个无符号数据占4字节，3000/4=750个
  >
  > 找到小于750的最大的二的次幂，512
  >
  > **0~2^32-1**一共有2^32个数据，可以分512份，每一份有2^(32-9)=2^23个数据
  >
  > arr = int[512] 
  >
  > arr[0]表示0~2^23-1这个范围内的数据的数量，arr[1]表示2^23~2^24-1这个范围内的数量
  >
  > 当有一个arr[i] 的数量不等于2^23时，说明其内至少有一个无符号位数字不存在。
  >
  > 然后在**i * 2^23~(i+1) * 2^23-1**这个范围内继续分512份，找到数量不等于其范围的区间
  >
  > 继续重复上述过程
  >
  > 直到找到为止。

- 【进阶】

  > 内存限制为几个变量，但是只用找到一个没出现过的数即可

- 【进阶】思路

  > 二分
  >
  > 找到0~2^31-1,2^31~2^32-1这两个区间的数量，然后查找不符合的那个区间
  >
  > 以这个区间再继续二分
  >
  > 直到找到了要找的不存在的值。

### 题目三

- 内容

  > 有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL

- 思路

  > 思路一：布隆过滤器，但有失误率
  >
  > 思路二：哈希分流
  >
  > 把大文件通过哈希分为小文件，若需要再把小文件分为小小文件...
  >
  > 若有重复的肯定会进入同一个小....文件中,即可找到所有重复的url

- 【进阶】

  > 某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门Top100词汇的可行办法

- 【进阶】思路

  > 哈希分流+100容量的小根堆

### 题目四

- 内容

  > 32位无符号整数的范围是0~4294967295,现在有40亿个无符号整数,可以使用最多1GB的内存，找出所有出现了两次的数。

- 思路

  > 使用位图
  >
  > 每两位表示一个数据出现的次数，00表示未出现 ，01表示出现1次，10表示出现2次，11表示出现3次及以上
  >
  > 需要的空间2^32个数，每个数占2位，共占据2^34bit，一共要占据2^31B空间
  >
  > 1GB = 1,000,000,000B，2^31B = 1,073,741,824 空间不够
  >
  > 先分段，再计算
  >
  > 第一段计算所有0~2^31-1的数据的出现两次重复的数
  >
  > 第二段计算所有2^31~2^32-1的数据的出现两次重复的数

### 题目五

- 内容

  > 32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数可以使用最多10MB的内存，怎么找到这40亿个整数的中位数?

- 思路

  > 10MB, 10MB/4B = 10^7/4 = 2.5 * 10^7 = 25,000,000
  >
  > 保守估计能申请134217728(2^27)长度的int数组
  >
  > 计算每个arr[i]的值，则能定位到哪个arr[i]包含中位数
  >
  > 继续在arr[i]所代表的范围中进行求第几个数
  >
  > 再进行分段
  >
  > 直到结束。

- 【进阶】

  > 只有3KB

- 【进阶】思路

  > 同上，不过要多进行几次分段处理

### 题目六

- 内容

  > 32位无符号整数的范围是0~4294967295,有一个10G大小的文件，每一行都装着这种类型的数字，整个文件是无序的，给你5G的内存空间，请你输出一个10G大小的文件，就是原文件所有数字排序的结果

- 思路

  > 利用堆，使用5G的内存空间的堆，记录这个内存下的小的值及其次数，然后写入文件中。
  >
  > 再利用堆，把除了上一次的最大值以下的值添加入堆，然后写入文件中。
  >
  > 直到所有的数据都完成了排序并写入了文件中。