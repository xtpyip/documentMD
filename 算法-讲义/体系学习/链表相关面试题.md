# 链表相关面试题

## 链表

- 概念

  > 链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。

- 链表的分类

  > 实际中链表的结构非常多样，如
  >
  > 单向与双向
  >
  > 带头或不带头
  >
  > 循环与非循环

## 问题集合

### LinkedListMid

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class09/Code01_LinkedListMid.java">测试链接</a>

- 内容：

  > 1)输入链表头节点，奇数长度返回中点，偶数长度返回上中点 midOrUpMidNode
  > 2)输入链表头节点，奇数长度返回中点，偶数长度返回下中点 midOrDownMidNode
  > 3)输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个 midOrUpMidPreNode
  > 4)输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个 midOrDownMidPreNode

- 思路：

  > 快慢指针
  >

- 代码：

  <details>
  <summary>返回有关中点的代码</summary>
  <p> - 上中点，下中点，中点前一个</p>
  <pre><code> //    1)输入链表头节点，奇数长度返回中点，偶数长度返回上中点 midOrUpMidNode
      public static SingleNode midOrUpMidNode(SingleNode head){
          if(head == null || head.next == null || head.next.next == null){
              return head;
          }
          SingleNode fast = head;
          SingleNode slow = head;
          while (fast.next != null && fast.next.next != null){
              fast = fast.next.next;
              slow = slow.next;
          }
          return slow;
      }
  //    2)输入链表头节点，奇数长度返回中点，偶数长度返回下中点 midOrDownMidNode
      public static SingleNode midOrDownMidNode(SingleNode head){
          if(head == null || head.next == null) return head;
          // 两个及以上节点
          SingleNode fast = head.next;
          SingleNode slow = head.next;
          while (fast.next != null && fast.next.next != null){
              fast = fast.next.next;
              slow = slow.next;
          }
          return slow;
      }
  //  3)输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个 midOrUpMidPreNode
      // 1 2 3 -> 1
      // 1 2 3 4 -> 1
      public static SingleNode midOrUpMidPreNode(SingleNode head){
          if(head == null || head.next == null) return null;
          SingleNode fast = head.next;
          SingleNode slow = head;
          while (fast.next != null && fast.next.next != null && fast.next.next.next != null){
              fast = fast.next.next;
              slow = slow.next;
          }
          return slow;
      }
  //    4)输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个 midOrDownMidPreNode
      // 1 -> null
      // 1 2 -> 1
      // 1 2 3 -> 1
      // 1 2 3 4 -> 2
      // 1 2 3 4 5 -> 2
      public static SingleNode midOrDownMidPreNode(SingleNode head){
          if(head == null || head.next == null) return null;
          SingleNode fast = head.next;
          SingleNode slow = head;
          while (fast.next != null && fast.next.next != null){
              fast = fast.next.next;
              slow = slow.next;
          }
          return slow;
      }</code>  </pre>
  </details>

### IsPalindromeList

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class09/Code02_IsPalindromeList.java">测试链接</a>

- 内容：

  > 判断一个单链表的值是否为回文字符串

- 思路：

  > 思路一：使用栈存储完数据，并进行逐一判断 **笔试用**
  >
  > 思路二：先得到上中点的位置，存储之后的数据，并进行逐一判断 **笔试用**
  >
  > 思路三：先得到上中点的前一个位置，将之后的链表反转，判断是否为回文字符串，再将其反转回来 **面试用**

- 代码：

  <details>
  <summary>判断是否为回文链表的代码</summary>
  <p> - 三种方法的实现</p>
  <pre><code> // need n extra space
      public static boolean isPalindrome1(SingleNode head) {
          Stack<SingleNode> stack = new Stack<SingleNode>();
          SingleNode cur = head;
          while (cur != null) {
              stack.push(cur);
              cur = cur.next;
          }
          while (head != null) {
              if (head.val != stack.pop().val) {
                  return false;
              }
              head = head.next;
          }
          return true;
      }
      // need n/2 extra space
      public static boolean isPalindrome2(SingleNode head) {
          if (head == null || head.next == null) {
              return true;
          }
          SingleNode right = head.next;
          SingleNode cur = head;
          while (cur.next != null && cur.next.next != null) {
              right = right.next;
              cur = cur.next.next;
          }
          Stack<SingleNode> stack = new Stack<SingleNode>();
          while (right != null) {
              stack.push(right);
              right = right.next;
          }
          while (!stack.isEmpty()) {
              if (head.val != stack.pop().val) {
                  return false;
              }
              head = head.next;
          }
          return true;
      }
      // need O(1) extra space
      public static boolean isPalindrome3(SingleNode head) {
          if (head == null || head.next == null) {
              return true;
          }
          SingleNode n1 = head;
          SingleNode n2 = head;
          while (n2.next != null && n2.next.next != null) { // find mid node
              n1 = n1.next; // n1 -> mid
              n2 = n2.next.next; // n2 -> end
          }
          // n1 中点
          n2 = n1.next; // n2 -> right part first node
          n1.next = null; // mid.next -> null
          SingleNode n3 = null;
          while (n2 != null) { // right part convert
              n3 = n2.next; // n3 -> save next node
              n2.next = n1; // next of right node convert
              n1 = n2; // n1 move
              n2 = n3; // n2 move
          }
          n3 = n1; // n3 -> save last node
          n2 = head;// n2 -> left first node
          boolean res = true;
          while (n1 != null && n2 != null) { // check palindrome
              if (n1.val != n2.val) {
                  res = false;
                  break;
              }
              n1 = n1.next; // left to mid
              n2 = n2.next; // right to mid
          }
          n1 = n3.next;
          n3.next = null;
          while (n1 != null) { // recover list
              n2 = n1.next;
              n1.next = n3;
              n3 = n1;
              n1 = n2;
          }
          return res;
      }</code>  </pre>
  </details>

### SmallerEqualBigger

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class09/Code03_SmallerEqualBigger.java">测试链接</a>

- 内容：

  > 将链接根据指定值划分为小于区等于区和大于区三个部分

- 思路：

  > 思路一：使用数组存储完数据，并进行划分 **笔试用**
  >
  > 思路二：使用三个指针头对数据进行划分，最后三个指针连起来 **面试用**

- 代码：

  <details>
  <summary>判断是否为回文链表的代码</summary>
  <p> - 两种方法的实现</p>
  <pre><code> public static SingleNode listPartition1(SingleNode head, int pivot) {
  		if (head == null) {
  			return head;
  		}
  		SingleNode cur = head;
  		int i = 0;
  		while (cur != null) {
  			i++;
  			cur = cur.next;
  		}
  		SingleNode[] nodeArr = new SingleNode[i];
  		i = 0;
  		cur = head;
  		for (i = 0; i != nodeArr.length; i++) {
  			nodeArr[i] = cur;
  			cur = cur.next;
  		}
  		arrPartition(nodeArr, pivot);
  		for (i = 1; i != nodeArr.length; i++) {
  			nodeArr[i - 1].next = nodeArr[i];
  		}
  		nodeArr[i - 1].next = null;
  		return nodeArr[0];
  	}
  	public static void arrPartition(SingleNode[] nodeArr, int pivot) {
  		int small = -1;
  		int big = nodeArr.length;
  		int index = 0;
  		while (index != big) {
  			if (nodeArr[index].val < pivot) {
  				swap(nodeArr, ++small, index++);
  			} else if (nodeArr[index].val == pivot) {
  				index++;
  			} else {
  				swap(nodeArr, --big, index);
  			}
  		}
  	}
  	public static void swap(SingleNode[] nodeArr, int a, int b) {
  		SingleNode tmp = nodeArr[a];
  		nodeArr[a] = nodeArr[b];
  		nodeArr[b] = tmp;
  	}
  	public static SingleNode listPartition2(SingleNode head, int pivot) {
  		SingleNode sH = null; // small head
  		SingleNode sT = null; // small tail
  		SingleNode eH = null; // equal head
  		SingleNode eT = null; // equal tail
  		SingleNode mH = null; // big head
  		SingleNode mT = null; // big tail
  		SingleNode next = null; // save next node
  		// every node distributed to three lists
  		while (head != null) {
  			next = head.next;
  			head.next = null;
  			if (head.val < pivot) {
  				if (sH == null) {
  					sH = head;
  					sT = head;
  				} else {
  					sT.next = head;
  					sT = head;
  				}
  			} else if (head.val == pivot) {
  				if (eH == null) {
  					eH = head;
  					eT = head;
  				} else {
  					eT.next = head;
  					eT = head;
  				}
  			} else {
  				if (mH == null) {
  					mH = head;
  					mT = head;
  				} else {
  					mT.next = head;
  					mT = head;
  				}
  			}
  			head = next;
  		}
  		// 小于区域的尾巴，连等于区域的头，等于区域的尾巴连大于区域的头
  		if (sT != null) { // 如果有小于区域
  			sT.next = eH;
  			eT = eT == null ? sT : eT; // 下一步，谁去连大于区域的头，谁就变成eT
  		}
  		// 下一步，一定是需要用eT 去接 大于区域的头
  		// 有等于区域，eT -> 等于区域的尾结点
  		// 无等于区域，eT -> 小于区域的尾结点
  		// eT 尽量不为空的尾巴节点
  		if (eT != null) { // 如果小于区域和等于区域，不是都没有
  			eT.next = mH;
  		}
  		return sH != null ? sH : (eH != null ? eH : mH);
  	}</code>  </pre>
  </details>

### CopyListWithRandom

- 链接：<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/">测试链接</a>

- 内容：

  > 给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。
  >
  > 构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。
  >
  > 例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。
  >
  > 返回复制链表的头节点。
  >
  > 用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：
  >
  > - `val`：一个表示 `Node.val` 的整数。
  > - `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。
  >
  > 你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。
  >
  > **示例 1：**
  >
  > ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)
  >
  > ```
  > 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
  > 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
  > ```
  >
  > **示例 2：**
  >
  > ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)
  >
  > ```
  > 输入：head = [[1,1],[2,1]]
  > 输出：[[1,1],[2,1]]
  > ```
  >
  > **示例 3：**
  >
  > **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)**
  >
  > ```
  > 输入：head = [[3,null],[3,0],[3,null]]
  > 输出：[[3,null],[3,0],[3,null]]
  > ```

- 思路：

  > 思路一：使用map记录每个节点的random节点
  >
  > 思路二：在每一个原节点后添加一个原节点的拷贝节点。拷贝节点的random连接原节点random的下一个（除了null）最后将原节点与拷贝节点分离

- 代码：

  <details>
  <summary>随机指针的拷贝代码</summary>
  <p> - 两种方法的实现</p>
  <pre><code> public static Node copyRandomList1(Node head) {
  		// key 老节点
  		// value 新节点
  		HashMap<Node, Node> map = new HashMap<Node, Node>();
  		Node cur = head;
  		while (cur != null) {
  			map.put(cur, new Node(cur.val));
  			cur = cur.next;
  		}
  		cur = head;
  		while (cur != null) {
  			// cur 老
  			// map.get(cur) 新
  			// 新.next ->  cur.next克隆节点找到
  			map.get(cur).next = map.get(cur.next);
  			map.get(cur).random = map.get(cur.random);
  			cur = cur.next;
  		}
  		return map.get(head);
  	}
  public static Node copyRandomList2(Node head) {
  		if (head == null) {
  			return null;
  		}
  		Node cur = head;
  		Node next = null;
  		// 1 -> 2 -> 3 -> null
  		// 1 -> 1' -> 2 -> 2' -> 3 -> 3'
  		while (cur != null) {
  			next = cur.next;
  			cur.next = new Node(cur.val);
  			cur.next.next = next;
  			cur = next;
  		}
  		cur = head;
  		Node copy = null;
  		// 1 1' 2 2' 3 3'
  		// 依次设置 1' 2' 3' random指针
  		while (cur != null) {
  			next = cur.next.next;
  			copy = cur.next;
  			copy.random = cur.random != null ? cur.random.next : null;
  			cur = next;
  		}
  		Node res = head.next;
  		cur = head;
  		// 老 新 混在一起，next方向上，random正确
  		// next方向上，把新老链表分离
  		while (cur != null) {
  			next = cur.next.next;
  			copy = cur.next;
  			cur.next = next;
  			copy.next = next != null ? next.next : null;
  			cur = next;
  		}
  		return res;
  	}</code>  </pre>
  </details>