# 加强堆

## 基础内容

- 为什么要有加强堆？

  > Java中的PriorityQueue（优先级队列）就是系统提供的堆实现，那么为什么还要手动去实现？
  >
  > 假如现在你手里有一个堆，里面存着一些元素，用户此时说要改变元素的排序指标且要求高效，怎么办？
  >
  > 用系统实现的堆，你是不是只能把堆中的元素拿出来再重新去调整。
  >
  > 此时你的用户又想删除堆中的某一个元素，你要怎么删除指定元素又能保证堆结构呢？
  >
  > 系统提供的堆是不是无能为力，或者说系统提供的堆不能高效的满足你的需求，你只能去手动改写。
  >
  > 这里我们想一想：系统的堆为什么不能满足我们的需求，根本原因在于：**元素进堆之后，我们不能确定元素在堆的位置，如果我们能知道堆中元素的位置，不管调整还是删除元素，是不是只需要在它的当前位置进行heapInsert或者heapify操作就可以了。**
  >
  > 这就是加强堆的作用，给堆中的元素增加一张反向索引表，记录入堆元素的位置，用来满足我们的需求。

## 问题集合

### HeapGreater

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class07/Code03_ShowHeapGreater.java">测试链接</a>

- 内容：

  > 加强堆实现
  >
  > 1、在原始堆的基础上添加按元素值删除，并保证堆还是保持排序状态
  >
  > 2、在原始堆的基础上添加查询元素值是否存在
  >
  > 3、返回堆上的所有元素

- 思路：

  > 加强堆，添加一个反向索引表，记录当前元素值对应的下标位置
  >
  > 当删除时，
  >
  > ​	元素值若在最后一个位置，则直接删除，不用调整
  >
  > ​	元素值若不在最后一个位置，则当前元素值与最后一个位置的元素值互换，更新索引表，再进行向上和向下的调整。
  >
  > 是否存在，可以直接使用反向索引表查看key是否存在。
  >
  > 返回堆上的所有元素，直接把heap这个list的元素值拿到返回

- 代码：

  <details>
  <summary>加强堆代码</summary>
  <p> - 自定义加强堆</p>
  <pre><code>public class HeapGreater<T> {
      private List<T> heap; // 元素值
      private Map<T,Integer> indexMap; // 反向索引表
      private int heapSize; // 当前堆的大小（有效值）
      private Comparator<? super T> comparator; // 该泛型的比较器
      public HeapGreater(Comparator<? super T> comparator){
          heap = new ArrayList<>();
          indexMap = new HashMap<>();
          heapSize = 0;
          this.comparator = comparator;
      }
      public boolean isEmpty() {
          return heapSize == 0;
      }
      public int size() {
          return heapSize;
      }
      public boolean contains(T obj) {
          return indexMap.containsKey(obj);
      }
      public T peek() {
          return heap.get(0);
      }
      public void push(T obj){
          heap.add(obj);
          indexMap.put(obj,heapSize);
          heapInsert(heapSize++);
      }
      public void heapInsert(int index){
          while (comparator.compare(heap.get(index), heap.get((index - 1) / 2)) < 0){
              swap(index,(index - 1)/2);
              index = (index - 1)/2;
          }
      }
      public void swap(int i,int j){
          T t1 = heap.get(i);
          T t2 = heap.get(j);
          indexMap.put(t1,j);
          indexMap.put(t2,i);
          heap.set(j,t1);
          heap.set(i,t2);
      }
      public T pop(){
          T popValue = heap.get(0);
          swap(0,heapSize-1);
          indexMap.remove(popValue);
          heap.remove(--heapSize);
          heapify(0);
          return popValue;
      }
      private void heapify(int index) {
          int left = index * 2 + 1;
          while (left < heapSize) {
              int best = left + 1 < heapSize && comparator.compare(heap.get(left + 1), heap.get(left)) < 0 ? (left + 1) : left;
              best = comparator.compare(heap.get(best), heap.get(index)) < 0 ? best : index;
              if (best == index) {
                  break;
              }
              swap(best, index);
              index = best;
              left = index * 2 + 1;
          }
      }
      // 请返回堆上的所有元素
      public List<T> getAllElements() {
          List<T> ans = new ArrayList<>();
          for (T c : heap) {
              ans.add(c);
          }
          return ans;
      }
      // 删除指定元素值
      public void remove(T obj){
          T replace = heap.get(heapSize - 1);
          Integer index = indexMap.get(obj);
          indexMap.remove(obj);
          heap.remove(--heapSize);
          if(obj != replace){
              heap.set(index,replace);
              indexMap.put(replace,index);
              resign(replace);
          }
      }
      public void resign(T obj) {
          Integer index = indexMap.get(obj);
          heapInsert(index);
          heapify(index);
      }
  }	</code>  </pre>
  </details>

### CoverMax

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class07/Code01_CoverMax.java">测试链接</a>

- 内容：

  > 最大线段重合问题（用堆的实现)
  >
  > 给定很多线段，每个线段都有两个数[start, end],表示线段开始位置和结束位置，左右都是闭区间
  >
  > 规定︰
  > 	1）线段的开始和结束位置一定都是整数值
  >
  > ​	2）线段重合区域的长度必须>=1
  >
  > 返回线段最多重合区域中，包含了几条线段。

- 思路：

  > 思路一：使用x + 0.5这个位置，任一线段的区间内包含x+0.5则一定有一条线段，把所有的x+0.5的最大值返回
  >
  > 思路二：排序（辅助类）+小根堆 当来到的新的线段，当堆顶<=起始位置时，说明要把堆中符合的数据弹出，再把当前线段的结尾加入，当前的最多重合区域包含的线段数即是堆的大小 
  >
  > 思路三：排序（二维数组）+小根堆 同思路二。

  <details>
  <summary>x+0.5代码</summary>
  <p> - 最大线段重合</p>
  <pre><code>public static int maxCover1(int[][] lines) {
          int min = Integer.MAX_VALUE;
          int max = Integer.MIN_VALUE;
          for (int i = 0; i < lines.length; i++) {
              min = Math.min(min, lines[i][0]);
              max = Math.max(max, lines[i][1]);
          }
          int cover = 0;
          for (double p = min + 0.5; p < max; p += 1) {
              int cur = 0;
              for (int i = 0; i < lines.length; i++) {
                  if (lines[i][0] < p && lines[i][1] > p) {
                      cur++;
                  }
              }
              cover = Math.max(cover, cur);
          }
          return cover;
      }</code>  </pre>
  </details>
  <details>
  <summary>排序（辅助类）+小根堆代码</summary>
  <p> - 最大线段重合</p>
  <pre><code>public static int maxCover2(int[][] m) {
          Line[] lines = new Line[m.length];
          for (int i = 0; i < m.length; i++) {
              lines[i] = new Line(m[i][0], m[i][1]);
          }
          Arrays.sort(lines, new StartComparator());
          // 小根堆，每一条线段的结尾数值，使用默认的
          PriorityQueue<Integer> heap = new PriorityQueue<>();
          int max = 0;
          for (int i = 0; i < lines.length; i++) {
              // lines[i] -> cur 在黑盒中，把<=cur.start 东西都弹出
              while (!heap.isEmpty() && heap.peek() <= lines[i].start) {
                  heap.poll();
              }
              heap.add(lines[i].end);
              max = Math.max(max, heap.size());
          }
          return max;
      }
      public static class Line {
          public int start;
          public int end;
          public Line(int s, int e) {
              start = s;
              end = e;
          }
      }
      public static class StartComparator implements Comparator<Line> {
          @Override
          public int compare(Line o1, Line o2) {
              return o1.start - o2.start;
          }
      }</code>  </pre>
  </details>
  <details>
  <summary>排序（二维数组）+小根堆代码</summary>
  <p> - 最大线段重合</p>
  <pre><code>    public static int maxCover3(int[][] m) {
          // m是二维数组，可以认为m内部是一个一个的一维数组
          // 每一个一维数组就是一个对象，也就是线段
          // 如下的code，就是根据每一个线段的开始位置排序
          // 比如, m = { {5,7}, {1,4}, {2,6} } 跑完如下的code之后变成：{ {1,4}, {2,6}, {5,7} }
          Arrays.sort(m, (a, b) -> (a[0] - b[0]));
          // 准备好小根堆，和课堂的说法一样
          PriorityQueue<Integer> heap = new PriorityQueue<>();
          int max = 0;
          for (int[] line : m) {
              while (!heap.isEmpty() && heap.peek() <= line[0]) {
                  heap.poll();
              }
              heap.add(line[1]);
              max = Math.max(max, heap.size());
          }
          return max;
      }</code>  </pre>
  </details>

### EveryStepShowBoss

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class07/Code02_EveryStepShowBoss.java">测试链接</a>

- 内容：

  > - 给定一个整型数组, int[] arr;和一个布尔类型数组, boolean[] op。
  >   两个数组一定等长，假设长度为N, arr[i]表示客户编号，op[i]表示客户操作
  >
  > - arr = [ 3,3,1,2,1,2,5…
  >   op =  [T,T, T,T,F,T,F…
  >   依次表示∶3用户购买了一件商品，3用户购买了一件商品，1用户购买了一件商品，2用户购买了一件商品，1用户退货了一件商品，2用户购买了一件商品，5用户退货了一件商品…
  >
  > - 得奖系统的规则︰
  >   - 1，如果某个用户购买商品数为0，但是又发生了退货事件，
  >     则认为该事件无效，得奖名单和上一个事件发生后一致，例子中的5用户
  >
  >   - 2，某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-1
  >
  >   - 3，每次都是最多K个用户得奖，K也为传入的参数
  >
  >   - 4，得奖系统分为得奖区和候选区，任何用户只要购买数>0，一定在这两个区域中的一个
  >
  >   - 5，购买数最大的前K名用户进入得奖区，在最初时如果得奖区没有到达K个用户，那么新来的用户直接进入得奖区
  >
  >   - 6，如果购买数不足以进入得奖区的用户，进入候选区，如果根据全部规则，得奖人数确实不够K个，那就以不够的情况输出结果
  >
  >   - 7，如果候选区购买数最多的用户，已经足以进入得奖区，该用户就会替换得奖区中购买数最少的用户(大于才能替换)，如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户。如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户
  >
  >   - 8，候选区和得奖区是两套时间，因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有从得奖区出来进入候选区的用户，得奖区时间删除，进入候选区的时间就是当前事件的时间(可以理解为arr[i]和op[i]中的i)从候选区出来进入得奖区的用户，候选区时间删除，进入得奖区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i)
  >
  >   - 9，如果某用户购买数==0，不管在哪个区域都离开，区域时间删除。离开是指彻底离开，哪个区域也不会找到该用户。如果下次该用户又发生购买行为，产生>0的购买数，会再次根据之前规则回到某个区域中，进入区域的时间重记

- 思路：

  > 如流程表述，使用两个加强堆，一个是得将区指定长度为k为小根堆，一个是候选区无限长度为大根堆
  >
  > 当大根堆peek>得奖区peek，进行替换操作
  >
  > 触发**当大根堆peek>得奖区peek**条件的有这几个，得奖区退货，候选区买货

- 代码：

  <details>
  <summary>加强堆实现代码</summary>
  <p> - showBoss堆</p>
  <pre><code>public static class Customer {
  		public int id;
  		public int buy;
  		public int enterTime;
  		public Customer(int v, int b, int o) {
  			id = v;
  			buy = b;
  			enterTime = 0;
  		}
  	}
  	public static class CandidateComparator implements Comparator<Customer> {
  		@Override
  		public int compare(Customer o1, Customer o2) {
  			return o1.buy != o2.buy ? (o2.buy - o1.buy) : (o1.enterTime - o2.enterTime);
  		}
  	}
  	public static class DaddyComparator implements Comparator<Customer> {
  		@Override
  		public int compare(Customer o1, Customer o2) {
  			return o1.buy != o2.buy ? (o1.buy - o2.buy) : (o1.enterTime - o2.enterTime);
  		}
  	}
  	public static class WhosYourDaddy {
  		private HashMap<Integer, Customer> customers;
  		private HeapGreater<Customer> candHeap;
  		private HeapGreater<Customer> daddyHeap;
  		private final int daddyLimit;
  		public WhosYourDaddy(int limit) {
  			customers = new HashMap<Integer, Customer>();
  			candHeap = new HeapGreater<>(new CandidateComparator());
  			daddyHeap = new HeapGreater<>(new DaddyComparator());
  			daddyLimit = limit;
  		}
  		// 当前处理i号事件，arr[i] -> id,  buyOrRefund
  		public void operate(int time, int id, boolean buyOrRefund) {
  			if (!buyOrRefund && !customers.containsKey(id)) {
  				return;
  			}
  			if (!customers.containsKey(id)) {
  				customers.put(id, new Customer(id, 0, 0));
  			}
  			Customer c = customers.get(id);
  			if (buyOrRefund) {
  				c.buy++;
  			} else {
  				c.buy--;
  			}
  			if (c.buy == 0) {
  				customers.remove(id);
  			}
  			if (!candHeap.contains(c) && !daddyHeap.contains(c)) {
  				if (daddyHeap.size() < daddyLimit) {
  					c.enterTime = time;
  					daddyHeap.push(c);
  				} else {
  					c.enterTime = time;
  					candHeap.push(c);
  				}
  			} else if (candHeap.contains(c)) {
  				if (c.buy == 0) {
  					candHeap.remove(c);
  				} else {
  					candHeap.resign(c);
  				}
  			} else {
  				if (c.buy == 0) {
  					daddyHeap.remove(c);
  				} else {
  					daddyHeap.resign(c);
  				}
  			}
  			daddyMove(time);
  		}
  		public List<Integer> getDaddies() {
  			List<Customer> customers = daddyHeap.getAllElements();
  			List<Integer> ans = new ArrayList<>();
  			for (Customer c : customers) {
  				ans.add(c.id);
  			}
  			return ans;
  		}
  		private void daddyMove(int time) {
  			if (candHeap.isEmpty()) {
  				return;
  			}
  			if (daddyHeap.size() < daddyLimit) {
  				Customer p = candHeap.pop();
  				p.enterTime = time;
  				daddyHeap.push(p);
  			} else {
  				if (candHeap.peek().buy > daddyHeap.peek().buy) {
  					Customer oldDaddy = daddyHeap.pop();
  					Customer newDaddy = candHeap.pop();
  					oldDaddy.enterTime = time;
  					newDaddy.enterTime = time;
  					daddyHeap.push(newDaddy);
  					candHeap.push(oldDaddy);
  				}
  			}
  		}
  	}
  	public static List<List<Integer>> topK(int[] arr, boolean[] op, int k) {
  		List<List<Integer>> ans = new ArrayList<>();
  		WhosYourDaddy whoDaddies = new WhosYourDaddy(k);
  		for (int i = 0; i < arr.length; i++) {
  			whoDaddies.operate(i, arr[i], op[i]);
  			ans.add(whoDaddies.getDaddies());
  		}
  		return ans;
  	}
  	// 干完所有的事，模拟，不优化
  	public static List<List<Integer>> compare(int[] arr, boolean[] op, int k) {
  		HashMap<Integer, Customer> map = new HashMap<>();
  		ArrayList<Customer> cands = new ArrayList<>();
  		ArrayList<Customer> daddy = new ArrayList<>();
  		List<List<Integer>> ans = new ArrayList<>();
  		for (int i = 0; i < arr.length; i++) {
  			int id = arr[i];
  			boolean buyOrRefund = op[i];
  			if (!buyOrRefund && !map.containsKey(id)) {
  				ans.add(getCurAns(daddy));
  				continue;
  			}
  			// 没有发生：用户购买数为0并且又退货了
  			// 用户之前购买数是0，此时买货事件
  			// 用户之前购买数>0， 此时买货
  			// 用户之前购买数>0, 此时退货
  			if (!map.containsKey(id)) {
  				map.put(id, new Customer(id, 0, 0));
  			}
  			// 买、卖
  			Customer c = map.get(id);
  			if (buyOrRefund) {
  				c.buy++;
  			} else {
  				c.buy--;
  			}
  			if (c.buy == 0) {
  				map.remove(id);
  			}
  			// c
  			// 下面做
  			if (!cands.contains(c) && !daddy.contains(c)) {
  				if (daddy.size() < k) {
  					c.enterTime = i;
  					daddy.add(c);
  				} else {
  					c.enterTime = i;
  					cands.add(c);
  				}
  			}
  			cleanZeroBuy(cands);
  			cleanZeroBuy(daddy);
  			cands.sort(new CandidateComparator());
  			daddy.sort(new DaddyComparator());
  			move(cands, daddy, k, i);
  			ans.add(getCurAns(daddy));
  		}
  		return ans;
  	}
  	public static void move(ArrayList<Customer> cands, ArrayList<Customer> daddy, int k, int time) {
  		if (cands.isEmpty()) {
  			return;
  		}
  		// 候选区不为空
  		if (daddy.size() < k) {
  			Customer c = cands.get(0);
  			c.enterTime = time;
  			daddy.add(c);
  			cands.remove(0);
  		} else { // 等奖区满了，候选区有东西
  			if (cands.get(0).buy > daddy.get(0).buy) {
  				Customer oldDaddy = daddy.get(0);
  				daddy.remove(0);
  				Customer newDaddy = cands.get(0);
  				cands.remove(0);
  				newDaddy.enterTime = time;
  				oldDaddy.enterTime = time;
  				daddy.add(newDaddy);
  				cands.add(oldDaddy);
  			}
  		}
  	}
  	public static void cleanZeroBuy(ArrayList<Customer> arr) {
  		List<Customer> noZero = new ArrayList<Customer>();
  		for (Customer c : arr) {
  			if (c.buy != 0) {
  				noZero.add(c);
  			}
  		}
  		arr.clear();
  		for (Customer c : noZero) {
  			arr.add(c);
  		}
  	}
  	public static List<Integer> getCurAns(ArrayList<Customer> daddy) {
  		List<Integer> ans = new ArrayList<>();
  		for (Customer c : daddy) {
  			ans.add(c.id);
  		}
  		return ans;
  	}
  </code>  </pre>
  </details>
