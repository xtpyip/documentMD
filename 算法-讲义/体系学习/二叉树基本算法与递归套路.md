# 二叉树基本算法与递归套路

## 基本内容

- 递归套路

  > 1）假设以X节点为头，假设可以向X左树和X右树要任何信息
  >
  > 2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）
  >
  > 3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息
  >
  > 4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S
  >
  > 5）递归函数都返回S，每一棵子树都这么要求
  >
  > 6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息

## 问题集合

### IsCBT

- 链接：<a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/description/">测试链接</a>

- 内容：

  > 判断一个树是否为完全二叉树

- 思路：

  > 思路一：队列标记
  >
  > ​	添加第一层的节点后，依次出队，将出队不为空的节点的左右孩子加入队列中
  >
  > ​	当遇见null时标记已经存在null值
  >
  > ​	若遇见不为空的节点且已经存在null值则说明不是CBT，返回false
  >
  > ​	当队列出队完毕还没有返回false，则返回true
  >
  > 思路二：二叉树的递归套路
  >
  > ​	使用辅助类记录以此节点为头的子树的信息，如高度，是否为满二叉树及完全二叉树
  >
  > ​	有以下几种情况
  >
  > ​	当前节点cur依赖其左右信息
  >
  > ​	当前节点类（辅助类）的高度为左右子树高度最大的那个+1
  >
  > ​	当前节点类是否满二叉树为左右皆满且左右高度相等
  >
  > ​	当前节点类是否完全二叉树为以下几种情况
  >
  > ​		是满二叉树，则是完全二叉树
  >
  > ​		左完全，右满，且左高=右高+1
  >
  > ​		左满，右满，且左高=右高+1
  >
  > ​		左满，右完全，且左高=右高
  >
  > ​	返回当前节点cur类的信息
  >
  > ​	最后返回节点head类是否为完全二叉树

- 代码：

  <details>
    <summary>队列标记</summary>
    <p> - 是否为完全二叉树</p>
    <pre><code> public static boolean isCBT1(Node head){
          // 使用队列添加每一层
          if(head == null) return true;
          Queue<Node> queue = new LinkedList<>();
          return addQueueAndCheck(head,queue);
      }
      public static boolean addQueueAndCheck(Node head,Queue<Node> queue){
          queue.add(head);
          boolean isExistNull = false;
          while (!queue.isEmpty()) {
              Node cur = queue.poll();
              if(isExistNull && cur != null){
                  return false;
              }
              if(cur == null){
                  isExistNull = true;
                  continue;
              }
              queue.add(cur.left);
              queue.add(cur.right);
          }
          return true;
      }</code>  </pre>
    </details>
  <details>
    <summary>递归套路</summary>
    <p> - 是否为完全二叉树</p>
    <pre><code> public static boolean isCBT1(Node head){
          // 使用队列添加每一层
          if(head == null) return true;
          Queue<Node> queue = new LinkedList<>();
          return addQueueAndCheck(head,queue);
      }
      public static boolean addQueueAndCheck(Node head,Queue<Node> queue){
          queue.add(head);
          boolean isExistNull = false;
          while (!queue.isEmpty()) {
              Node cur = queue.poll();
              if(isExistNull && cur != null){
                  return false;
              }
              if(cur == null){
                  isExistNull = true;
                  continue;
              }
              queue.add(cur.left);
              queue.add(cur.right);
          }
          return true;
      }
      static class Info{
          public boolean isFull;
          public boolean isCBT;
          public int height;
          public Info(boolean full, boolean cbt, int h) {
              isFull = full;
              isCBT = cbt;
              height = h;
          }
      }
      public static boolean isCBT2(Node head){
          if(head == null) return true;
          return process(head).isCBT;
      }
      public static Info process(Node head){
          if(head == null) return new Info(true,true,0);
          Info lInfo = process(head.left);
          Info rInfo = process(head.right);
          boolean isFull,isCBT = false;
          isFull = lInfo.isFull && rInfo.isFull && lInfo.height == rInfo.height;
          int height = Math.max(lInfo.height, rInfo.height) + 1;
          if(isFull){
              isCBT = true;
          }else{
              if(lInfo.isCBT && rInfo.isCBT){
                  if(lInfo.isCBT && rInfo.isFull && lInfo.height == rInfo.height + 1){
                      isCBT = true;
                  }
                  if(lInfo.isFull && rInfo.isFull && lInfo.height == rInfo.height+1){
                      isCBT = true;
                  }
                  if(lInfo.isFull && rInfo.isCBT && lInfo.height == rInfo.height){
                      isCBT = true;
                  }
              }
          }
          return new Info(isFull,isCBT,height);
      }</code>  </pre>
    </details>

### IsBST

- 链接：<a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">测试链接</a>

- 内容：

  > 判断一个树是否为搜索二叉树

- 思路：

  > 思路一：先序存储数据，看是否严格递增
  >
  > 思路二：二叉树的递归套路
  >
  > ​	存储以当前节点x为根的子树的最小值及最大值，及是否为BST树
  >
  > ​	x.min = min(left.min,right.min),   x.max=max(left.max,right.max)
  >
  > ​	为BST树要满足以下条件
  >
  > ​		左右都是BST树
  >
  > ​		x.val > left.max && x.val < right.min
  >
  > ​	最后封装信息返回

- 代码：

  <details>
    <summary>数据存储判断严格递增</summary>
    <p> - 是否为搜索二叉树</p>
    <pre><code> public static boolean isValidBST(TreeNode head){
          if(head == null) return true;
          List<Integer> list = new ArrayList<>();
          in(head,list);
          int pre = list.get(0);
          for (int i = 1; i < list.size(); i++) {
              Integer cur = list.get(i);
              if(cur > pre){
                  pre = cur;
              }else{
                  return false;
              }
          }
          return true;
      }
      public static void in(TreeNode cur,List<Integer> list){
          if(cur == null) return;
          in(cur.left,list);
          list.add(cur.val);
          in(cur.right,list);
      }</code>  </pre>
    </details>

  <details>
    <summary>二叉树递归套路</summary>
    <p> - 是否为搜索二叉树</p>
    <pre><code> public static boolean isValidBST(TreeNode head){
          if(head == null) return true;
          return process(head).isBST;
      }
      static class Info{
          public int min;
          public int max;
          public boolean isBST;
          public Info(){}
          public Info(int i,int a,boolean bst){min=i;max=a;isBST=bst;}
      }
      public static Info process(TreeNode cur){
          if(cur == null) return null;
          Info lInfo = process(cur.left);
          Info rInfo = process(cur.right);
          int max,min;
          boolean isBST = false;
          if(lInfo == null && rInfo == null) return new Info(cur.val,cur.val,true);
          if(lInfo != null && rInfo != null){
              isBST = cur.val > lInfo.max && cur.val < rInfo.min && lInfo.isBST && rInfo.isBST;
              max = Math.max(lInfo.max, rInfo.max);
              min = Math.min(lInfo.min, rInfo.min);
          }else{
              if(lInfo != null){ // rInfo = null
                  isBST = cur.val > lInfo.max && lInfo.isBST;
                  min = lInfo.min;
                  max = cur.val;
              }else{ // lInfo = null
                  isBST = cur.val < rInfo.min && rInfo.isBST;
                  min = cur.val;
                  max = rInfo.max;
              }
          }
          return new Info(min,max,isBST);
      }</code>  </pre>
    </details>

### IsBalanced

- 链接：<a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/description/">测试链接</a>

- 内容：

  > 判断一个树是否为平衡二叉树

- 思路：

  > 思路一：暴力递归
  >
  > 思路二：二叉树的递归套路
  >
  > ​	存储以当前节点x为根的子树的**高度，及是否为balancedTree**(下面简称**BT**)
  >
  > ​	高度为左右子树高度最大的那个+1
  >
  > ​	为BT树要满足以下条件
  >
  > ​		左右都是BT树
  >
  > ​		左高与右高之间绝对值差不能大于1
  >
  > ​	最后封装信息返回

- 代码：

  <details>
    <summary>暴力递归</summary>
    <p> - 是否为平衡二叉树</p>
    <pre><code> public static boolean isBalanced(TreeNode head){
          if(head == null) return true;
          boolean[] ans = new boolean[]{true};
          process(head,ans);
          return ans[0];
      }
      public static int process(TreeNode cur,boolean[] ans){
          if(!ans[0] || cur == null) return -1;
          int lProcess = process(cur.left, ans);
          int rProcess = process(cur.right, ans);
          if(Math.abs(lProcess - rProcess) > 1){
              ans[0] = false;
          }
          return Math.max(lProcess,rProcess) + 1;
      }</code>  </pre>
    </details>

  <details>
    <summary>二叉树递归套路</summary>
    <p> - 是否为平衡二叉树</p>
    <pre><code> public static class Info{
          public int height;
          public boolean isBalanced;
          public Info(){}
          public Info(int h,boolean b){height=h;isBalanced=b;}
      }
      public static boolean isBalanced(TreeNode head){
          if(head == null) return true;
          return getInfo(head).isBalanced;
      }
      public static Info getInfo(TreeNode cur){
          if(cur == null) return new Info(0,true);
          Info lInfo = getInfo(cur.left);
          Info rInfo = getInfo(cur.right);
          boolean b = Math.abs(lInfo.height - rInfo.height) <= 1 && lInfo.isBalanced && rInfo.isBalanced;
          int height = Math.max(lInfo.height, rInfo.height) + 1;
          return new Info(height,b);
      }</code>  </pre>
    </details>

### IsFull

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class12/Code04_IsFull.java">测试链接</a>

- 内容：

  > 判断一个树是否为满二叉树

- 思路：

  > 思路一：二叉树的递归套路
  >
  > ​	存储以当前节点x为根的子树的高度，及节点的数量
  >
  > ​	最后判断是否数量是否等于2的子树高度次方-1
  >
  > 思路二：二叉树的递归套路
  >
  > ​	存储以当前节点x为根的子树的**高度，及是否为full tree**(下面简称**FT**)
  >
  > ​	高度为左右子树高度最大的那个+1
  >
  > ​	为FT树要满足以下条件
  >
  > ​		左右都是FT树
  >
  > ​		左高等于右高
  >
  > ​	最后封装信息返回

- 代码：

  <details>
    <summary>二叉树的递归套路节点数量与高度</summary>
    <p> - 是否为满二叉树</p>
    <pre><code> public static boolean isFull1(Node head){
          if(head == null) return true;
          Info1 info = process1(head);
          return (1 << (info.height)) - 1 == info.nodes;
      }
      public static class Info1 {
          public int height;
          public int nodes;
          public Info1(int h, int n) {
              height = h;
              nodes = n;
          }
      }
      public static Info1 process1(Node head){
          if(head == null) return new Info1(0,0);
          Info1 lInfo = process1(head.left);
          Info1 rInfo = process1(head.right);
          return new Info1(Math.max(lInfo.height,rInfo.height)+1, lInfo.nodes+ rInfo.nodes + 1);
      }</code>  </pre>
  </details>

  <details>
    <summary>二叉树递归套路高度与isFull</summary>
    <p> - 是否为满二叉树</p>
    <pre><code> public static boolean isFull2(Node head){
          if(head == null) return true;
          Info2 info = process2(head);
          return info.isFull;
      }
      public static class Info2 {
          public int height;
          public boolean isFull;
          public Info2(int h, boolean n) {
              height = h;
              isFull = n;
          }
      }
      public static Info2 process2(Node head){
          if(head == null) return new Info2(0,true);
          Info2 lInfo = process2(head.left);
          Info2 rInfo = process2(head.right);
          return new Info2(Math.max(lInfo.height,rInfo.height)+1, lInfo.isFull && rInfo.isFull && lInfo.height == rInfo.height);
      }</code>  </pre>
    </details>

### MaxSubBSTSize

- 链接：<a href="https://leetcode.cn/problems/largest-bst-subtree">测试链接</a>

- 内容：

  > 返回最大的二叉搜索子树的大小

- 思路：

  > 二叉树的递归套路
  >
  > ​	存储以当前节点x为根的子树的**最大值，最小值，当前最大二叉搜索子树的大小(maxSubSize)，及当前子树总数量**
  >
  > ​	先根据当前左右信息判断当前节点是否为bst
  >
  > ​	若是，则更新maxBSTSubtreeSize信息
  >
  > ​	若不是，则不更新信息
  >
  > ​	最后封装信息返回

- 代码：

  <details>
    <summary>二叉树的递归套路</summary>
    <p> - 最大搜索二叉子树节点数量</p>
    <pre><code> public static int largestBSTSubtree(TreeNode head) {
          if(head == null) return 0;
          return process(head).maxBSTSubtreeSize;
      }
      public static class Info {
          public int maxBSTSubtreeSize;
          public int allSize;
          public int max;
          public int min;
          public Info(int m, int a, int ma, int mi) {
              maxBSTSubtreeSize = m;
              allSize = a;
              max = ma;
              min = mi;
          }
      }
      public static Info process(TreeNode x){
          if (x == null) {
              return null;
          }
          Info leftInfo = process(x.left);
          Info rightInfo = process(x.right);
          int max = x.val;
          int min = x.val;
          int allSize = 1;
          if (leftInfo != null) {
              max = Math.max(leftInfo.max, max);
              min = Math.min(leftInfo.min, min);
              allSize += leftInfo.allSize;
          }
          if (rightInfo != null) {
              max = Math.max(rightInfo.max, max);
              min = Math.min(rightInfo.min, min);
              allSize += rightInfo.allSize;
          }
          int p1 = -1;
          if (leftInfo != null) {
              p1 = leftInfo.maxBSTSubtreeSize;
          }
          int p2 = -1;
          if (rightInfo != null) {
              p2 = rightInfo.maxBSTSubtreeSize;
          }
          int p3 = -1;
          boolean leftBST = leftInfo == null ? true : (leftInfo.maxBSTSubtreeSize == leftInfo.allSize);
          boolean rightBST = rightInfo == null ? true : (rightInfo.maxBSTSubtreeSize == rightInfo.allSize);
          if (leftBST && rightBST) {
              boolean leftMaxLessX = leftInfo == null ? true : (leftInfo.max < x.val);
              boolean rightMinMoreX = rightInfo == null ? true : (x.val < rightInfo.min);
              if (leftMaxLessX && rightMinMoreX) {
                  int leftSize = leftInfo == null ? 0 : leftInfo.allSize;
                  int rightSize = rightInfo == null ? 0 : rightInfo.allSize;
                  p3 = leftSize + rightSize + 1;
              }
          }
          return new Info(Math.max(p1, Math.max(p2, p3)), allSize, max, min);
      }</code>  </pre>
  </details>

### MaxDistance

- 链接：<a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">类似测试链接（要对其结果-1）</a>

- 内容：

  > 返回二叉树中两节点之间的最大距离

- 思路：

  > 思路一：使用map记录当前节点和其父节点，及前序序列，遍历两次序列，得到距离，返回最大的那个距离
  >
  > 思路二：二叉树的递归套路
  >
  > ​	当前节点x辅助类存储其最大高度，最大距离
  >
  > ​	最大高度为左右子树高度最大那个+1
  >
  > ​	最大距离为左子树最大距离，右子树最大距离，左子树最大高度+右高+1的最大值
  >
  > ​	封装信息返回

- 代码：

  <details>
    <summary>map记录父子</summary>
    <p> - 最远的距离</p>
    <pre><code> public static int maxDistance1(TreeNode head) {
          if (head == null) {
              return 0;
          }
          ArrayList<TreeNode> arr = getPrelist(head);
          HashMap<TreeNode, TreeNode> parentMap = getParentMap(head);
          int max = 0;
          for (int i = 0; i < arr.size(); i++) {
              for (int j = i; j < arr.size(); j++) {
                  max = Math.max(max, distance(parentMap, arr.get(i), arr.get(j)));
              }
          }
          return max;
      }
      public static ArrayList<TreeNode> getPrelist(TreeNode head) {
          ArrayList<TreeNode> arr = new ArrayList<>();
          fillPrelist(head, arr);
          return arr;
      }
      public static void fillPrelist(TreeNode head, ArrayList<TreeNode> arr) {
          if (head == null) {
              return;
          }
          arr.add(head);
          fillPrelist(head.left, arr);
          fillPrelist(head.right, arr);
      }
      public static HashMap<TreeNode, TreeNode> getParentMap(TreeNode head) {
          HashMap<TreeNode, TreeNode> map = new HashMap<>();
          map.put(head, null);
          fillParentMap(head, map);
          return map;
      }
      public static void fillParentMap(TreeNode head, HashMap<TreeNode, TreeNode> parentMap) {
          if (head.left != null) {
              parentMap.put(head.left, head);
              fillParentMap(head.left, parentMap);
          }
          if (head.right != null) {
              parentMap.put(head.right, head);
              fillParentMap(head.right, parentMap);
          }
      }
      public static int distance(HashMap<TreeNode, TreeNode> parentMap, TreeNode o1, TreeNode o2) {
          HashSet<TreeNode> o1Set = new HashSet<>();
          TreeNode cur = o1;
          o1Set.add(cur);
          while (parentMap.get(cur) != null) {
              cur = parentMap.get(cur);
              o1Set.add(cur);
          }
          cur = o2;
          while (!o1Set.contains(cur)) {
              cur = parentMap.get(cur);
          }
          TreeNode lowestAncestor = cur;
          cur = o1;
          int distance1 = 1;
          while (cur != lowestAncestor) {
              cur = parentMap.get(cur);
              distance1++;
          }
          cur = o2;
          int distance2 = 1;
          while (cur != lowestAncestor) {
              cur = parentMap.get(cur);
              distance2++;
          }
          return distance1 + distance2 - 1;
      }</code>  </pre>
  </details>
  <details>
    <summary>二叉树递归套路</summary>
    <p> - 最远的距离</p>
    <pre><code> public static int maxDistance2(TreeNode head) {
          return process(head).maxDistance;
      }
      public static class Info {
          public int maxDistance;
          public int height;
          public Info(int m, int h) {
              maxDistance = m;
              height = h;
          }
      }
      public static Info process(TreeNode x) {
          if (x == null) {
              return new Info(0, 0);
          }
          Info leftInfo = process(x.left);
          Info rightInfo = process(x.right);
          int height = Math.max(leftInfo.height, rightInfo.height) + 1;
          int p1 = leftInfo.maxDistance;
          int p2 = rightInfo.maxDistance;
          int p3 = leftInfo.height + rightInfo.height + 1;
          int maxDistance = Math.max(Math.max(p1, p2), p3);
          return new Info(maxDistance, height);
      }</code>  </pre>
  </details>