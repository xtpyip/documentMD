# 二叉树基本算法下

## 问题集合

### LevelTraversalBT

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class11/Code01_LevelTraversalBT.java">测试链接</a>

- 内容：

  > 实现二叉树的按层遍历
  >
  > 1)其实就是宽度优先遍历，用队列
  >
  > 2)可以通过设置flag变量的方式，来发现某一层的结束（看题目)

- 思路：

  > 队列

- 代码：

  <details>
  <summary>层序遍历代码</summary>
  <p> - 队列实现</p>
  <pre><code>public static void level(Node head) {
  		if (head == null) {
  			return;
  		}
  		Queue<Node> queue = new LinkedList<>();
  		queue.add(head);
  		while (!queue.isEmpty()) {
  			Node cur = queue.poll();
  			System.out.println(cur.value);
  			if (cur.left != null) {
  				queue.add(cur.left);
  			}
  			if (cur.right != null) {
  				queue.add(cur.right);
  			}
  		}
  }</code>  </pre>
  </details>

### SerializeAndReconstructTree

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class11/Code02_SerializeAndReconstructTree.java">测试链接</a>

- 内容：

  > 实现二叉树的序列化和反序列化
  >
  > 1)先序方式序列化和反序列化
  >
  > 2)中序方式序列化和反序列化 （无法确定一个树）
  >
  > 3)后序方式序列化和反序列化
  >
  > 4)按层方式序列化和反序列化。

- 思路：

  > 先序方式序列化和反序列化 **队列记录中前后，根据中前后生成树**
  >
  > 中序方式序列化 **队列记录前中后，根据前中后生成树****
  >
  > 后序方式序列化和反序列化 **队列记录前后中，根据出队入栈中后前生成树**
  >
  > 层序方式序列化和反序列化 **队列记录每一层及其左右，根据左右生成树**

- 代码：

  <details>
  <summary>层序序列化与反序列化代码</summary>
  <p> - 队列实现</p>
  <pre><code>public static Queue<String> levelSerial(Node head) {
          Queue<String> ans = new LinkedList<>();
          if(head == null){
              ans.add(null);
          }else{
              ans.add(String.valueOf(head.value));
              Queue<Node> queue = new LinkedList<>();
              queue.add(head);
              while (!queue.isEmpty()) {
                  head = queue.poll();
                  if(head.left != null){
                      ans.add(String.valueOf(head.left.value));
                      queue.add(head.left);
                  }else{
                      ans.add(null);
                  }
                  if(head.right != null){
                      ans.add(String.valueOf(head.right.value));
                      queue.add(head.right);
                  }else{
                      ans.add(null);
                  }
              }
          }
          return ans;
      }
      public static Node buildByLevelQueue(Queue<String> levelList){
          if(levelList == null || levelList.isEmpty()) return null;
          Node head = generateNode(levelList.poll());
          Queue<Node> queue = new LinkedList<>();
          if(head != null){
              queue.add(head);
          }
          Node node = null;
          while (!queue.isEmpty()){
              node = queue.poll();
              node.left = generateNode(levelList.poll());
              node.right = generateNode(levelList.poll());
              if(node.left != null) queue.add(node.left);
              if(node.right != null) queue.add(node.right);
          }
          return head;
      }
      public static Node generateNode(String val) {
          if (val == null) {
              return null;
          }
          return new Node(Integer.valueOf(val));
      }</code>  </pre>
  </details>
  
  <details>
  <summary>先序序列化与反序列化代码</summary>
  <p> - 队列实现</p>
  <pre><code>    public static Queue<String> preSerial(Node head) {
          Queue<String> queue = new LinkedList<>();
          pres(head,queue);
          return queue;
      }
      public static void pres(Node cur,Queue<String> queue){
          if(cur == null){
              queue.add(null);
          }else{
              queue.add(String.valueOf(cur.value));
              pres(cur.left,queue);
              pres(cur.right,queue);
          }
      }
      public static Node buildByPreQueue(Queue<String> queue){
          if(queue == null || queue.isEmpty()) return null;
          return preb(queue);
      }
      public static Node preb(Queue<String> queue){
          String value = queue.poll();
          if(value == null) return null;
          Node head = new Node(Integer.valueOf(value));
          head.left = preb(queue);
          head.right = preb(queue);
          return head;
      }</code>  </pre>
  </details>
  
  <details>
  <summary>后序序列化与反序列化代码</summary>
  <p> - 队列与栈实现</p>
  <pre><code>    public static Queue<String> posSerial(Node head) {
          Queue<String> ans = new LinkedList<>();
          poss(head, ans);
          return ans;
      }
      public static void poss(Node head, Queue<String> ans) {
          if (head == null) {
              ans.add(null);
          } else {
              poss(head.left, ans);
              poss(head.right, ans);
              ans.add(String.valueOf(head.value));
          }
      }
      public static Node buildByPosQueue(Queue<String> poslist) {
          if (poslist == null || poslist.isEmpty()) {
              return null;
          }
          // 左右中  ->  stack(中右左)
          Stack<String> stack = new Stack<>();
          while (!poslist.isEmpty()) {
              stack.push(poslist.poll());
          }
          return posb(stack);
      }
      public static Node posb(Stack<String> posstack) {
          String value = posstack.pop();
          if (value == null) {
              return null;
          }
          Node head = new Node(Integer.valueOf(value));
          head.right = posb(posstack);
          head.left = posb(posstack);
          return head;
      }</code>  </pre>
  </details>
  
  <details>
  <summary>中序序列化代码</summary>
  <p> - 队列实现</p>
  <pre><code>public static void ins(Node head, Queue<String> ans) {
          if (head == null) {
              ans.add(null);
          } else {
              ins(head.left, ans);
              ans.add(String.valueOf(head.value));
              ins(head.right, ans);
          }
      }</code>  </pre>
  </details>

### EncodeNaryTreeToBinary

- 链接：<a href="https://leetcode.cn/problems/encode-n-ary-tree-to-binary-tree">测试链接</a>

- 内容：

  > Design an algorithm to encode an N-ary tree into a binary tree and decode the binary tree to get the original N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. Similarly, a binary tree is a rooted tree in which each node has no more than 2 children. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that an N-ary tree can be encoded to a binary tree and this binary tree can be decoded to the original N-nary tree structure.
  >
  > For example, you may encode the following `3-ary` tree to a binary tree in this way:
  >
  >  
  >
  > ![img](https://assets.leetcode.com/uploads/2018/10/12/narytreebinarytreeexample.png)
  >
  >  
  >
  > Note that the above is just an example which *might or might not* work. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.
  >
  > ```java
  > N-ary Tree:
  > 
  >       1
  >    /  |  \
  >   3   2   4
  >  / \
  > 5   6
  > 
  > 
  > Binary Tree:
  > 
  >     1
  >    /
  >   3
  >  / \
  > 5   2
  >  \   \
  >   6   4
  > ```

- 思路：

  > 父节点把除了自己的最左的节点都挂在最左的节点上，

- 代码：

  <details>
  <summary>n叉树转二叉树及其反转代码</summary>
  <p> - 递归系统栈实现</p>
  <pre><code>class Codec {
          // Encodes an n-ary tree to a binary tree.
          public TreeNode encode(Node root) {
             if(root == null) return null;
             TreeNode head = new TreeNode(root.val);
             head.left = en(root.children);
             return head;
          }
          private TreeNode en(List<Node> children) {
              TreeNode head = null,cur = null;
              for (Node child : children) {
                  TreeNode tNode = new TreeNode(child.val);
                  if(head == null){
                      head = tNode;
                  }else{
                      cur.right = tNode;
                  }
                  cur = tNode;
                  cur.left = en(child.children);
              }
              return head;
          }
          // Decodes your binary tree to an n-ary tree.
          public Node decode(TreeNode root) {
              if(root == null) return null;
              return new Node(root.val,de(root));
          }
          public List<Node> de(TreeNode root) {
              List<Node> children = new ArrayList<>();
              while (root != null) {
                  Node cur = new Node(root.val,de(root.left));
                  children.add(cur);
                  root = root.right;
              }
              return children;
          }
      }</code>  </pre>
  </details>

### TreeMaxWidth

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class11/Code05_TreeMaxWidth.java">测试链接</a>

- 内容：

  > 求二叉树最宽的层有多少个节点。

- 思路：

  > 思路一：使用map标记节点及其所在level，计算level所在的节点数量
  >
  > 思路二：使用变量记录每一层节点的数量

- 代码：

  <details>
  <summary>map方法实现代码</summary>
  <p> - 最宽长度</p>
  <pre><code>public static int maxWidthUseMap(Node head) {
          if (head == null) {
              return 0;
          }
          Queue<Node> queue = new LinkedList<>();
          queue.add(head);
          // key 在 哪一层，value
          HashMap<Node, Integer> levelMap = new HashMap<>();
          levelMap.put(head, 1);
          int curLevel = 1; // 当前你正在统计哪一层的宽度
          int curLevelNodes = 0; // 当前层curLevel层，宽度目前是多少
          int max = 0;
          while (!queue.isEmpty()) {
              Node cur = queue.poll();
              int curNodeLevel = levelMap.get(cur);
              if (cur.left != null) {
                  levelMap.put(cur.left, curNodeLevel + 1);
                  queue.add(cur.left);
              }
              if (cur.right != null) {
                  levelMap.put(cur.right, curNodeLevel + 1);
                  queue.add(cur.right);
              }
              if (curNodeLevel == curLevel) {
                  curLevelNodes++;
              } else {
                  max = Math.max(max, curLevelNodes);
                  curLevel++;
                  curLevelNodes = 1;
              }
          }
          max = Math.max(max, curLevelNodes);
          return max;
      }</code>  </pre>
  </details>

  <details>
  <summary>变量记录实现代码</summary>
  <p> - 最宽长度</p>
  <pre><code>public static int maxWidthNoMap(Node head) {
          if(head == null) return 0;
          Queue<Node> queue = new LinkedList<>();
          queue.add(head);
          int maxSize = 1;
          int cur = 1,next;
          while (!queue.isEmpty()) {
              next = 0;
              for (int i = 0; i < cur; i++) {
                  Node curPoll = queue.poll();
                  if(curPoll.left != null){
                      queue.add(curPoll.left);
                      next++;
                  }
                  if(curPoll.right != null){
                      queue.add(curPoll.right);
                      next++;
                  }
              }
              maxSize = Math.max(maxSize,next);
              cur = next;
          }
          return maxSize;
      }</code>  </pre>
  </details>

### SuccessorNode

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class11/Code06_SuccessorNode.java">测试链接</a>

- 内容：

  > 给你二叉树中的某个节点，返回该节点的后继节点。

- 思路：

  > 有右子树，一定在右子树的最左节点上
  >
  > 无右子树，其后继是 某第一个节点为根的子树，该节点为其左子树中的节点

- 代码：

  <details>
  <summary>实现代码</summary>
  <p> - 一个节点的后继节点</p>
  <pre><code>public static Node getSuccessorNode(Node node) {
  		if(node == null) return node;
  		if(node.right != null) return getLeftMost(node.right);
  		while (node.parent != null && node.parent.left != node){
  			node = node.parent;
  		}
  		return node.parent;
  	}
  	public static Node getLeftMost(Node node) {
  		if (node == null) {
  			return node;
  		}
  		while (node.left != null) {
  			node = node.left;
  		}
  		return node;
  	}</code>  </pre>
  </details>

### PaperFolding

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class11/Code07_PaperFolding.java">测试链接</a>

- 内容：

  > 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。
  >
  > 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。
  >
  > 给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。
  >
  > 例如:N=1时，打印: down N=2时，打印: down down up。

- 思路：

  > 单纯的二叉树的中序遍历问题

- 代码：

  <details>
  <summary>实现代码</summary>
  <p> - 折纸凹凸</p>
  <pre><code>public static void printAllFolds(int N) {
  		process(1, N, true);
  		System.out.println();
  	}
  	// 当前你来了一个节点，脑海中想象的！
  	// 这个节点在第i层，一共有N层，N固定不变的
  	// 这个节点如果是凹的话，down = T
  	// 这个节点如果是凸的话，down = F
  	// 函数的功能：中序打印以你想象的节点为头的整棵树！
  	public static void process(int i, int N, boolean down) {
  		if (i > N) {
  			return;
  		}
  		process(i + 1, N, true);
  		System.out.print(down ? "凹 " : "凸 ");
  		process(i + 1, N, false);
  	}</code>  </pre>
  </details>