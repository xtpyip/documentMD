# 单调栈（续）、由斐波那契数列讲述矩

## 基本内容

- 什么是单调栈？

  > 从名字上就听的出来，单调栈中存放的数据应该是有序的，所以单调栈也分为**单调递增栈**和**单调递减栈**

  - 单调递增栈：单调递增栈就是从栈底到栈顶数据是从大到小
  - 单调递减栈：单调递减栈就是从栈底到栈顶数据是从小到大

- 求斐波那契数列矩阵乘法的方法

  > 1）斐波那契数列的线性求解(O(N))的方式非常好理解
  >
  > 2）同时利用线性代数，也可以改写出另一种表示 
  >
  > ​    | F(N),F(N-1) |= | F(2), F(1) | * 某个二阶矩阵的N-2次方
  >
  > 3）求出这个二阶矩阵，进而最快求出这个二阶矩阵的N-2次方

## 问题集合

### SumOfSubarrayMinimums

- 链接：<a href="https://leetcode.cn/problems/sum-of-subarray-minimums/description/">测试链接</a>

- 内容：

  > 给定一个整数数组 `arr`，找到 `min(b)` 的总和，其中 `b` 的范围为 `arr` 的每个（连续）子数组。
  >
  > 由于答案可能很大，因此 **返回答案模 `10^9 + 7`** 。
  >
  > **示例 1：**
  >
  > ```
  > 输入：arr = [3,1,2,4]
  > 输出：17
  > 解释：
  > 子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
  > 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：arr = [11,81,94,43,3]
  > 输出：444
  > ```

- 思路：

  > 思路一：暴力尝试
  >
  > 思路二：最优解思路
  >
  > 思路三：最优解单调栈优化
  
- 代码：

  <details>
  <summary>暴力尝试</summary>
  <p> - 子数组的最小值之和</p>
  <pre><code>	public static int subArrayMinSum1(int[] arr) {
  		int ans = 0;
  		for (int i = 0; i < arr.length; i++) {
  			for (int j = i; j < arr.length; j++) {
  				int min = arr[i];
  				for (int k = i + 1; k <= j; k++) {
  					min = Math.min(min, arr[k]);
  				}
  				ans += min;
  			}
  		}
  		return ans;
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>最优解思路</summary>
  <p> - 子数组的最小值之和</p>
  <pre><code>	// 没有用单调栈
  	public static int subArrayMinSum2(int[] arr) {
  		// left[i] = x : arr[i]左边，离arr[i]最近，<=arr[i]，位置在x
  		int[] left = leftNearLessEqual2(arr);
  		// right[i] = y : arr[i]右边，离arr[i]最近，< arr[i],的数，位置在y
  		int[] right = rightNearLess2(arr);
  		int ans = 0;
  		for (int i = 0; i < arr.length; i++) {
  			int start = i - left[i];
  			int end = right[i] - i;
  			ans += start * end * arr[i];
  		}
  		return ans;
  	}
  	public static int[] leftNearLessEqual2(int[] arr) {
  		int N = arr.length;
  		int[] left = new int[N];
  		for (int i = 0; i < N; i++) {
  			int ans = -1;
  			for (int j = i - 1; j >= 0; j--) {
  				if (arr[j] <= arr[i]) {
  					ans = j;
  					break;
  				}
  			}
  			left[i] = ans;
  		}
  		return left;
  	}
  	public static int[] rightNearLess2(int[] arr) {
  		int N = arr.length;
  		int[] right = new int[N];
  		for (int i = 0; i < N; i++) {
  			int ans = N;
  			for (int j = i + 1; j < N; j++) {
  				if (arr[i] > arr[j]) {
  					ans = j;
  					break;
  				}
  			}
  			right[i] = ans;
  		}
  		return right;
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>最优解单调栈优化</summary>
  <p> - 子数组的最小值之和</p>
  <pre><code>	public static int sumSubarrayMins(int[] arr) {
  		int[] stack = new int[arr.length];
  		int[] left = nearLessEqualLeft(arr, stack);
  		int[] right = nearLessRight(arr, stack);
  		long ans = 0;
  		for (int i = 0; i < arr.length; i++) {
  			long start = i - left[i];
  			long end = right[i] - i;
  			ans += start * end * (long) arr[i];
  			ans %= 1000000007;
  		}
  		return (int) ans;
  	}
  	public static int[] nearLessEqualLeft(int[] arr, int[] stack) {
  		int N = arr.length;
  		int[] left = new int[N];
  		int size = 0;
  		for (int i = N - 1; i >= 0; i--) {
  			while (size != 0 && arr[i] <= arr[stack[size - 1]]) {
  				left[stack[--size]] = i;
  			}
  			stack[size++] = i;
  		}
  		while (size != 0) {
  			left[stack[--size]] = -1;
  		}
  		return left;
  	}
  	public static int[] nearLessRight(int[] arr, int[] stack) {
  		int N = arr.length;
  		int[] right = new int[N];
  		int size = 0;
  		for (int i = 0; i < N; i++) {
  			while (size != 0 && arr[stack[size - 1]] > arr[i]) {
  				right[stack[--size]] = i;
  			}
  			stack[size++] = i;
  		}
  		while (size != 0) {
  			right[stack[--size]] = N;
  		}
  		return right;
  	}</code>  </pre>
  </details>

### Fibonacci

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class26/Code02_FibonacciProblem.java">测试链接</a>

- 内容：

  > **一、求第n个fibonacci的值。**
  >
  > **二、s(n) = s(n-1)+s(n-2);s(1)=1,s(2)=2;求n的值**
  >
  > **三、第一年农场有1只成熟的母牛A**，往后的每年︰ c方法
  >
  > 1）每一只成熟的母牛都会生一只母牛
  >
  > 2）每一只新出生的母牛都在出生的第三年成熟
  >
  > 3）每一只母牛永远不会死
  >
  > **返回N年后牛的数量**

- 思路：

  > 思路一：暴力递归
  >
  > 思路二：备忘录
  >
  > 思路三：矩阵求值

- 代码：

  <details>
  <summary>fibonacci求值</summary>
  <p> - fibonacci值</p>
  <pre><code>	public static int f1(int n) {
  		if (n < 1) {
  			return 0;
  		}
  		if (n == 1 || n == 2) {
  			return 1;
  		}
  		return f1(n - 1) + f1(n - 2);
  	}
  	public static int f2(int n) {
  		if (n < 1) {
  			return 0;
  		}
  		if (n == 1 || n == 2) {
  			return 1;
  		}
  		int res = 1;
  		int pre = 1;
  		int tmp = 0;
  		for (int i = 3; i <= n; i++) {
  			tmp = res;
  			res = res + pre;
  			pre = tmp;
  		}
  		return res;
  	}
  	// O(logN)
  	public static int f3(int n) {
  		if (n < 1) {
  			return 0;
  		}
  		if (n == 1 || n == 2) {
  			return 1;
  		}
  		// [ 1 ,1 ]
  		// [ 1, 0 ]
  		int[][] base = { 
  				{ 1, 1 }, 
  				{ 1, 0 } 
  				};
  		int[][] res = matrixPower(base, n - 2);
  		return res[0][0] + res[1][0];
  	}
  	public static int[][] matrixPower(int[][] m, int p) {
  		int[][] res = new int[m.length][m[0].length];
  		for (int i = 0; i < res.length; i++) {
  			res[i][i] = 1;
  		}
  		// res = 矩阵中的1
  		int[][] t = m;// 矩阵1次方
  		for (; p != 0; p >>= 1) {
  			if ((p & 1) != 0) {
  				res = product(res, t);
  			}
  			t = product(t, t);
  		}
  		return res;
  	}
  	// 两个矩阵乘完之后的结果返回
  	public static int[][] product(int[][] a, int[][] b) {
  		int n = a.length;
  		int m = b[0].length;
  		int k = a[0].length; // a的列数同时也是b的行数
  		int[][] ans = new int[n][m];
  		for(int i = 0 ; i < n; i++) {
  			for(int j = 0 ; j < m;j++) {
  				for(int c = 0; c < k; c++) {
  					ans[i][j] += a[i][c] * b[c][j];
  				}
  			}
  		}
  		return ans;
  	}</code>  </pre>
  </details>

  <details>
  <summary>第n荐s的值</summary>
  <p> - s值</p>
  <pre><code>	public static int s1(int n) {
  		if (n < 1) {
  			return 0;
  		}
  		if (n == 1 || n == 2) {
  			return n;
  		}
  		return s1(n - 1) + s1(n - 2);
  	}
  	public static int s2(int n) {
  		if (n < 1) {
  			return 0;
  		}
  		if (n == 1 || n == 2) {
  			return n;
  		}
  		int res = 2;
  		int pre = 1;
  		int tmp = 0;
  		for (int i = 3; i <= n; i++) {
  			tmp = res;
  			res = res + pre;
  			pre = tmp;
  		}
  		return res;
  	}
  	public static int s3(int n) {
  		if (n < 1) {
  			return 0;
  		}
  		if (n == 1 || n == 2) {
  			return n;
  		}
  		int[][] base = { { 1, 1 }, { 1, 0 } };
  		int[][] res = matrixPower(base, n - 2);
  		return 2 * res[0][0] + res[1][0];
  	}</code>  </pre>
  </details>

  <details>
  <summary>母牛的数量</summary>
  <p> - 递推求和</p>
  <pre><code>public static int c1(int n) {
  		if (n < 1) {
  			return 0;
  		}
  		if (n == 1 || n == 2 || n == 3) {
  			return n;
  		}
  		return c1(n - 1) + c1(n - 3);
  	}
  	public static int c2(int n) {
  		if (n < 1) {
  			return 0;
  		}
  		if (n == 1 || n == 2 || n == 3) {
  			return n;
  		}
  		int res = 3;
  		int pre = 2;
  		int prepre = 1;
  		int tmp1 = 0;
  		int tmp2 = 0;
  		for (int i = 4; i <= n; i++) {
  			tmp1 = res;
  			tmp2 = pre;
  			res = res + prepre;
  			pre = tmp1;
  			prepre = tmp2;
  		}
  		return res;
  	}
  	public static int c3(int n) {
  		if (n < 1) {
  			return 0;
  		}
  		if (n == 1 || n == 2 || n == 3) {
  			return n;
  		}
  		int[][] base = { 
  				{ 1, 1, 0 }, 
  				{ 0, 0, 1 }, 
  				{ 1, 0, 0 } };
  		int[][] res = matrixPower(base, n - 3);
  		return 3 * res[0][0] + 2 * res[1][0] + res[2][0];
  	}</code>  </pre>
  </details>

### ZeroLeftOneStringNumber

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class26/Code03_ZeroLeftOneStringNumber.java">测试链接</a>

- 内容：

  > 给定一个数N，想象只由0和1两种字符，组成的所有长度为N的字符串
  >
  > 如果某个字符串，任何0字符的左边都有1紧挨着，认为这个字符串达标
  >
  > 返回有多少达标的字符串。

- 思路：

  > fibonacci问题 递归 行列式乘法加速
  >
  > 长度为1  0，1 只有1种 
  >
  > 长度为2 00，01，10，11 只有两种  1->10,11
  >
  > 长度为3 000 ，001，010，011，100，101，110，111  10->101 11->110,111
  >
  > 长度为n f(n) = f(n-1)+f(n-2)
  >
  > 思路一：暴力递归
  >
  > 思路二：备忘录
  >
  > 思路三：矩阵相乘

- 代码：

  <details>
  <summary>递推求值</summary>
  <p> - 达标字符串数量</p>
  <pre><code>public static int getNum1(int n) {
  		if (n < 1) {
  			return 0;
  		}
  		return process(1, n);
  	}
  	public static int process(int i, int n) {
  		if (i == n - 1) {
  			return 2;
  		}
  		if (i == n) {
  			return 1;
  		}
  		return process(i + 1, n) + process(i + 2, n);
  	}
  	public static int getNum2(int n) {
  		if (n < 1) {
  			return 0;
  		}
  		if (n == 1) {
  			return 1;
  		}
  		int pre = 1;
  		int cur = 1;
  		int tmp = 0;
  		for (int i = 2; i < n + 1; i++) {
  			tmp = cur;
  			cur += pre;
  			pre = tmp;
  		}
  		return cur;
  	}
  	public static int getNum3(int n) {
  		if (n < 1) {
  			return 0;
  		}
  		if (n == 1 || n == 2) {
  			return n;
  		}
  		int[][] base = { { 1, 1 }, { 1, 0 } };
  		int[][] res = matrixPower(base, n - 2);
  		return 2 * res[0][0] + res[1][0];
  	}
  	public static int[][] matrixPower(int[][] m, int p) {
  		int[][] res = new int[m.length][m[0].length];
  		for (int i = 0; i < res.length; i++) {
  			res[i][i] = 1;
  		}
  		int[][] tmp = m;
  		for (; p != 0; p >>= 1) {
  			if ((p & 1) != 0) {
  				res = product(res, tmp);
  			}
  			tmp = product(tmp, tmp);
  		}
  		return res;
  	}
  	// 两个矩阵乘完之后的结果返回
  	public static int[][] product(int[][] a, int[][] b) {
  		int n = a.length;
  		int m = b[0].length;
  		int k = a[0].length; // a的列数同时也是b的行数
  		int[][] ans = new int[n][m];
  		for(int i = 0 ; i < n; i++) {
  			for(int j = 0 ; j < m;j++) {
  				for(int c = 0; c < k; c++) {
  					ans[i][j] += a[i][c] * b[c][j];
  				}
  			}
  		}
  		return ans;
  	}</code>  </pre>
  </details>