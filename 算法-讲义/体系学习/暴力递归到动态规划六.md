# 暴力递归到动态规划六

## 基本内容

- 暴力递归就是尝试

  > 1，把问题转化为规模缩小了的同类问题的子问题
  >
  > 2，有明确的不需要继续进行递归的条件(base case)
  >
  > 3，有当得到了子问题的结果之后的决策过程
  >
  > 4，不记录每一个子问题的解

- 动态规划

  > 动态规划（Dynamic Programming,DP）算法通常用于求解某种具有最优性质的问题。在这类问题中，可能会有许多可行解，每一个解都对应一个值，我们希望找到具有最优值的解。
  > 动态规划算法与分治法类似，其基本思想也是将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解中 得到原有问题的解。与分治法不同的是，动态规划经分解后得到的**子问题往往不是相互独立的。**

- 暴力递归与动态规划的关系

  > 递归包含了含有**重复子问题的递归**与**不含有重复子问题的递归**
  >
  > **动态规划**只与**重复子问题的递归**有关系
  >
  > **所有动态规划问题全部可以由递归实现，但只有含有重复子问题的递归才能由动态规划实现。**

- 怎么尝试—件事?

  > 1）有经验但是没有方法论?
  >
  > 2）怎么判断一个尝试就是最优尝试?
  >
  > 3）难道尝试这件事真的只能拼天赋?那我咋搞定我的面试?
  >
  > 4）动态规划是啥?好高端的样子哦…可是我不会啊!和尝试有什么关系?

- 什么暴力递归可以继续优化?

  > 有**重复调用**同一个子问题的解，这种递归可以优化
  >
  > 如果每一个子问题都是不同的解，无法优化也不用优化

- 面试题和动态规划的关系

  > 解决一个问题，可能有很多尝试方法
  >
  > 可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式
  >
  > **一个问题可能有若干种动态规划的解法**

- 如何找到某个问题的动态规划方式?

  > 1）设计暴力递归∶重要原则+4种常见尝试模型!重点!
  >
  > 2）分析有没有重复解︰套路解决
  >
  > 3）用记忆化搜索->用严格表结构实现动态规划∶套路解决
  >
  > 4）看看能否继续优化∶套路解决

- 面试中设计暴力递归过程的原则

  > 1）每一个可变参数的类型，一定不要比int类型更加复杂
  >
  > 2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数
  >
  > 3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可
  >
  > 4）可变参数的个数，能少则少

- 知道了面试中设计暴力递归过程的原则，然后呢?

  > 一定要逼自己找到不违反原则情况下的暴力尝试!
  >
  > 如果你找到的暴力尝试，不符合原则，马上舍弃!找新的!
  >
  > 如果某个题目突破了设计原则，一定极难极难，面试中出现**概率低于5%** !

- 常见的4种尝试模型

  > 1）从左往右的尝试模型
  >
  > 2）范围上的尝试模型
  >
  > 3）多样本位置全对应的尝试模型
  >
  > 4）寻找业务限制的尝试模型

- 如何分析有没有重复解

  > 列出调用过程，可以只列出前几层
  >
  > 有没有重复解，一看便知

- 暴力递归到动态规划的套路

  > 1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用
  >
  > 2）找到哪些参数的变化会影响返回值，对每一个列出变化范围
  >
  > 3）参数间的所有的组合数量，意味着表大小
  >
  > 4）记忆化搜索的方法就是傻缓存，非常容易得到
  >
  > 5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解
  >
  > 6）对于有枚举行为的决策过程，进一步优化

- 动态规划的进一步优化

  > 1）空间压缩
  >
  > 2）状态化简
  >
  > 3）四边形不等式
  >
  > 4）其他优化技巧

## 问题集合

### SplitSumClosed

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class23/Code01_SplitSumClosed.java">测试链接</a>

- 内容：

  > 给定一个正数数组arr,请把arr中所有的数分成两个集合，尽量让两个集合的累加和接近
  >
  > 返回︰最接近的情况下，较小集合的累加和。

- 思路：

  > 递归
  >
  > dp 递归转化
  >

- 代码：

  <details>
  <summary>递归</summary>
  <p> - 较小集合的累加和</p>
  <pre><code>	public static int right(int[] arr) {
  		if (arr == null || arr.length < 2) {
  			return 0;
  		}
  		int sum = 0;
  		for (int num : arr) {
  			sum += num;
  		}
  		return process(arr, 0, sum / 2);
  	}
  	// arr[i...]可以自由选择，请返回累加和尽量接近rest，但不能超过rest的情况下，最接近的累加和是多少？
  	public static int process(int[] arr, int i, int rest) {
  		if (i == arr.length) {
  			return 0;
  		} else { // 还有数，arr[i]这个数
  			// 可能性1，不使用arr[i]
  			int p1 = process(arr, i + 1, rest);
  			// 可能性2，要使用arr[i]
  			int p2 = 0;
  			if (arr[i] <= rest) {
  				p2 = arr[i] + process(arr, i + 1, rest - arr[i]);
  			}
  			return Math.max(p1, p2);
  		}
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp</summary>
  <p> - 较小集合的累加和</p>
  <pre><code>public static int dp(int[] arr) {
  		if (arr == null || arr.length < 2) {
  			return 0;
  		}
  		int sum = 0;
  		for (int num : arr) {
  			sum += num;
  		}
  		sum /= 2;
  		int N = arr.length;
  		int[][] dp = new int[N + 1][sum + 1];
  		for (int i = N - 1; i >= 0; i--) {
  			for (int rest = 0; rest <= sum; rest++) {
  				// 可能性1，不使用arr[i]
  				int p1 = dp[i + 1][rest];
  				// 可能性2，要使用arr[i]
  				int p2 = 0;
  				if (arr[i] <= rest) {
  					p2 = arr[i] + dp[i + 1][rest - arr[i]];
  				}
  				dp[i][rest] = Math.max(p1, p2);
  			}
  		}
  		return dp[0][sum];
  	}</code>  </pre>
  </details>

### SplitSumClosedSizeHalf

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class23/Code02_SplitSumClosedSizeHalf.java">测试链接</a>

- 内容：

  >   给定一个正数数组arr，请把arr中所有的数分成两个集合
  >   
  >    如果arr长度为偶数，两个集合包含数的个数要一样多
  >   
  >    如果arr长度为奇数，两个集合包含数的个数必须只差一个
  >   
  >   请尽量让两个集合的累加和接近
  >   
  >    返回:
  >   
  >   最接近的情况下，较小集合的累加和
  >
  
- 思路：

  > 递归
  >
  > dp 递归转化
  >
  > dp dp枚举优化

- 代码：

  <details>
  <summary>递归</summary>
  <p> - 较小集合的累加和</p>
  <pre><code>	public static int right(int[] arr) {
  		if (arr == null || arr.length < 2) {
  			return 0;
  		}
  		int sum = 0;
  		for (int num : arr) {
  			sum += num;
  		}
  		if ((arr.length & 1) == 0) {
  			return process(arr, 0, arr.length / 2, sum / 2);
  		} else {
  			return Math.max(process(arr, 0, arr.length / 2, sum / 2), process(arr, 0, arr.length / 2 + 1, sum / 2));
  		}
  	}
  	// arr[i....]自由选择，挑选的个数一定要是picks个，累加和<=rest, 离rest最近的返回
  	public static int process(int[] arr, int i, int picks, int rest) {
  		if (i == arr.length) {
  			return picks == 0 ? 0 : -1;
  		} else {
  			int p1 = process(arr, i + 1, picks, rest);
  			// 就是要使用arr[i]这个数
  			int p2 = -1;
  			int next = -1;
  			if (arr[i] <= rest) {
  				next = process(arr, i + 1, picks - 1, rest - arr[i]);
  			}
  			if (next != -1) {
  				p2 = arr[i] + next;
  			}
  			return Math.max(p1, p2);
  		}
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp</summary>
  <p> - 较小集合的累加和</p>
  <pre><code>	public static int dp(int[] arr) {
  		if (arr == null || arr.length < 2) {
  			return 0;
  		}
  		int sum = 0;
  		for (int num : arr) {
  			sum += num;
  		}
  		sum /= 2;
  		int N = arr.length;
  		int M = (N + 1) / 2;
  		int[][][] dp = new int[N + 1][M + 1][sum + 1];
  		for (int i = 0; i <= N; i++) {
  			for (int j = 0; j <= M; j++) {
  				for (int k = 0; k <= sum; k++) {
  					dp[i][j][k] = -1;
  				}
  			}
  		}
  		for (int rest = 0; rest <= sum; rest++) {
  			dp[N][0][rest] = 0;
  		}
  		for (int i = N - 1; i >= 0; i--) {
  			for (int picks = 0; picks <= M; picks++) {
  				for (int rest = 0; rest <= sum; rest++) {
  					int p1 = dp[i + 1][picks][rest];
  					// 就是要使用arr[i]这个数
  					int p2 = -1;
  					int next = -1;
  					if (picks - 1 >= 0 && arr[i] <= rest) {
  						next = dp[i + 1][picks - 1][rest - arr[i]];
  					}
  					if (next != -1) {
  						p2 = arr[i] + next;
  					}
  					dp[i][picks][rest] = Math.max(p1, p2);
  				}
  			}
  		}
  		if ((arr.length & 1) == 0) {
  			return dp[0][arr.length / 2][sum];
  		} else {
  			return Math.max(dp[0][arr.length / 2][sum], dp[0][(arr.length / 2) + 1][sum]);
  		}
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp枚举优化</summary>
  <p> - 较小集合的累加和</p>
  <pre><code>	public static int dp2(int[] arr) {
  		if (arr == null || arr.length < 2) {
  			return 0;
  		}
  		int sum = 0;
  		for (int num : arr) {
  			sum += num;
  		}
  		sum >>= 1;
  		int N = arr.length;
  		int M = (arr.length + 1) >> 1;
  		int[][][] dp = new int[N][M + 1][sum + 1];
  		for (int i = 0; i < N; i++) {
  			for (int j = 0; j <= M; j++) {
  				for (int k = 0; k <= sum; k++) {
  					dp[i][j][k] = Integer.MIN_VALUE;
  				}
  			}
  		}
  		for (int i = 0; i < N; i++) {
  			for (int k = 0; k <= sum; k++) {
  				dp[i][0][k] = 0;
  			}
  		}
  		for (int k = 0; k <= sum; k++) {
  			dp[0][1][k] = arr[0] <= k ? arr[0] : Integer.MIN_VALUE;
  		}
  		for (int i = 1; i < N; i++) {
  			for (int j = 1; j <= Math.min(i + 1, M); j++) {
  				for (int k = 0; k <= sum; k++) {
  					dp[i][j][k] = dp[i - 1][j][k];
  					if (k - arr[i] >= 0) {
  						dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - 1][k - arr[i]] + arr[i]);
  					}
  				}
  			}
  		}
  		return Math.max(dp[N - 1][M][sum], dp[N - 1][N - M][sum]);
  	}</code>  </pre>
  </details>

### NQueens

- 链接：<a href="https://leetcode.cn/problems/n-queens/description/">测试链接(辅助)</a>

- 内容：

  >   按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
  >
  >   **n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。
  >
  >   给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。
  >
  >   每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。
  >
  >   **示例 1：**
  >
  >   ![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)
  >
  >   ```
  >   输入：n = 4
  >   输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
  >   解释：如上图所示，4 皇后问题存在两个不同的解法。
  >   ```
  >
  >   **示例 2：**
  >
  >   ```
  >   输入：n = 1
  >   输出：[["Q"]]
  >   ```

- 思路：

  > 递归
  >
  > 递归优化，位运算
  >

- 代码：

  <details>
  <summary>递归</summary>
  <p> - n皇后的摆法有多少种</p>
  <pre><code>	public static int num1(int n) {
  		if (n < 1) {
  			return 0;
  		}
  		int[] record = new int[n];
  		return process1(0, record, n);
  	}
  	// 当前来到i行，一共是0~N-1行
  	// 在i行上放皇后，所有列都尝试
  	// 必须要保证跟之前所有的皇后不打架
  	// int[] record record[x] = y 之前的第x行的皇后，放在了y列上
  	// 返回：不关心i以上发生了什么，i.... 后续有多少合法的方法数
  	public static int process1(int i, int[] record, int n) {
  		if (i == n) {
  			return 1;
  		}
  		int res = 0;
  		// i行的皇后，放哪一列呢？j列，
  		for (int j = 0; j < n; j++) {
  			if (isValid(record, i, j)) {
  				record[i] = j;
  				res += process1(i + 1, record, n);
  			}
  		}
  		return res;
  	}
  	public static boolean isValid(int[] record, int i, int j) {
  		// 0..i-1
  		for (int k = 0; k < i; k++) {
  			if (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) {
  				return false;
  			}
  		}
  		return true;
  	}</code>  </pre>
  </details>

  <details>
  <summary>递归优化</summary>
  <p> - n皇后的摆法有多少种</p>
  <pre><code>	// 请不要超过32皇后问题
  	public static int num2(int n) {
  		if (n < 1 || n > 32) {
  			return 0;
  		}
  		// 如果你是13皇后问题，limit 最右13个1，其他都是0
  		int limit = n == 32 ? -1 : (1 << n) - 1;
  		return process2(limit, 0, 0, 0);
  	}
  	// 7皇后问题
  	// limit : 0....0 1 1 1 1 1 1 1
  	// 之前皇后的列影响：colLim
  	// 之前皇后的左下对角线影响：leftDiaLim
  	// 之前皇后的右下对角线影响：rightDiaLim
  	public static int process2(int limit, int colLim, int leftDiaLim, int rightDiaLim) {
  		if (colLim == limit) {
  			return 1;
  		}
  		// pos中所有是1的位置，是你可以去尝试皇后的位置
  		int pos = limit & (~(colLim | leftDiaLim | rightDiaLim));
  		int mostRightOne = 0;
  		int res = 0;
  		while (pos != 0) {
  			mostRightOne = pos & (~pos + 1);
  			pos = pos - mostRightOne;
  			res += process2(limit, colLim | mostRightOne, (leftDiaLim | mostRightOne) << 1,
  					(rightDiaLim | mostRightOne) >>> 1);
  		}
  		return res;
  	}</code>  </pre>
  </details>