# 堆和堆排序

## 基本内容

- 比较器

  > 1）比较器的实质就是重载比较运算符
  >
  > 2）比较器可以很好的应用在特殊标准的排序上
  >
  > 3）比较器可以很好的应用在根据特殊标准排序的结构上
  >
  > 4）写代码变得异常容易，还用于范型编程

- 堆排序

  > 1，先让整个数组都变成大根堆结构，建立堆的过程:
  >
  >   1）从上到下的方法，时间复杂度为O(N*logN)*
  >   2）从下到上的方法，时间复杂度为O(N)
  >
  > 2，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始,时间复杂度为O(NlogN)
  >
  > 3，堆的大小减小成0之后，排序完成







## 问题集合

### Comparator

- 链接：暂无

- 内容：

  > 比较器排序
  >

- 思路：

  > 见下代码及其打印结果
  >

- 代码：

  <details>
  <summary>比较器代码</summary>
  <p> - map中的使用</p>
  <pre><code> 	public static class Student {
  		public String name;
  		public int id;
  		public int age;
  		public Student(String name, int id, int age) {
  			this.name = name;
  			this.id = id;
  			this.age = age;
  		}
  	}
  	// 任何比较器：
  	// compare方法里，遵循一个统一的规范：
  	// 返回负数的时候，认为第一个参数应该排在前面
  	// 返回正数的时候，认为第二个参数应该排在前面
  	// 返回0的时候，认为无所谓谁放前面
  	public static class IdShengAgeJiangOrder implements Comparator<Student> {
  		// 根据id从小到大，但是如果id一样，按照年龄从大到小
  		@Override
  		public int compare(Student o1, Student o2) {
  			return o1.id != o2.id ? (o1.id - o2.id) : (o2.age - o1.age);
  		}
  	}
  	public static class IdAscendingComparator implements Comparator<Student> {
  		// 返回负数的时候，第一个参数排在前面
  		// 返回正数的时候，第二个参数排在前面
  		// 返回0的时候，谁在前面无所谓
  		@Override
  		public int compare(Student o1, Student o2) {
  			return o1.id - o2.id;
  		}
  	}
  	public static class IdDescendingComparator implements Comparator<Student> {
  		@Override
  		public int compare(Student o1, Student o2) {
  			return o2.id - o1.id;
  		}
  	}
  	// 先按照id排序，id小的，放前面；
  	// id一样，age大的，前面；
  	public static class IdInAgeDe implements Comparator<Student> {
  		@Override
  		public int compare(Student o1, Student o2) {
  			return o1.id != o2.id ? o1.id - o2.id : (o2.age - o1.age);
  		}
  	}
  	public static void printStudents(Student[] students) {
  		for (Student student : students) {
  			System.out.println("Name : " + student.name + ", Id : " + student.id + ", Age : " + student.age);
  		}
  	}
  	public static void printArray(Integer[] arr) {
  		if (arr == null) {
  			return;
  		}
  		for (int i = 0; i < arr.length; i++) {
  			System.out.print(arr[i] + " ");
  		}
  		System.out.println();
  	}
  	public static class MyComp implements Comparator<Integer> {
  		@Override
  		public int compare(Integer o1, Integer o2) {
  			return o2 - o1;
  		}
  	}
  	public static class AComp implements Comparator<Integer> {
  		// 如果返回负数，认为第一个参数应该拍在前面
  		// 如果返回正数，认为第二个参数应该拍在前面
  		// 如果返回0，认为谁放前面都行
  		@Override
  		public int compare(Integer arg0, Integer arg1) {
  			return arg1 - arg0;
  //			return 0;
  		}
  	}
  	public static void main(String[] args) {
  		Integer[] arr = {5, 4, 3, 2, 7, 9, 1, 0};
  		Arrays.sort(arr, new AComp());
  		for (int i = 0; i < arr.length; i++) {
  			System.out.println(arr[i]); // 9 7 5 4 3 2 1 0
  		}
  		System.out.println("==========================="); // ===========================
  		Student student1 = new Student("A", 4, 40);
  		Student student2 = new Student("B", 4, 21);
  		Student student3 = new Student("C", 3, 12);
  		Student student4 = new Student("D", 3, 62);
  		Student student5 = new Student("E", 3, 42);
  		// D E C A B
  		Student[] students = new Student[]{student1, student2, student3, student4, student5};
  		System.out.println("第一条打印"); // 第一条打印
  		Arrays.sort(students, new IdShengAgeJiangOrder());
  		for (int i = 0; i < students.length; i++) {
  			Student s = students[i];
  			System.out.println(s.name + "," + s.id + "," + s.age); // D,3,62 E,3,42 C,3,12 A,4,40 B,4,21
  		}
  		System.out.println("第二条打印"); // 第二条打印
  		ArrayList<Student> studentList = new ArrayList<>();
  		studentList.add(student1);
  		studentList.add(student2);
  		studentList.add(student3);
  		studentList.add(student4);
  		studentList.add(student5);
  		studentList.sort(new IdShengAgeJiangOrder());
  		for (int i = 0; i < studentList.size(); i++) {
  			Student s = studentList.get(i);
  			System.out.println(s.name + "," + s.id + "," + s.age); // D,3,62 E,3,42 C,3,12 A,4,40 B,4,21
  		}
  		// N * logN
  		System.out.println("第三条打印"); // 第三条打印
  		student1 = new Student("A", 4, 40);
  		student2 = new Student("B", 4, 21);
  		student3 = new Student("C", 4, 12);
  		student4 = new Student("D", 4, 62);
  		student5 = new Student("E", 4, 42);
  		TreeMap<Student, String> treeMap = new TreeMap<>((a, b) -> (a.id - b.id));
  		treeMap.put(student1, "我是学生1，我的名字叫A");
  		treeMap.put(student2, "我是学生2，我的名字叫B");
  		treeMap.put(student3, "我是学生3，我的名字叫C");
  		treeMap.put(student4, "我是学生4，我的名字叫D");
  		treeMap.put(student5, "我是学生5，我的名字叫E");
  		for (Student s : treeMap.keySet()) {
  			System.out.println(s.name + "," + s.id + "," + s.age);// A,4,40
  		}
  	}  </code>  </pre>
  </details>

### Heap

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class06/Code02_Heap.java">测试链接</a>

- 内容：

  > 堆有两种，大根堆及小根堆
  >
  > 大根堆：任意节点的值都大于左右节点的值（如果存在）
  >
  > 小根堆：任意节点的值都小于左右节点的值（如果存在）

- 思路：

  > 见下大根堆实现代码，小根堆略

- 代码：

  <details>
  <summary>堆代码</summary>
  <p> - 自定义大根堆</p>
  <pre><code>	public static class MyMaxHeap {
          private int[] heap; // heap[i]的左右节点为heap[2*i+1],heap[2*i+2]
          private final int limit; // 最多只能有limit个数
          private int heapSize; // 实际拥有的数量
          public MyMaxHeap(int limit) { // 指定堆的大小
              heap = new int[limit];
              this.limit = limit;
              heapSize = 0;
          }
          public boolean isEmpty() {
              return heapSize == 0;
          }
          public boolean isFull() {
              return heapSize == limit;
          }
          public void push(int value) {
              // 添加一个数据
              if (isFull()) throw new RuntimeException("数据已满");
              heap[heapSize] = value; // 添加到末尾
              // 末尾这个点的值是否可以取代父节点
              heapInsert(heap, heapSize++);
          }
          // 用户此时，让你返回最大值，并且在大根堆中，把最大值删掉
          // 剩下的数，依然保持大根堆组织
          public int pop() {
              if (isEmpty()) throw new RuntimeException("堆为空");
              int popValue = heap[0];
              swap(heap, 0, --heapSize);
              heapify(heap, 0, heapSize);
              return popValue;
          }
          // 新加进来的数，现在停在了index位置，请依次往上移动，
          // 移动到0位置，或者干不掉自己的父亲了，停！
          private void heapInsert(int[] arr, int index) {
  //            while (index != 0 && arr[index] > arr[(index-1)/2]){ //  arr[0] > arr[(0-1)/2] always false
              while (arr[index] > arr[(index - 1) / 2]) {
                  swap(arr, index, (index - 1) / 2);
                  index = (index - 1) / 2;
              }
          }
          // 从index位置，往下看，不断的下沉
          // 停：较大的孩子都不再比index位置的数大；已经没孩子了
          private void heapify(int[] arr, int index, int heapSize) {
              int leftIndex = 2 * index + 1;
              while (leftIndex < heapSize) { // 是否存在左孩子
                  // 找到左右孩子最大的值的下标
                  int largestIndex = leftIndex + 1 < heapSize && arr[leftIndex] < arr[leftIndex + 1] ? leftIndex + 1 : leftIndex;
                  largestIndex = arr[largestIndex] > arr[index] ? largestIndex : index;
                  if (largestIndex == index) {
                      break;
                  }
                  // 进行交换
                  swap(arr, largestIndex, index);
                  index = largestIndex;
                  leftIndex = index * 2 + 1;
              }
          }
          private void swap(int[] arr, int i, int j) {
              int tmp = arr[i];
              arr[i] = arr[j];
              arr[j] = tmp;
          }
      }</code>  </pre>
  </details>

### HeapSort

- 链接：<a href="https://leetcode.cn/problems/sort-an-array/description/">升序测试</a>

- 内容：

  > 给你一个整数数组 `nums`，请你将该数组升序排列。
  >
  > **示例 1：**
  >
  > ```
  > 输入：nums = [5,2,3,1]
  > 输出：[1,2,3,5]
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：nums = [5,1,1,2,0,0]
  > 输出：[0,0,1,1,2,5]
  > ```

- 思路：

  > 使用大根堆实现（O(NlogN)）
  >
  > 建完堆后，
  >
  > 0与heapSize-1位置的值互换，在0~heapSize-2中进行调整 （heapSize = heapSize -1）
  >
  > 再使用0与heapSize-1午饭了的值互换，在0~heapSize-2中进行调整（heapSize = heapSize -1）
  >
  > 直到heapSize = 0结束

- 代码：

  <details>
  <summary>实现数组升序代码</summary>
  <p> - 大根堆实现</p>
  <pre><code>	// 使用大根堆完成arr数组从小到大排序
      public static void headSort(int[] arr){
          if(arr == null || arr.length < 1) return;
          // 两种方法调整堆
          // 一个个传递数据 O(NlogN)
  //        for (int i = 0; i < arr.length; i++) { // O(N)
  //            heapInsert(arr,i); // O(logN)
  //        }
          // O(N) 自上到下建堆
          for (int i = arr.length - 1; i >= 0; i--) {
              heapify(arr,i,arr.length);
          }
          int heapSize = arr.length;
          swap(arr,0,--heapSize);
          while (heapSize > 0){ // O(N)
              heapify(arr,0,heapSize); // O(logN)
              swap(arr,0,--heapSize); // O(1)
          }
      }
      // arr[index]刚来的数，往上
      public static void heapInsert(int[] arr, int index) {
          while (arr[index] > arr[(index - 1) / 2]) {
              swap(arr, index, (index - 1) / 2);
              index = (index - 1) / 2;
          }
      }
      // arr[index]位置的数，能否往下移动
      public static void heapify(int[] arr, int index, int heapSize) {
          int left = index * 2 + 1; // 左孩子的下标
          while (left < heapSize) { // 下方还有孩子的时候
              // 两个孩子中，谁的值大，把下标给largest
              // 1）只有左孩子，left -> largest
              // 2) 同时有左孩子和右孩子，右孩子的值<= 左孩子的值，left -> largest
              // 3) 同时有左孩子和右孩子并且右孩子的值> 左孩子的值， right -> largest
              int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
              // 父和较大的孩子之间，谁的值大，把下标给largest
              largest = arr[largest] > arr[index] ? largest : index;
              if (largest == index) {
                  break;
              }
              swap(arr, largest, index);
              index = largest;
              left = index * 2 + 1;
          }
      }
      public static void swap(int[] arr, int i, int j) {
          int tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
      }</code>  </pre>
  </details>

### SortArrayDistanceLessK

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class06/Code04_SortArrayDistanceLessK.java">测试链接</a>

- 内容：

  > 已知一个几乎有序的数组。
  >
  > 几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，
  >
  > 并且k相对于数组长度来说是比较小的。
  >
  > 请选择一个合适的排序策略，对这个数组进行排序。

- 思路：

  > 【0，k】个元素确定第0个值，【1，k+1】确定第1个值...
  >
  > 创建一个长度为k的小根堆，每次堆满就pop一个值放入数组中，再添加一个值到小根堆中
  >
  > 最后若小根堆中还有值，则依次添加入数组中。

- 代码：

  <details>
  <summary>实现数组升序代码</summary>
  <p> - 小根堆实现</p>
  <pre><code>	public static void sortedArrDistanceLessK(int[] arr, int k) {
  		if(k == 0) return ;
  		PriorityQueue<Integer> queue = new PriorityQueue<>(k);
  		int i = 0;
  		for (; i <= Math.min(arr.length - 1, k - 1); i++) {
  			queue.add(arr[i]);
  		}
  		int index = 0;
  		for (; i < arr.length; i++) {
  			queue.add(arr[i]);
  			arr[index++] = queue.poll();
  		}
  		while (!queue.isEmpty()) {
  			arr[index++] = queue.poll();
  		}
  	}</code>  </pre>
  </details>

  

  