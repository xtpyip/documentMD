# 有序表二

## 基本内容

- SBT

  > 每棵子树的大小，不小于其兄弟的子树的大小，也就是每棵叔叔树的大小，不小于任何侄子树的大小。

- 跳表

  > 对于单链表，即使是 存储的有序数据（即 有序链表），想在其中查找某个数据，也只能从头到尾遍历，查找效率低，时间复杂度是O(n)，如下图所示：
  >
  > ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class36/skipListMap1.png)
  >
  > 怎么才能提高查找效率呢？ 
  >
  > 为了提高查找效率，使用二分查找的思想，对有序链表建立一级“索引”。 每两个节点提取一个节点到索引层。 索引层中的每个节点 都包含两个指针，一个指向下一个节点，一个down指针，指向下一级节点。
  >
  > ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class36/skipListMap2.png)
  >
  > 假设要查找图中 18这个节点：
  >
  > 首先在一级索引层遍历，当遍历到14这个节点的时候，发现其下一个节点是23，则要查找的18就在14和23之间。 然后，通过14节点的 down 指针，下降到原始链表这一层，继续在原始链表中遍历。 此时，只需要在原始链表中，遍历两个节点，14和18,就找到18这个节点了。    查找18这个节点，在原始链表需要遍历10个节点，现在只需要遍历7个节点（一级索引层遍历5个节点，原始链表遍历2个节点）。 
  >
  > 从以上示例可以看出，加上一层索引之后，查找一个节点的遍历节点数减少了，效率提高了。如果再增加一级索引，那么效率会不会更高呢？
  >
  > 建立二级索引
  >
  > 与建立一级索引的方式类似，在第一级索引的基础上，每两个节点抽出一个节点到第二级索引，如下图：
  >
  > ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class36/skipListMap3.png)
  >
  >  现在如果要查找18节点，只需要遍历6个节点（二级索引层遍历3个节点，一级索引层1个节点，原始链表2个节点）。
  >
  > 通过建立索引的方式，对于数据量越大的有序链表，通过建立多级索引，查找效率提升会非常明显。
  >
  > 这种链表加多级索引的结构 就是 跳表。
  >

## 问题集合

### SBT

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class36/Code02_SkipListMap.java">测试链接</a>

- 内容：

  > 实现一个SB树
  
- 思路：

  > 添加递归调用检查，左旋与右旋使树平衡
  
- 代码：

  <details>
  <summary>泛型实现SBT</summary>
  <p> - SBT及扩展方法</p>
  <pre><code>	public static class SBTNode<K extends Comparable<K>, V> {
  		public K key;
  		public V value;
  		public SBTNode<K, V> l;
  		public SBTNode<K, V> r;
  		public int size; // 不同的key的数量
  		public SBTNode(K key, V value) {
  			this.key = key;
  			this.value = value;
  			size = 1;
  		}
  	}
  	public static class SizeBalancedTreeMap<K extends Comparable<K>, V> {
  		private SBTNode<K, V> root;
  		private SBTNode<K, V> rightRotate(SBTNode<K, V> cur) {
  			SBTNode<K, V> leftNode = cur.l;
  			cur.l = leftNode.r;
  			leftNode.r = cur;
  			leftNode.size = cur.size;
  			cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
  			return leftNode;
  		}
  		private SBTNode<K, V> leftRotate(SBTNode<K, V> cur) {
  			SBTNode<K, V> rightNode = cur.r;
  			cur.r = rightNode.l;
  			rightNode.l = cur;
  			rightNode.size = cur.size;
  			cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
  			return rightNode;
  		}
  		private SBTNode<K, V> maintain(SBTNode<K, V> cur) {
  			if (cur == null) {
  				return null;
  			}
  			int leftSize = cur.l != null ? cur.l.size : 0;
  			int leftLeftSize = cur.l != null && cur.l.l != null ? cur.l.l.size : 0;
  			int leftRightSize = cur.l != null && cur.l.r != null ? cur.l.r.size : 0;
  			int rightSize = cur.r != null ? cur.r.size : 0;
  			int rightLeftSize = cur.r != null && cur.r.l != null ? cur.r.l.size : 0;
  			int rightRightSize = cur.r != null && cur.r.r != null ? cur.r.r.size : 0;
  			if (leftLeftSize > rightSize) {
  				cur = rightRotate(cur);
  				cur.r = maintain(cur.r);
  				cur = maintain(cur);
  			} else if (leftRightSize > rightSize) {
  				cur.l = leftRotate(cur.l);
  				cur = rightRotate(cur);
  				cur.l = maintain(cur.l);
  				cur.r = maintain(cur.r);
  				cur = maintain(cur);
  			} else if (rightRightSize > leftSize) {
  				cur = leftRotate(cur);
  				cur.l = maintain(cur.l);
  				cur = maintain(cur);
  			} else if (rightLeftSize > leftSize) {
  				cur.r = rightRotate(cur.r);
  				cur = leftRotate(cur);
  				cur.l = maintain(cur.l);
  				cur.r = maintain(cur.r);
  				cur = maintain(cur);
  			}
  			return cur;
  		}
  		private SBTNode<K, V> findLastIndex(K key) {
  			SBTNode<K, V> pre = root;
  			SBTNode<K, V> cur = root;
  			while (cur != null) {
  				pre = cur;
  				if (key.compareTo(cur.key) == 0) {
  					break;
  				} else if (key.compareTo(cur.key) < 0) {
  					cur = cur.l;
  				} else {
  					cur = cur.r;
  				}
  			}
  			return pre;
  		}
  		private SBTNode<K, V> findLastNoSmallIndex(K key) {
  			SBTNode<K, V> ans = null;
  			SBTNode<K, V> cur = root;
  			while (cur != null) {
  				if (key.compareTo(cur.key) == 0) {
  					ans = cur;
  					break;
  				} else if (key.compareTo(cur.key) < 0) {
  					ans = cur;
  					cur = cur.l;
  				} else {
  					cur = cur.r;
  				}
  			}
  			return ans;
  		}
  		private SBTNode<K, V> findLastNoBigIndex(K key) {
  			SBTNode<K, V> ans = null;
  			SBTNode<K, V> cur = root;
  			while (cur != null) {
  				if (key.compareTo(cur.key) == 0) {
  					ans = cur;
  					break;
  				} else if (key.compareTo(cur.key) < 0) {
  					cur = cur.l;
  				} else {
  					ans = cur;
  					cur = cur.r;
  				}
  			}
  			return ans;
  		}
  		// 现在，以cur为头的树上，新增，加(key, value)这样的记录
  		// 加完之后，会对cur做检查，该调整调整
  		// 返回，调整完之后，整棵树的新头部
  		private SBTNode<K, V> add(SBTNode<K, V> cur, K key, V value) {
  			if (cur == null) {
  				return new SBTNode<K, V>(key, value);
  			} else {
  				cur.size++;
  				if (key.compareTo(cur.key) < 0) {
  					cur.l = add(cur.l, key, value);
  				} else {
  					cur.r = add(cur.r, key, value);
  				}
  				return maintain(cur);
  			}
  		}
  		// 在cur这棵树上，删掉key所代表的节点
  		// 返回cur这棵树的新头部
  		private SBTNode<K, V> delete(SBTNode<K, V> cur, K key) {
  			cur.size--;
  			if (key.compareTo(cur.key) > 0) {
  				cur.r = delete(cur.r, key);
  			} else if (key.compareTo(cur.key) < 0) {
  				cur.l = delete(cur.l, key);
  			} else { // 当前要删掉cur
  				if (cur.l == null && cur.r == null) {
  					// free cur memory -> C++
  					cur = null;
  				} else if (cur.l == null && cur.r != null) {
  					// free cur memory -> C++
  					cur = cur.r;
  				} else if (cur.l != null && cur.r == null) {
  					// free cur memory -> C++
  					cur = cur.l;
  				} else { // 有左有右
  					SBTNode<K, V> pre = null;
  					SBTNode<K, V> des = cur.r;
  					des.size--;
  					while (des.l != null) {
  						pre = des;
  						des = des.l;
  						des.size--;
  					}
  					if (pre != null) {
  						pre.l = des.r;
  						des.r = cur.r;
  					}
  					des.l = cur.l;
  					des.size = des.l.size + (des.r == null ? 0 : des.r.size) + 1;
  					// free cur memory -> C++
  					cur = des;
  				}
  			}
  			// cur = maintain(cur);
  			return cur;
  		}
  		private SBTNode<K, V> getIndex(SBTNode<K, V> cur, int kth) {
  			if (kth == (cur.l != null ? cur.l.size : 0) + 1) {
  				return cur;
  			} else if (kth <= (cur.l != null ? cur.l.size : 0)) {
  				return getIndex(cur.l, kth);
  			} else {
  				return getIndex(cur.r, kth - (cur.l != null ? cur.l.size : 0) - 1);
  			}
  		}
  		public int size() {
  			return root == null ? 0 : root.size;
  		}
  		public boolean containsKey(K key) {
  			if (key == null) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			SBTNode<K, V> lastNode = findLastIndex(key);
  			return lastNode != null && key.compareTo(lastNode.key) == 0 ? true : false;
  		}
  		// （key，value） put -> 有序表 新增、改value
  		public void put(K key, V value) {
  			if (key == null) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			SBTNode<K, V> lastNode = findLastIndex(key);
  			if (lastNode != null && key.compareTo(lastNode.key) == 0) {
  				lastNode.value = value;
  			} else {
  				root = add(root, key, value);
  			}
  		}
  		public void remove(K key) {
  			if (key == null) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			if (containsKey(key)) {
  				root = delete(root, key);
  			}
  		}
  		public K getIndexKey(int index) {
  			if (index < 0 || index >= this.size()) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			return getIndex(root, index + 1).key;
  		}
  		public V getIndexValue(int index) {
  			if (index < 0 || index >= this.size()) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			return getIndex(root, index + 1).value;
  		}
  		public V get(K key) {
  			if (key == null) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			SBTNode<K, V> lastNode = findLastIndex(key);
  			if (lastNode != null && key.compareTo(lastNode.key) == 0) {
  				return lastNode.value;
  			} else {
  				return null;
  			}
  		}
  		public K firstKey() {
  			if (root == null) {
  				return null;
  			}
  			SBTNode<K, V> cur = root;
  			while (cur.l != null) {
  				cur = cur.l;
  			}
  			return cur.key;
  		}
  		public K lastKey() {
  			if (root == null) {
  				return null;
  			}
  			SBTNode<K, V> cur = root;
  			while (cur.r != null) {
  				cur = cur.r;
  			}
  			return cur.key;
  		}
  		public K floorKey(K key) {
  			if (key == null) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			SBTNode<K, V> lastNoBigNode = findLastNoBigIndex(key);
  			return lastNoBigNode == null ? null : lastNoBigNode.key;
  		}
  		public K ceilingKey(K key) {
  			if (key == null) {
  				throw new RuntimeException("invalid parameter.");
  			}
  			SBTNode<K, V> lastNoSmallNode = findLastNoSmallIndex(key);
  			return lastNoSmallNode == null ? null : lastNoSmallNode.key;
  		}
  	}</code>  </pre>
  </details>

### SkipMap

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class36/Code02_SkipListMap.java">测试链接</a>

- 内容：

  > 跳表

- 思路：

  > 以0.5概率来实现数据的二分

- 代码：

  <details>
  <summary>泛型实现跳表</summary>
  <p> - 跳表及其相关方法</p>
  <pre><code>	</code>  </pre>
  </details>
