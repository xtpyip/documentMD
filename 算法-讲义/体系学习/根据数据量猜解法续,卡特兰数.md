# 根据数据量猜解法续,卡特兰数

## 基本内容

- 根据数据量猜解法

  > 所有的数据量在10^8次方及以内，我们认为这个算法是可以过的。

- Catalan

  > 卡特兰数又称卡塔兰数，英文名Catalan number，是组合数学中一个常出现在各种计数问题中出现的数列。其前几项为︰
  > 1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190,6564120420,24466267020,91482563640,343059613650,1289904147324，4861946401452，...
  >
  > k(0)= 1,k(1)= 1时，如果接下来的项满足︰
  > 	**k(n)= k(0) * k(n - 1)+ k(1)*k(n - 2)+ ...+ k(n - 2) * k(1)+ k(n - 1)* k(0)**
  >
  > 或者:**k(n)= c(2n, n) - c(2n, n-1)**
  >
  > 或者: **k(n)= c(2n, n)/ (n + 1)**
  >
  > 就说这个表达式，满足卡特兰数，常用的是范式1和2，3几乎不会使用到

## 问题集合

### SubsequenceMaxModM

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class39/Code01_SubsequenceMaxModM.java">测试链接</a>

- 内容：

  > 给定一个非负数组arr，和一个正数m。
  >
  > 返回arr的所有子序列中累加和%m之后的最大值。
  
- 思路：

  > **思路1：暴力递归，所有的子序列有2^n-1种（除了一个都不选），其值%m后取最大值**
  >
  > **思路2：动态规划，i表示arr下标，j表示和，arr[i,j]表示从0~i位置任意组合和为j是否存在（arr中的数不大，m很大）**
  >
  > ​	转移方程
  >
  > ​		1、当前i不使用，则dp[i,j] = dp[i-1,j]
  >
  > ​		2、当前i使用，则dp[i,j] = dp[i-1,j-arr[i]]  
  >
  > ​		任一存在即为true
  >
  > **思路3：动态规划，i表示arr下标，j表示值，arr[i,j]表示从0~i位置任意组合和%m后的结果j是否存在（arr长度大，m不大）**
  >
  > ​	转移方程：
  >
  > ​		dp[i,j] = dp[i-1,j]
  >
  > ​		dp[i,j] = dp[i - 1,j - cur] || dp[i - 1,j + m - cur]
  >
  > ​		任一存在即为true
  >
  > **思路4：分治，当arr长度相对不大，但数值大，m也大**
  >
  > ​	将数组一分为二，每一部分先进行取值，得出最大值 (暴力递归（长度不大）)
  >
  > ​	再以其中一个为基，寻找另一个最接近<=最大值的数，更新最大值(O(logN))
  
- 代码：

  <details>
  <summary>暴力方法</summary>
  <p> - %m后的最大值</p>
  <pre><code>public static int max1(int[] arr, int m) {
  		HashSet<Integer> set = new HashSet<>();
  		process(arr, 0, 0, set);
  		int max = 0;
  		for (Integer sum : set) {
  			max = Math.max(max, sum % m);
  		}
  		return max;
  	}
  	public static void process(int[] arr, int index, int sum, HashSet<Integer> set) {
  		if (index == arr.length) {
  			set.add(sum);
  		} else {
  			process(arr, index + 1, sum, set);
  			process(arr, index + 1, sum + arr[index], set);
  		}
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp数量和</summary>
  <p> - %m的最大值</p>
  <pre><code>	public static int max2(int[] arr, int m) {
  		int sum = 0;
  		int N = arr.length;
  		for (int i = 0; i < N; i++) {
  			sum += arr[i];
  		}
  		boolean[][] dp = new boolean[N][sum + 1];
  		for (int i = 0; i < N; i++) {
  			dp[i][0] = true;
  		}
  		dp[0][arr[0]] = true;
  		for (int i = 1; i < N; i++) {
  			for (int j = 1; j <= sum; j++) {
  				dp[i][j] = dp[i - 1][j];
  				if (j - arr[i] >= 0) {
  					dp[i][j] |= dp[i - 1][j - arr[i]];
  				}
  			}
  		}
  		int ans = 0;
  		for (int j = 0; j <= sum; j++) {
  			if (dp[N - 1][j]) {
  				ans = Math.max(ans, j % m);
  			}
  		}
  		return ans;
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp %m值</summary>
  <p> - %m的最大值</p>
  <pre><code>public static int max3(int[] arr, int m) {
  		int N = arr.length;
  		// 0...m-1
  		boolean[][] dp = new boolean[N][m];
  		for (int i = 0; i < N; i++) {
  			dp[i][0] = true;
  		}
  		dp[0][arr[0] % m] = true;
  		for (int i = 1; i < N; i++) {
  			for (int j = 1; j < m; j++) {
  				// dp[i][j] T or F
  				dp[i][j] = dp[i - 1][j];
  				int cur = arr[i] % m;
  				if (cur <= j) {
  					dp[i][j] |= dp[i - 1][j - cur];
  				} else {
  					dp[i][j] |= dp[i - 1][m + j - cur];
  				}
  			}
  		}
  		int ans = 0;
  		for (int i = 0; i < m; i++) {
  			if (dp[N - 1][i]) {
  				ans = i;
  			}
  		}
  		return ans;
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>分治</summary>
  <p> - %m的最大值</p>
  <pre><code>// 如果arr的累加和很大，m也很大
  	// 但是arr的长度相对不大
  	public static int max4(int[] arr, int m) {
  		if (arr.length == 1) {
  			return arr[0] % m;
  		}
  		int mid = (arr.length - 1) / 2;
  		TreeSet<Integer> sortSet1 = new TreeSet<>();
  		process4(arr, 0, 0, mid, m, sortSet1);
  		TreeSet<Integer> sortSet2 = new TreeSet<>();
  		process4(arr, mid + 1, 0, arr.length - 1, m, sortSet2);
  		int ans = 0;
  		for (Integer leftMod : sortSet1) {
  			ans = Math.max(ans, leftMod + sortSet2.floor(m - 1 - leftMod));
  		}
  		return ans;
  	}
  	// 从index出发，最后有边界是end+1，arr[index...end]
  	public static void process4(int[] arr, int index, int sum, int end, int m, TreeSet<Integer> sortSet) {
  		if (index == end + 1) {
  			sortSet.add(sum % m);
  		} else {
  			process4(arr, index + 1, sum, end, m, sortSet);
  			process4(arr, index + 1, sum + arr[index], end, m, sortSet);
  		}
  	}</code>  </pre>
  </details>

### SnacksWays

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class39/Code02_SnacksWays.java">测试链接</a>

- 内容：

  > 牛牛家里一共有n袋零食,第i袋零食体积为v们，背包容量为w。
  >
  > 牛牛想知道在总体积不超过背包容量的情况下，一共有多少种零食放法，体积为0也算一种放法
  >
  > 1 <= n <= 30,1 <= w<= 2* 10^9，v[i] (0<= v[i]<= 10^9)。

- 思路：

  > **思路一：递归，从左到右的模型**
  >
  > **思路二：动态规划：i是第几号零食，j是0~i号零食自由选择，不重复<=w，凑够j体积的零食的种类**
  >
  > ​	转移方程
  >
  > ​		1、当前i不使用，则dp[i,j] += dp[i-1,j]
  >
  > ​		2、当前i使用，则dp[i,j] += dp[i-1,j-arr[i]]  
  >
  > **思路三：动态规划：i是第几号零食，j是占用的体积，dp[i,j]是0~i号零食<=Sum(v[i])，自由选择，占用j容量的种类**
  >
  > ​	转移方程
  >
  > ​		1、当前i不使用，则dp[i,j] += dp[i-1,j]
  >
  > ​		2、当前i使用，则dp[i,j] += dp[i-1,j-arr[i]]  
  >
  > 但是w和sum(v)的值都很大，容易超出O(10^8)
  >
  > **思路四：分治**
  >
  > ans = 0
  >
  > 求出每一半的体积及其种类数 ans += v1[i,1] + v2[i,1]
  >
  > 以其中一个为基，求<=w.-v1[i,0] 的值 ans += h(v2[i,1]) （前缀和）

- 代码：

  <details>
  <summary>暴力方法</summary>
  <p> - 放法总数</p>
  <pre><code>public static int ways1(int[] arr, int w) {
  		// arr[0...]
  		return process(arr, 0, w);
  	}
  	// 从左往右的经典模型
  	// 还剩的容量是rest，arr[index...]自由选择，
  	// 返回选择方案
  	// index ： 0～N
  	// rest : 0~w
  	public static int process(int[] arr, int index, int rest) {
  		if (rest < 0) { // 没有容量了
  			// -1 无方案的意思
  			return -1;
  		}
  		// rest>=0,
  		if (index == arr.length) { // 无零食可选
  			return 1;
  		}
  		// rest >=0
  		// 有零食index
  		// index号零食，要 or 不要
  		// index, rest
  		// (index+1, rest)
  		// (index+1, rest-arr[i])
  		int next1 = process(arr, index + 1, rest); // 不要
  		int next2 = process(arr, index + 1, rest - arr[index]); // 要
  		return next1 + (next2 == -1 ? 0 : next2);
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp 体积</summary>
  <p> - 放法总数</p>
  <pre><code>public static int ways2(int[] arr, int w) {
  		int N = arr.length;
  		int[][] dp = new int[N + 1][w + 1];
  		for (int j = 0; j <= w; j++) {
  			dp[N][j] = 1;
  		}
  		for (int i = N - 1; i >= 0; i--) {
  			for (int j = 0; j <= w; j++) {
  				dp[i][j] = dp[i + 1][j] + ((j - arr[i] >= 0) ? dp[i + 1][j - arr[i]] : 0);
  			}
  		}
  		return dp[0][w];
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp 容量总类</summary>
  <p> - 放法总数</p>
  <pre><code>public static int ways3(int[] arr, int w) {
  		int N = arr.length;
  		int[][] dp = new int[N][w + 1];
  		for (int i = 0; i < N; i++) {
  			dp[i][0] = 1;
  		}
  		if (arr[0] <= w) {
  			dp[0][arr[0]] = 1;
  		}
  		for (int i = 1; i < N; i++) {
  			for (int j = 1; j <= w; j++) {
  				dp[i][j] = dp[i - 1][j] + ((j - arr[i]) >= 0 ? dp[i - 1][j - arr[i]] : 0);
  			}
  		}
  		int ans = 0;
  		for (int j = 0; j <= w; j++) {
  			ans += dp[N - 1][j];
  		}
  		return ans;
  	}</code>  </pre>
  </details>

  <details>
  <summary>分治</summary>
  <p> - 放法总数</p>
  <pre><code>// 分治
  		public static long ways(int[] arr, int bag) {
  		if (arr == null || arr.length == 0) {
  			return 0;
  		}
  		if (arr.length == 1) {
  			return arr[0] <= bag ? 2 : 1;
  		}
  		int mid = (arr.length - 1) >> 1;
  		TreeMap<Long, Long> lmap = new TreeMap<>();
  		long ways = process(arr, 0, 0, mid, bag, lmap);
  		TreeMap<Long, Long> rmap = new TreeMap<>();
  		ways += process(arr, mid + 1, 0, arr.length - 1, bag, rmap);
  		TreeMap<Long, Long> rpre = new TreeMap<>();
  		long pre = 0;
  		for (Entry<Long, Long> entry : rmap.entrySet()) {
  			pre += entry.getValue();
  			rpre.put(entry.getKey(), pre);
  		}
  		for (Entry<Long, Long> entry : lmap.entrySet()) {
  			long lweight = entry.getKey();
  			long lways = entry.getValue();
  			Long floor = rpre.floorKey(bag - lweight);
  			if (floor != null) {
  				long rways = rpre.get(floor);
  				ways += lways * rways;
  			}
  		}
  		return ways + 1;
  	}
  	// arr 30
  	// func(arr, 0, 14, 0, bag, map)
  	// func(arr, 15, 29, 0, bag, map)
  	// 从index出发，到end结束
  	// 之前的选择，已经形成的累加和sum
  	// 零食[index....end]自由选择，出来的所有累加和，不能超过bag，每一种累加和对应的方法数，填在map里
  	// 最后不能什么货都没选
  	// [3,3,3,3] bag = 6
  	// 0 1 2 3
  	// - - - - 0 -> （0 : 1）
  	// - - - $ 3 -> （0 : 1）(3, 1)
  	// - - $ - 3 -> （0 : 1）(3, 2)
  	public static long func(int[] arr, int index, int end, long sum, long bag, TreeMap<Long, Long> map) {
  		if (sum > bag) {
  			return 0;
  		}
  		// sum <= bag
  		if (index > end) { // 所有商品自由选择完了！
  			// sum
  			if (sum != 0) {
  				if (!map.containsKey(sum)) {
  					map.put(sum, 1L);
  				} else {
  					map.put(sum, map.get(sum) + 1);
  				}
  				return 1;
  			} else {
  				return 0;
  			}
  		}
  		// sum <= bag 并且 index <= end(还有货)
  		// 1) 不要当前index位置的货
  		long ways = func(arr, index + 1, end, sum, bag, map);
  		// 2) 要当前index位置的货
  		ways += func(arr, index + 1, end, sum + arr[index], bag, map);
  		return ways;
  	}
  	public static long process(int[] arr, int index, long w, int end, int bag, TreeMap<Long, Long> map) {
  		if (w > bag) {
  			return 0;
  		}
  		if (index > end) {
  			if (w != 0) {
  				if (!map.containsKey(w)) {
  					map.put(w, 1L);
  				} else {
  					map.put(w, map.get(w) + 1);
  				}
  				return 1;
  			} else {
  				return 0;
  			}
  		} else {
  			long ways = process(arr, index + 1, w, end, bag, map);
  			ways += process(arr, index + 1, w + arr[index], end, bag, map);
  			return ways;
  		}
  	}</code>  </pre>
  </details>

### Catalan

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class39/Code04_DifferentBTNum.java">测试链接</a>

- 内容：

  > 卡特兰数又称卡塔兰数，英文名Catalan number，是组合数学中一个常出现在各种计数问题中出现的数列。其前几项为︰
  > 1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190,6564120420,24466267020,91482563640,343059613650,1289904147324，4861946401452，...
  >
  > k(0)= 1,k(1)= 1时，如果接下来的项满足︰
  > 	**k(n)= k(0) * k(n - 1)+ k(1)*k(n - 2)+ ...+ k(n - 2) * k(1)+ k(n - 1)* k(0)**
  >
  > 或者:**k(n)= c(2n, n) - c(2n, n-1)**
  >
  > 或者: **k(n)= c(2n, n)/ (n + 1)**
  >
  > 就说这个表达式，满足卡特兰数，常用的是范式1和2，3几乎不会使用到

- 符合卡特兰数的问题

  > **一共有n对()**,有2n个格子，每个格子放一个'('或者')',一共有多少种合法的放法，"((()))"合法，")(()))"不合法**一共有k(n)个合法的放法**
  >
  > **长度为n的数字任意进栈或出栈，一共有k(n)个合法的出栈序列**
  >
  > **股票开始为0，后以45度向左上涨，或以45度向右下降，升降各n次，求不会降到0以下的方法数（中途也不能降到0以下），也是卡特兰数**
  >
  > **一共有n个节点，问有多少种组成二叉树的方式？也是卡特兰数k(n) ,公式一**
