# 根据对数器找规律、根据数据量猜解法

## 基本内容

- 对数器找规律

  > 根据对数器找规律，一般都是一个输出值对应一个输入值。
  >
  > 我们只需要改变输入就能得到输出
  >
  > 一般流程
  >
  > - 先写一个暴力但正确的方法，打印其1-200之后的值与其对应结果
  > - 观察对数器的结果及其规律，写一个简易的但与暴力方法结果一致的算法
  
- 根据数据量猜解法

  > 所有的数据量在10^8次方左右，我们认为这个算法是可以过的。

## 问题集合

### AppleMinBag

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class38/Code01_AppleMinBags.java">测试链接</a>

- 内容：

  > 小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量。
  >
  > 1)能装下6个苹果的袋子
  >
  > 2)能装下8个苹果的袋子
  >
  > 小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满。
  >
  > 给定一个正整数N，返回至少使用多少袋子。
  >
  > 如果N无法让使用的每个袋子必须装满,返回-1
  
- 思路：

  > 思路一：暴力方法
  >
  > 思路二：解法尝试
  >
  > 根据结果，我们不难发现奇数全为-1
  >
  > 偶数从18开始向下对8进行取整为其结果
  
- 代码：

  <details>
  <summary>暴力方法</summary>
  <p> - 至少使用的袋子数量</p>
  <pre><code>	public static int minBags(int apple) {
  		if (apple < 0) {
  			return -1;
  		}
  		int bag8 = (apple >> 3);
  		int rest = apple - (bag8 << 3);
  		while(bag8 >= 0) {
  			// rest 个
  			if(rest % 6 ==0) {
  				return bag8 + (rest / 6);
  			} else {
  				bag8--;
  				rest += 8;
  			}
  		}
  		return -1;
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>解法尝试</summary>
  <p> - 至少需要的袋子数量</p>
  <pre><code>	public static int minBagAwesome(int apple) {
  		if ((apple & 1) != 0) { // 如果是奇数，返回-1
  			return -1;
  		}
  		if (apple < 18) {
  			return apple == 0 ? 0 : (apple == 6 || apple == 8) ? 1
  					: (apple == 12 || apple == 14 || apple == 16) ? 2 : -1;
  		}
  		return (apple - 18) / 8 + 3;
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>暴力尝试打印的结果</summary>
  <p> - 根据内容猜解法</p>
  <pre><code>1 : -1
  2 : -1
  3 : -1
  4 : -1
  5 : -1
  6 : 1
  7 : -1
  8 : 1
  9 : -1
  10 : -1
  11 : -1
  12 : 2
  13 : -1
  14 : 2
  15 : -1
  16 : 2
  17 : -1
  18 : 3
  19 : -1
  20 : 3
  21 : -1
  22 : 3
  23 : -1
  24 : 3
  25 : -1
  26 : 4
  27 : -1
  28 : 4
  29 : -1
  30 : 4
  31 : -1
  32 : 4
  33 : -1
  34 : 5
  35 : -1
  36 : 5
  37 : -1
  38 : 5
  39 : -1
  40 : 5
  41 : -1
  42 : 6
  43 : -1
  44 : 6
  45 : -1
  46 : 6
  47 : -1
  48 : 6
  49 : -1
  50 : 7
  51 : -1
  52 : 7
  53 : -1
  54 : 7
  55 : -1
  56 : 7
  57 : -1
  58 : 8
  59 : -1
  60 : 8
  61 : -1
  62 : 8
  63 : -1
  64 : 8
  65 : -1
  66 : 9
  67 : -1
  68 : 9
  69 : -1
  70 : 9
  71 : -1
  72 : 9
  73 : -1
  74 : 10
  75 : -1
  76 : 10
  77 : -1
  78 : 10
  79 : -1
  80 : 10
  81 : -1
  82 : 11
  83 : -1
  84 : 11
  85 : -1
  86 : 11
  87 : -1
  88 : 11
  89 : -1
  90 : 12
  91 : -1
  92 : 12
  93 : -1
  94 : 12
  95 : -1
  96 : 12
  97 : -1
  98 : 13
  99 : -1
  100 : 13
  101 : -1
  102 : 13
  103 : -1
  104 : 13
  105 : -1
  106 : 14
  107 : -1
  108 : 14
  109 : -1
  110 : 14
  111 : -1
  112 : 14
  113 : -1
  114 : 15
  115 : -1
  116 : 15
  117 : -1
  118 : 15
  119 : -1
  120 : 15
  121 : -1
  122 : 16
  123 : -1
  124 : 16
  125 : -1
  126 : 16
  127 : -1
  128 : 16
  129 : -1
  130 : 17
  131 : -1
  132 : 17
  133 : -1
  134 : 17
  135 : -1
  136 : 17
  137 : -1
  138 : 18
  139 : -1
  140 : 18
  141 : -1
  142 : 18
  143 : -1
  144 : 18
  145 : -1
  146 : 19
  147 : -1
  148 : 19
  149 : -1
  150 : 19
  151 : -1
  152 : 19
  153 : -1
  154 : 20
  155 : -1
  156 : 20
  157 : -1
  158 : 20
  159 : -1
  160 : 20
  161 : -1
  162 : 21
  163 : -1
  164 : 21
  165 : -1
  166 : 21
  167 : -1
  168 : 21
  169 : -1
  170 : 22
  171 : -1
  172 : 22
  173 : -1
  174 : 22
  175 : -1
  176 : 22
  177 : -1
  178 : 23
  179 : -1
  180 : 23
  181 : -1
  182 : 23
  183 : -1
  184 : 23
  185 : -1
  186 : 24
  187 : -1
  188 : 24
  189 : -1
  190 : 24
  191 : -1
  192 : 24
  193 : -1
  194 : 25
  195 : -1
  196 : 25
  197 : -1
  198 : 25
  199 : -1</code>  </pre>
  </details>

### EatGrass

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class38/Code02_EatGrass.java">测试链接</a>

- 内容：

  > 给定一个正整数N，表示有N份青草统一堆放在仓库里
  >
  > 有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草
  >
  > 不管是牛还是羊，每一轮能吃的草量必须是︰1，4，16,64…(4的某次方)
  >
  > 谁最先把草吃完，谁获胜
  >
  > 假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定根据唯一的参数N,返回谁会赢

- 思路：

  > 思路一：暴力方法
  >
  > 思路二：解法尝试
  >
  > 根据结果，我们不难发现所有的数字满足以下规律
  >
  > num % 5 == 0 || num % 5 == 2 ? "后手" : " 先手"

- 代码：

  <details>
  <summary>暴力方法</summary>
  <p> - 返回谁会赢</p>
  <pre><code>	// 如果n份草，最终先手赢，返回"先手"
  	// 如果n份草，最终后手赢，返回"后手"
  	public static String whoWin(int n) {
  		if (n < 5) {
  			return n == 0 || n == 2 ? "后手" : "先手";
  		}
  		// 进到这个过程里来，当前的先手，先选
  		int want = 1;
  		while (want <= n) {
  			if (whoWin(n - want).equals("后手")) {
  				return "先手";
  			}
  			if (want <= (n / 4)) {
  				want *= 4;
  			} else {
  				break;
  			}
  		}
  		return "后手";
  	}</code>  </pre>
  </details>

  <details>
  <summary>解法尝试</summary>
  <p> - 返回谁会赢</p>
  <pre><code>	public static String winner2(int n) {
  		if (n % 5 == 0 || n % 5 == 2) {
  			return "后手";
  		} else {
  			return "先手";
  		}
  	}</code>  </pre>
  </details>

  <details>
  <summary>暴力尝试打印的结果</summary>
  <p> - 根据内容猜解法</p>
  <pre><code>0 : 后手
  1 : 先手
  2 : 后手
  3 : 先手
  4 : 先手
  5 : 后手
  6 : 先手
  7 : 后手
  8 : 先手
  9 : 先手
  10 : 后手
  11 : 先手
  12 : 后手
  13 : 先手
  14 : 先手
  15 : 后手
  16 : 先手
  17 : 后手
  18 : 先手
  19 : 先手
  20 : 后手
  21 : 先手
  22 : 后手
  23 : 先手
  24 : 先手
  25 : 后手
  26 : 先手
  27 : 后手
  28 : 先手
  29 : 先手
  30 : 后手
  31 : 先手
  32 : 后手
  33 : 先手
  34 : 先手
  35 : 后手
  36 : 先手
  37 : 后手
  38 : 先手
  39 : 先手
  40 : 后手
  41 : 先手
  42 : 后手
  43 : 先手
  44 : 先手
  45 : 后手
  46 : 先手
  47 : 后手
  48 : 先手
  49 : 先手
  50 : 后手</code>  </pre>
  </details>

### MSumToN

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class38/Code03_MSumToN.java">测试链接</a>

- 内容：

  > 定义一种数︰可以表示成若干（数量>1）连续正数和的数
  >
  > 比如:
  >
  > 5= 2+3，5就是这样的数
  >
  > 12 = 3+4+5，12就是这样的数
  >
  > 1不是这样的数，因为要求数量大于1个、连续正数和2= 1+ 1，2也不是，因为等号右边不是连续正数
  >
  > 给定一个参数N，返回是不是可以表示成若干连续正数和的数

- 思路：

  > 思路一：暴力方法
  >
  > 思路二：解法尝试
  >
  > 根据结果，我们不难发现不可表示的数字全部是2的某次方
  >
  > 2的某次方的规律是在32位bit上，有且只有一个1

- 代码：

  <details>
  <summary>暴力方法</summary>
  <p> - 是否可表示</p>
  <pre><code>public static boolean isMSum1(int num) {
  		for (int start = 1; start <= num; start++) {
  			int sum = start;
  			for (int j = start + 1; j <= num; j++) {
  				if (sum + j > num) {
  					break;
  				}
  				if (sum + j == num) {
  					return true;
  				}
  				sum += j;
  			}
  		}
  		return false;
  	}</code>  </pre>
  </details>

  <details>
  <summary>解法尝试</summary>
  <p> - 是否可表示</p>
  <pre><code>public static boolean isMSum2(int num) {
  //		return num == (num & (~num + 1));
  //		return num == (num & (-num));
  		return (num & (num - 1)) != 0;
  	}</code>  </pre>
  </details>

  <details>
  <summary>暴力尝试打印的结果</summary>
  <p> - 根据内容猜解法</p>
  <pre><code>1 : false
  2 : false
  3 : true
  4 : false
  5 : true
  6 : true
  7 : true
  8 : false
  9 : true
  10 : true
  11 : true
  12 : true
  13 : true
  14 : true
  15 : true
  16 : false
  17 : true
  18 : true
  19 : true
  20 : true
  21 : true
  22 : true
  23 : true
  24 : true
  25 : true
  26 : true
  27 : true
  28 : true
  29 : true
  30 : true
  31 : true
  32 : false
  33 : true
  34 : true
  35 : true
  36 : true
  37 : true
  38 : true
  39 : true
  40 : true
  41 : true
  42 : true
  43 : true
  44 : true
  45 : true
  46 : true
  47 : true
  48 : true
  49 : true
  50 : true
  51 : true
  52 : true
  53 : true
  54 : true
  55 : true
  56 : true
  57 : true
  58 : true
  59 : true
  60 : true
  61 : true
  62 : true
  63 : true
  64 : false
  65 : true
  66 : true
  67 : true
  68 : true
  69 : true
  70 : true
  71 : true
  72 : true
  73 : true
  74 : true
  75 : true
  76 : true
  77 : true
  78 : true
  79 : true
  80 : true
  81 : true
  82 : true
  83 : true
  84 : true
  85 : true
  86 : true
  87 : true
  88 : true
  89 : true
  90 : true
  91 : true
  92 : true
  93 : true
  94 : true
  95 : true
  96 : true
  97 : true
  98 : true
  99 : true
  100 : true
  101 : true
  102 : true
  103 : true
  104 : true
  105 : true
  106 : true
  107 : true
  108 : true
  109 : true
  110 : true
  111 : true
  112 : true
  113 : true
  114 : true
  115 : true
  116 : true
  117 : true
  118 : true
  119 : true
  120 : true
  121 : true
  122 : true
  123 : true
  124 : true
  125 : true
  126 : true
  127 : true
  128 : false
  129 : true
  130 : true
  131 : true
  132 : true
  133 : true
  134 : true
  135 : true
  136 : true
  137 : true
  138 : true
  139 : true
  140 : true
  141 : true
  142 : true
  143 : true
  144 : true
  145 : true
  146 : true
  147 : true
  148 : true
  149 : true
  150 : true
  151 : true
  152 : true
  153 : true
  154 : true
  155 : true
  156 : true
  157 : true
  158 : true
  159 : true
  160 : true
  161 : true
  162 : true
  163 : true
  164 : true
  165 : true
  166 : true
  167 : true
  168 : true
  169 : true
  170 : true
  171 : true
  172 : true
  173 : true
  174 : true
  175 : true
  176 : true
  177 : true
  178 : true
  179 : true
  180 : true
  181 : true
  182 : true
  183 : true
  184 : true
  185 : true
  186 : true
  187 : true
  188 : true
  189 : true
  190 : true
  191 : true
  192 : true
  193 : true
  194 : true
  195 : true
  196 : true
  197 : true
  198 : true
  199 : true
  test begin
  test end</code>  </pre>
  </details>

### MoneyProblem

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class38/Code04_MoneyProblem.java">测试链接</a>

- 内容：

  > int[]d, d[]: i号怪兽的能力
  >
  > int[ p, p]∶ i号怪兽要求的钱
  >
  > 开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。
  >
  > 如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上
  >
  > 如果你当前的能力，大于等于i号怪兽的能力，你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。
  >
  > 返回通过所有的怪兽，需要花的最小钱数。
  >
  > **数据状态不同最优解不同**

- 思路：

  > **不同的思路对应不同的题目条件下的最优解法(要确保计算的数量级为10^8及以内)**
  >
  > 思路一：暴力递归(当怪兽数量少时)
  >
  > 思路二：暴力递归(当贿赂总量小时)
  >
  > 思路三：dp dp[i] [j] 表示 从i~n这个区间中，我们使用最少的贿赂值可以通过n(当贿赂值小时)
  >
  > 思路四：dp dp[i] [j]表示通过0~i这个区间中，我们一定要使用j这个钱数通过n(不可以为-1,可以为正数值)

- 代码：

  <details>
  <summary>暴力递归</summary>
  <p> - 最小钱数</p>
  <pre><code>	// 目前，你的能力是ability，你来到了index号怪兽的面前，如果要通过后续所有的怪兽，
  	// 请返回需要花的最少钱数
  	public static long process1(int[] d, int[] p, int ability, int index) {
  		if (index == d.length) {
  			return 0;
  		}
  		if (ability < d[index]) {
  			return p[index] + process1(d, p, ability + d[index], index + 1);
  		} else { // ability >= d[index] 可以贿赂，也可以不贿赂
  			return Math.min(
  					p[index] + process1(d, p, ability + d[index], index + 1),
  					0 + process1(d, p, ability, index + 1));
  		}
  	}
  	public static long func1(int[] d, int[] p) {
  		return process1(d, p, 0, 0);
  	}</code>  </pre>
  </details>

  <details>
  <summary>暴力递归贿赂问题小</summary>
  <p> - 最小钱数</p>
  <pre><code>	// 从0....index号怪兽，花的钱，必须严格==money
  	// 如果通过不了，返回-1
  	// 如果可以通过，返回能通过情况下的最大能力值
  	public static long process2(int[] d, int[] p, int index, int money) {
  		if (index == -1) { // 一个怪兽也没遇到呢
  			return money == 0 ? 0 : -1;
  		}
  		// index >= 0
  		// 1) 不贿赂当前index号怪兽
  		long preMaxAbility = process2(d, p, index - 1, money);
  		long p1 = -1;
  		if (preMaxAbility != -1 && preMaxAbility >= d[index]) {
  			p1 = preMaxAbility;
  		}
  		// 2) 贿赂当前的怪兽 当前的钱 p[index]
  		long preMaxAbility2 = process2(d, p, index - 1, money - p[index]);
  		long p2 = -1;
  		if (preMaxAbility2 != -1) {
  			p2 = d[index] + preMaxAbility2;
  		}
  		return Math.max(p1, p2);
  	}
  	public static int minMoney2(int[] d, int[] p) {
  		int allMoney = 0;
  		for (int i = 0; i < p.length; i++) {
  			allMoney += p[i];
  		}
  		int N = d.length;
  		for (int money = 0; money < allMoney; money++) {
  			if (process2(d, p, N - 1, money) != -1) {
  				return money;
  			}
  		}
  		return allMoney;
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp 贿赂值</summary>
  <p> - 最小钱数</p>
  <pre><code>	public static long func2(int[] d, int[] p) {
  		int sum = 0;
  		for (int num : d) {
  			sum += num;
  		}
  		long[][] dp = new long[d.length + 1][sum + 1];
  		for (int cur = d.length - 1; cur >= 0; cur--) {
  			for (int hp = 0; hp <= sum; hp++) {
  				// 如果这种情况发生，那么这个hp必然是递归过程中不会出现的状态
  				// 既然动态规划是尝试过程的优化，尝试过程碰不到的状态，不必计算
  				if (hp + d[cur] > sum) {
  					continue;
  				}
  				if (hp < d[cur]) {
  					dp[cur][hp] = p[cur] + dp[cur + 1][hp + d[cur]];
  				} else {
  					dp[cur][hp] = Math.min(p[cur] + dp[cur + 1][hp + d[cur]], dp[cur + 1][hp]);
  				}
  			}
  		}
  		return dp[0][0];
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp 使用定量钱</summary>
  <p> - 最小钱数</p>
  <pre><code>	public static long func3(int[] d, int[] p) {
  		int sum = 0;
  		for (int num : p) {
  			sum += num;
  		}
  		// dp[i][j]含义：
  		// 能经过0～i的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？
  		// 如果dp[i][j]==-1，表示经过0～i的怪兽，花钱为j是无法通过的，或者之前的钱怎么组合也得不到正好为j的钱数
  		int[][] dp = new int[d.length][sum + 1];
  		for (int i = 0; i < dp.length; i++) {
  			for (int j = 0; j <= sum; j++) {
  				dp[i][j] = -1;
  			}
  		}
  		// 经过0～i的怪兽，花钱数一定为p[0]，达到武力值d[0]的地步。其他第0行的状态一律是无效的
  		dp[0][p[0]] = d[0];
  		for (int i = 1; i < d.length; i++) {
  			for (int j = 0; j <= sum; j++) {
  				// 可能性一，为当前怪兽花钱
  				// 存在条件：
  				// j - p[i]要不越界，并且在钱数为j - p[i]时，要能通过0～i-1的怪兽，并且钱数组合是有效的。
  				if (j >= p[i] && dp[i - 1][j - p[i]] != -1) {
  					dp[i][j] = dp[i - 1][j - p[i]] + d[i];
  				}
  				// 可能性二，不为当前怪兽花钱
  				// 存在条件：
  				// 0~i-1怪兽在花钱为j的情况下，能保证通过当前i位置的怪兽
  				if (dp[i - 1][j] >= d[i]) {
  					// 两种可能性中，选武力值最大的
  					dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);
  				}
  			}
  		}
  		int ans = 0;
  		// dp表最后一行上，dp[N-1][j]代表：
  		// 能经过0～N-1的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？
  		// 那么最后一行上，最左侧的不为-1的列数(j)，就是答案
  		for (int j = 0; j <= sum; j++) {
  			if (dp[d.length - 1][j] != -1) {
  				ans = j;
  				break;
  			}
  		}
  		return ans;
  	}</code>  </pre>
  </details>
