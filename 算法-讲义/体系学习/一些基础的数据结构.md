# 一些基础的数据结构

## 常见数据结构

- 单链表

  > 单向链表
  > 单向链表节点结构（可以实现成范型)
  > public class Node {
  > 	public T value;
  >
  > ​	public Node next;
  >
  > ​	public Node(T data) {
  > ​		value = data;
  > ​	}
  > }

- 双链表

  > 双向链表
  > 双向链表节点结构（可以实现成范型)
  > public class Node {
  > 	public T value;
  >
  > ​	public Node next;
  >
  > ​	public Node pre;
  >
  > ​	public Node(T data) {
  > ​		value = data;
  > ​	}
  > }

- 单向链表和双向链表最简单的练习

  > 链表相关的问题几乎都是coding
  >
  > 问题1）单链表和双链表如何反转
  >
  > 问题2）把给定值都删除
  >
  > 这里就是熟悉结构。
  >
  > 链表还有哪些常见面试题，后续有专门一节来系统学习。

- 栈

  > 逻辑概念：数据先进后出，犹如弹匣

- 队列

  > 逻辑概念：数据先进先出，好似排队

- 栈与队列的实现

  > 1. 双向链表实现
  > 2. 数组实现

- 既然语言都有这些结构和api，为什么还需要手擅练习?

  > 1）算法问题无关语言
  >
  > 2）语言提供的api是有限的， 当有新的功能是api不提供的，就需要改写
  >
  > 3）任何软件工具的底层都是最基本的算法和数据结构，这是绕不过去的

- 栈和队列的常见面试题

  > 怎么用数组实现不超过固定大小的队列和栈?
  >
  > 1. 栈︰正常使用
  > 2. 队列∶环形数组
  >
  > 实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能
  >
  > 1) pop、push、getMin操作的时间复杂度都是O(1)。
  >
  > 2) 设计的栈类型可以使用现成的栈结构。
  >
  >如何用栈结构实现队列结构
如何用队列结构实现栈结构

- 递归的脑图和实际实现

  > 对于新手来说，把调用的过程画出结构图是必须的，这有利于分析递归
  >
  > 递归并不是玄学，递归底层是利用系统栈来实现的
  >
  > 任何递归函数都一定可以改成非递归

- Master公式

  > 形如T(N) = a * T(N/b)+O(N ^ d)(其中的a、b、d都是常数)的递归函数，可以直接通过Master公式来确定时间复杂度
  >
  > 如果log(b,a) < d，复杂度为O(N ^ d)
  >
  > 如果log(b,a) > d，复杂度为O(N ^ log(b,a))
  >
  > 如果log(b,a) == d，复杂度为O(N ^ d * logN)

## 问题集合

### ReverseSingleNode

- 链接：<a href="https://leetcode.cn/problems/reverse-linked-list/description/">单链表反转</a>

- 内容：

  > 反转单链表
  >

- 思路：

  > 链表反转简单理解为将原链表的头节点剥离，并使用头插法添加到新链表中

  ![链表反转](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class03/reverseSingleList.png)

- 代码：

  <details>
  <summary>链表反转代码</summary>
  <p> - 反转单链表</p>
  <pre><code> 	    public SingleNode reverseList(SingleNode head) {
          SingleNode newHead = new SingleNode();
          SingleNode p = head,next = null;
          while (p != null) {
              SingleNode cur = p;
              next = p.next;
              p.next = null;
              cur.next = newHead.next;
              newHead.next = cur;
              p = next;
          }
          return newHead.next;
      }  </code>  </pre>
  </details>

### ReverseDoubleNode

- 链接：暂无

- 内容：

  > 反转双链表

- 思路：

  > 双链表反转与单链表反转思路一致，都可以简单理解为将原链表的头节点剥离，并使用头插法添加到新链表中

  ![双链表反转](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class03/reverseSingleList.png)

- 代码：

  <details>
  <summary>链表反转代码</summary>
  <p> - 反转双链表</p>
  <pre><code> 	    public static DoubleNode reverseList(DoubleNode head) {
          DoubleNode newHead = new DoubleNode();
          DoubleNode p = head,next;
          while (p != null) {
              DoubleNode cur = p;
              next = p.next;
              p.next = null;
              if (next != null) { // 防止到最后一个元素的下一个null，出现指针错误
                  next.pre = null;
              }
              cur.next = newHead.next;
              if (newHead.next != null) { // 防止一个元素都没有，指向null，出现指针错误
                  newHead.next.pre = cur;
              }
              newHead.next = cur;
              p = next;
          }
          return newHead.next;
      } </code>  </pre>
  </details>

### DeleteGivenValue

- 链接：<a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">移除指定元素</a>

- 内容：

  > 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
  >
  >  
  >
  > **示例 1：**
  >
  > ![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)
  >
  > ```
  > 输入：head = [1,2,6,3,4,5,6], val = 6
  > 输出：[1,2,3,4,5]
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：head = [], val = 1
  > 输出：[]
  > ```
  >
  > **示例 3：**
  >
  > ```
  > 输入：head = [7,7,7,7], val = 7
  > 输出：[]
  > ```

- 思路：

  > 思路一：遍历从头到尾，找到第一个不删除的元素，以其做头进行删除操作
  >
  > 思路二：新建一个节点，它的next为原链表的头，以它为头（天然值不等于target），删除指定节点

- 代码：

  <details>
  <summary>移除指定元素代码</summary>
  <p> - 移除target值的节点</p>
  <pre><code> 	    public SingleNode removeElements(SingleNode head, int val) {
          SingleNode newHead = new SingleNode();
          newHead.next = head;
          SingleNode p = newHead;
          while (p.next != null) {
              if(p.next.val == val){
                  p.next = p.next.next;
              }else{
                  p = p.next;
              }
          }
          return newHead.next;
      } </code>  </pre>
  </details>

### DoubleNodesToStackAndQueue

- 链接：暂无

- 内容：

  > 使用双端节点实现栈与队列
  >
  > 默认使用双链表节点

- 思路：

  > 栈：先进后出
  >
  > ​	api：isEmpty,push,pop,peek,size
  >
  > 队列：先进先出
  >
  > ​	api：isEmpty,push,pull,peek,size

- 代码：

  <details>
  <summary>实现栈的代码</summary>
  <p> - 实现栈的api</p>
  <pre><code> 	    static class MyStack {
          DoubleNode head = null, tail = null;
          int size;
          public MyStack() {
              size = 0;
          }
          public void push(int data) {
              if (head == null) {
                  head = new DoubleNode(data);
                  tail = head;
              } else {
                  DoubleNode cur = new DoubleNode(data);
                  cur.next = head.next;
                  cur.pre = head;
                  head.next = cur;
              }
              size++;
          }
          public int pop() {
              size--;
              DoubleNode cur = head;
              head = head.next;
              head.pre = null;
              cur.next = null;
              return cur.value;
          }
          public int peek() {
              return head.value;
          }
          public boolean isEmpty() {
              return size == 0;
          }
          public int size() {
              return size;
          }
      }</code>  </pre>
  </details>
  <details>
  <summary>实现队列的代码</summary>
  <p> - 实现队列的api</p>
  <pre><code> 	    static class MyQueue {
          DoubleNode head = null, tail = null;
          int size;
          public MyQueue() {
              size = 0;
          }
          public void push(int data) {
              if (head == null) {
                  head = new DoubleNode(data);
                  tail = head;
              } else {
                  DoubleNode cur = new DoubleNode(data);
                  cur.next = head.next;
                  cur.pre = head;
                  head.next = cur;
              }
              size++;
          }
          public int poll(){
              size--;
              DoubleNode cur = tail;
              tail = tail.pre;
              tail.next = null;
              cur.pre = null;
              return cur.value;
          }
          public boolean isEmpty(){
              return size == 0;
          }
          public int peek(){
              return tail.value;
          }
          public int size(){
              return size;
          }
      }</code>  </pre>
  </details>

### RingArray

- 链接：暂无

- 内容：

  > 使用数组实现环形队列

- 思路：

  > 思路1：使用一个size记录队列的大小，用来判断队列满空的情况，默认队头与队尾一致
  >
  > 思路2：只使用数组的n-1个位置，最后一个位置用来判断队列是否满空，默认队尾=(队头+1)%n

- 代码：

  <details>
  <summary>自定义环形队列代码</summary>
  <p> - 实现环形队列的api</p>
  <pre><code> 	 public static class MyQueue {
          private int[] arr;
          private int pushi;// end
          private int polli;// begin
          private int size;
          private final int limit;
          public MyQueue(int limit){
              size = 0;
              arr = new int[limit];
              this.limit = limit;
              pushi = 0;
              polli = 0;
          }
          public void push(int value) {
              if(size == limit) {
                  throw new RuntimeException("队列已满");
              }
              arr[pushi] = value;
              pushi = nextIndex(pushi);
              size++;
          }
          public int poll() {
              if(size == 0){
                  throw new RuntimeException("队列已空");
              }
              size--;
              int pollValue = arr[polli];
              polli = nextIndex(polli);
              return pollValue;
          }
          public boolean isEmpty() {
              return size == 0;
          }
          // 如果现在的下标是i，返回下一个位置
          private int nextIndex(int i) {
              return i < limit - 1 ? i + 1: 0;
          }
      }</code>  </pre>
  </details>

### MinStack

- 链接：<a href="https://leetcode.cn/problems/min-stack/description/">最小栈</a>

- 内容：

  > 计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。
  >
  > 实现 `MinStack` 类:
  >
  > - `MinStack()` 初始化堆栈对象。
  > - `void push(int val)` 将元素val推入堆栈。
  > - `void pop()` 删除堆栈顶部的元素。
  > - `int top()` 获取堆栈顶部的元素。
  > - `int getMin()` 获取堆栈中的最小元素。
  >
  > **示例 1:**
  >
  > ```
  > 输入：
  > ["MinStack","push","push","push","getMin","pop","top","getMin"]
  > [[],[-2],[0],[-3],[],[],[],[]]
  > 
  > 输出：
  > [null,null,null,null,-3,null,0,-2]
  > 
  > 解释：
  > MinStack minStack = new MinStack();
  > minStack.push(-2);
  > minStack.push(0);
  > minStack.push(-3);
  > minStack.getMin();   --> 返回 -3.
  > minStack.pop();
  > minStack.top();      --> 返回 0.
  > minStack.getMin();   --> 返回 -2.
  > ```

- 思路：

  > 使用两个栈来完成数据的封装与查询，一个数据栈一个最小栈

- 代码：

  <details>
  <summary>最小栈实现代码</summary>
  <p> - 在对应的时间复杂度下实现最小栈的api</p>
  <pre><code> 	 static class MinStack {
          Stack<Integer> dataStack;
          Stack<Integer> minStack;
          public MinStack() {
              dataStack = new Stack<>();
              minStack = new Stack<>();
          }
          public void push(int val) {
              dataStack.push(val);
              if(!minStack.isEmpty()){
                  minStack.push(Math.min(minStack.peek(),val));
              }else{
                  minStack.push(val);
              }
          }
          public void pop() {
              dataStack.pop();
              minStack.pop();
          }
          public int top() {
              return dataStack.peek();
          }
          public int getMin() {
              return minStack.peek();
          }
      }</code>  </pre>
  </details>

### TwoStacksImplementQueue

- 链接：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">实现队列</a>

- 内容：

  > 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：
  >
  > 实现 `MyQueue` 类：
  >
  > - `void push(int x)` 将元素 x 推到队列的末尾
  > - `int pop()` 从队列的开头移除并返回元素
  > - `int peek()` 返回队列开头的元素
  > - `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`
  >
  > **说明：**
  >
  > - 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
  > - 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
  >
  > **示例 1：**
  >
  > ```
  > 输入：
  > ["MyQueue", "push", "push", "peek", "pop", "empty"]
  > [[], [1], [2], [], [], []]
  > 输出：
  > [null, null, null, 1, 1, false]
  > 
  > 解释：
  > MyQueue myQueue = new MyQueue();
  > myQueue.push(1); // queue is: [1]
  > myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
  > myQueue.peek(); // return 1
  > myQueue.pop(); // return 1, queue is [2]
  > myQueue.empty(); // return false
  > ```
  >
  > 

- 思路：

  > 使用两个栈来完成数据的进出操作，一个栈用来进，一个栈用来出。
  >
  > 当进或出时，要保证另一个栈是空。

- 代码：

  <details>
  <summary>队列实现代码</summary>
  <p> - 只使用两个栈实现队列的api</p>
  <pre><code> 	     class MyQueue {
          public Stack<Integer> stackPush;
          public Stack<Integer> stackPop;
          public MyQueue() {stackPush = new Stack<Integer>();stackPop = new Stack<Integer>();}
          // push栈向pop栈倒入数据
          private void pushToPop() {
              while (!stackPush.empty()) {
                  stackPop.push(stackPush.pop());
              }
          }
          // pop栈向push栈倒入数据
          private void popToPush() {
              while (!stackPop.empty()) {
                  stackPush.push(stackPop.pop());
              }
          }
          public void push(int pushInt) {
              popToPush();
              stackPush.push(pushInt);
          }
          public int pop() {
              if (stackPop.empty() && stackPush.empty()) {
                  throw new RuntimeException("Queue is empty!");
              }
              pushToPop();
              return stackPop.pop();
          }
          public int peek() {
              if (stackPop.empty() && stackPush.empty()) {
                  throw new RuntimeException("Queue is empty!");
              }
              pushToPop();
              return stackPop.peek();
          }
          public boolean empty(){
              return stackPop.size() == 0 && stackPop.size() == 0;
          }
      }</code>  </pre>
  </details>

### TwoQueueImplementStack

- 链接：<a href="https://leetcode.cn/problems/implement-stack-using-queues/description//">实现栈</a>

- 内容：

  > 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。
  >
  > 实现 `MyStack` 类：
  >
  > - `void push(int x)` 将元素 x 压入栈顶。
  > - `int pop()` 移除并返回栈顶元素。
  > - `int top()` 返回栈顶元素。
  > - `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。
  >
  >  
  >
  > **注意：**
  >
  > - 你只能使用队列的标准操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
  > - 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
  >
  >  
  >
  > **示例：**
  >
  > ```
  > 输入：
  > ["MyStack", "push", "push", "top", "pop", "empty"]
  > [[], [1], [2], [], [], []]
  > 输出：
  > [null, null, null, 2, 2, false]
  > 
  > 解释：
  > MyStack myStack = new MyStack();
  > myStack.push(1);
  > myStack.push(2);
  > myStack.top(); // 返回 2
  > myStack.pop(); // 返回 2
  > myStack.empty(); // 返回 False
  > ```

- 思路：

  > 使用两个栈来完成数据的进出操作，一个栈用来进，一个栈用来出。
  >
  > 当进或出时，要保证另一个栈是空。

- 代码：

  <details>
  <summary>栈实现代码</summary>
  <p> - 只使用两个队列实现栈的api</p>
  <pre><code> 	static class MyStack {
          Queue<Integer> in ,out;
          public MyStack() {
              in = new LinkedList<>();
              out = new LinkedList<>();
          }
          public void push(int x) {
              in.add(x);
          }
          public int pop() {
              while (!in.isEmpty()) {
                  Integer cur = in.poll();
                  if(in.isEmpty()){
                      return cur;
                  }
                  out.add(cur);
              }
              while (!out.isEmpty()){
                  Integer cur = out.poll();
                  if(out.isEmpty()){
                      return cur;
                  }
                  in.add(cur);
              }
              return -1;
          }
          public int top() {
              while (!in.isEmpty()) {
                  Integer cur = in.poll();
                  out.add(cur);
                  if(in.isEmpty()){
                      return cur;
                  }
              }
              while (!out.isEmpty()){
                  Integer cur = out.poll();
                  in.add(cur);
                  if(out.isEmpty()){
                      return cur;
                  }
              }
              return -1;
          }
          public boolean empty() {
              return in.isEmpty() && out.isEmpty();
          }
      };</code>  </pre>
  </details>

### GetMax

- 链接：暂无

- 内容：

  > 求数组中的最大值

- 思路：

  > 递归求取

- 代码：

  <details>
  <summary>求最大值代码</summary>
  <p> - 使用递归实现求取最大值功能</p>
  <pre><code> 	// 求arr中的最大值
      public static int getMax(int[] arr) {
          return process(arr, 0, arr.length - 1);
      }
      // arr[L..R]范围上求最大值  L ... R   N
      public static int process(int[] arr, int L, int R) {
          // arr[L..R]范围上只有一个数，直接返回，base case
          if (L == R) {
              return arr[L];
          }
          // L...R 不只一个数
          // mid = (L + R) / 2
          int mid = L + ((R - L) >> 1); // 中点   	1
          int leftMax = process(arr, L, mid);
          int rightMax = process(arr, mid + 1, R);
          return Math.max(leftMax, rightMax);
      }</code>  </pre>
  </details>

### Hash

- hash相关操作及其结果

  ```java
  public class HashMapAndSortedMap {
      public static class Node {
          public int value;
          public Node(int v) {
              value = v;
          }
      }
      public static class Zuo {
          public int value;
          public Zuo(int v) {
              value = v;
          }
      }
      public static void main(String[] args) {
          HashMap<Integer, String> test = new HashMap<>();
          Integer a = 19000000;
          Integer b = 19000000;
          System.out.println(a == b); // false
          test.put(a, "我是3");
          System.out.println(test.containsKey(b));// true
          Zuo z1 = new Zuo(1);
          Zuo z2 = new Zuo(1);
          HashMap<Zuo, String> test2 = new HashMap<>();
          test2.put(z1, "我是z1");
          System.out.println(test2.containsKey(z2)); // false
          // UnSortedMap
          HashMap<Integer, String> map = new HashMap<>();
          map.put(1000000, "我是1000000");
          map.put(2, "我是2");
          map.put(3, "我是3");
          map.put(4, "我是4");
          map.put(5, "我是5");
          map.put(6, "我是6");
          map.put(1000000, "我是1000001");
          System.out.println(map.containsKey(1)); // false
          System.out.println(map.containsKey(10)); // false
          System.out.println(map.get(4)); // 我是4 
          System.out.println(map.get(10)); // null
          map.put(4, "他是4");
          System.out.println(map.get(4)); //他是4
          map.remove(4);
          System.out.println(map.get(4)); // null
          // key
          HashSet<String> set = new HashSet<>();
          set.add("abc");
          set.contains("abc");
          set.remove("abc");
          // 哈希表，增、删、改、查，在使用时，O（1）
          System.out.println("====================="); // =====================
          Integer c = 100000;
          Integer d = 100000;
          System.out.println(c.equals(d)); // true
          Integer e = 127; // - 128 ~ 127
          Integer f = 127;
          System.out.println(e == f); //true
          HashMap<Node, String> map2 = new HashMap<>();
          Node node1 = new Node(1);
          Node node2 = node1;
          map2.put(node1, "我是node1");
          map2.put(node2, "我是node1");
          System.out.println(map2.size()); // 1
          System.out.println("======================"); // ======================
          // TreeMap 有序表：接口名
          // 红黑树、avl、sb树、跳表
          // O(logN)
          System.out.println("有序表测试开始"); // 有序表测试开始
          TreeMap<Integer, String> treeMap = new TreeMap<>();
          treeMap.put(3, "我是3");
          treeMap.put(4, "我是4");
          treeMap.put(8, "我是8");
          treeMap.put(5, "我是5");
          treeMap.put(7, "我是7");
          treeMap.put(1, "我是1");
          treeMap.put(2, "我是2");
          System.out.println(treeMap.containsKey(1)); // true
          System.out.println(treeMap.containsKey(10));// false
          System.out.println(treeMap.get(4)); // 我是4
          System.out.println(treeMap.get(10)); // null
          treeMap.put(4, "他是4");
          System.out.println(treeMap.get(4)); // 他是4
          // treeMap.remove(4);
          System.out.println(treeMap.get(4)); // 他是4
          System.out.println("新鲜："); // 新鲜：
          System.out.println(treeMap.firstKey()); // 1
          System.out.println(treeMap.lastKey()); // 8
          // <= 4
          System.out.println(treeMap.floorKey(4)); // 4
          // >= 4
          System.out.println(treeMap.ceilingKey(4)); // 4
          // O(logN)
      }
  }
  ```

  
