# 前缀树，不基于比较的排序，稳定性

## 基本内容

- 前缀树

  > `前缀树`是`N叉树`的一种特殊形式。通常来说，一个前缀树是用来`存储字符串`的。前缀树的每一个节点代表一个`字符串`（`前缀`）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的`原始字符串`，以及`通往该子节点路径上所有的字符`组成的。

- 不基于比较的排序

  >  计数排序，桶排序，基数排序
  >
  >  不基于比较的排序对数据都有一定的要求

- 稳定性

  > 通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。
  >
  > 稳定性是指同样大小的样本再排序之后不会改变相对次序
  >
  > 对基础类型来说，稳定性毫无意义
  >
  > 对非基础类型来说，稳定性有重要意义
  >
  > 有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的
- 总结
  > | 排序方法     | 时间复杂度 | 额外空间复杂度 | 稳定性 |
  > | ------------ | ---------- | -------------- | ------ |
  > | 选择排序     | O(N^2)     | O(1)           | 无     |
  > | 冒泡排序     | O(N^2)     | O(1)           | 有     |
  > | 插入排序     | O(N^2)     | O(1)           | 有     |
  > | 归并排序     | O(NlogN)   | O(N)           | 有     |
  > | 随机快排     | O(NlogN)   | O(NlogN)       | 无     |
  > | 堆排序       | O(NlogN)   | O(1)           | 无     |
  > | 计数排序     | O(N)       | O(M)           | 有     |
  > | 基数排序(桶) | O(N)       | O(N)           | 有     |
  >
  > 1）不基于比较的排序，对样本数据有严格要求，不易改写
  >
  > 2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
  >
  > 3）基于比较的排序，时间复杂度的极限是O(N*logN)*
  >
  > 4）时间复杂度O(NlogN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的。
  >
  > 5）为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并

## 问题集合

### Trie

- 链接：<a href="https://leetcode.cn/problems/implement-trie-ii-prefix-tree/">测试链接</a>

- 内容：

  > 实现一个前缀树

- 思路：

  > 路径为字符值，节点记录经过的值与以此节点结束的值

- 代码：

  <details>
  <summary>数组实现前缀树代码</summary>
  <p> - trie实现</p>
  <pre><code>class Trie { // 前缀树-所有的字符串数据放入路径中
          class Node { // 节点
              public int pass; // 通过此路径的数量
              public int end; // 以此节点结束的数量
              public Node[] nexts; // 路径值
              public Node() { // 初始化
                  pass = 0;
                  end = 0;
                  nexts = new Node[26];
              }
          }
          private Node root;
          public Trie() {
              root = new Node();
          }
          public void insert(String word) {
              if(word == null) return;
              char[] chars = word.toCharArray();
              Node p = root;
              p.pass++;
              int index;
              for (char cur : chars) {
                  index = cur - 'a';
                  if(p.nexts[index] == null){
                      p.nexts[index] = new Node();
                  }
                  p = p.nexts[index];
                  p.pass++;
              }
              p.end++;
          }
          public void erase(String word) {
              if(countWordsStartingWith(word) != 0){
                  char[] chars = word.toCharArray();
                  Node node = root;
                  node.pass--;
                  int index;
                  for (char cur : chars) {
                      index = cur - 'a';
                      if(--node.nexts[index].pass == 0){
                          node.nexts[index] = null;
                          return;
                      }
                      node = node.nexts[index];
                  }
                  node.end--;
              }
          }
          public int countWordsEqualTo(String word) {
              if(word == null) return 0;
              char[] chars = word.toCharArray();
              Node node = root;
              int index;
              for (char cur : chars) {
                  index = cur - 'a';
                  if(node.nexts[index] == null){
                      return 0;
                  }
                  node = node.nexts[index];
              }
              return node.end;
          }
          public int countWordsStartingWith(String pre) {
              if(pre == null) return 0;
              char[] chars = pre.toCharArray();
              Node node = root;
              int index;
              for (char cur : chars) {
                  index = cur - 'a';
                  if(node.nexts[index] == null){
                      return 0;
                  }
                  node = node.nexts[index];
              }
              return node.pass;
          }
      }</code>  </pre>
  </details>
  <details>
  <summary>map实现前缀树代码</summary>
  <p> - trie实现</p>
  <pre><code>	class Trie {
  		class Node {
  			public int pass;
  			public int end;
  			public HashMap<Integer, Node> nexts;
  			public Node() {
  				pass = 0;
  				end = 0;
  				nexts = new HashMap<>();
  			}
  		}
  		private Node root;
  		public Trie() {
  			root = new Node();
  		}
  		public void insert(String word) {
  			if (word == null) {
  				return;
  			}
  			char[] chs = word.toCharArray();
  			Node node = root;
  			node.pass++;
  			int index = 0;
  			for (int i = 0; i < chs.length; i++) {
  				index = (int) chs[i];
  				if (!node.nexts.containsKey(index)) {
  					node.nexts.put(index, new Node());
  				}
  				node = node.nexts.get(index);
  				node.pass++;
  			}
  			node.end++;
  		}
  		public void erase(String word) {
  			if (countWordsEqualTo(word) != 0) {
  				char[] chs = word.toCharArray();
  				Node node = root;
  				node.pass--;
  				int index = 0;
  				for (int i = 0; i < chs.length; i++) {
  					index = (int) chs[i];
  					if (--node.nexts.get(index).pass == 0) {
  						node.nexts.remove(index);
  						return;
  					}
  					node = node.nexts.get(index);
  				}
  				node.end--;
  			}
  		}
  		public int countWordsEqualTo(String word) {
  			if (word == null) {
  				return 0;
  			}
  			char[] chs = word.toCharArray();
  			Node node = root;
  			int index = 0;
  			for (int i = 0; i < chs.length; i++) {
  				index = (int) chs[i];
  				if (!node.nexts.containsKey(index)) {
  					return 0;
  				}
  				node = node.nexts.get(index);
  			}
  			return node.end;
  		}
  		public int countWordsStartingWith(String pre) {
  			if (pre == null) {
  				return 0;
  			}
  			char[] chs = pre.toCharArray();
  			Node node = root;
  			int index = 0;
  			for (int i = 0; i < chs.length; i++) {
  				index = (int) chs[i];
  				if (!node.nexts.containsKey(index)) {
  					return 0;
  				}
  				node = node.nexts.get(index);
  			}
  			return node.pass;
  		}
  	}</code>  </pre>
  </details>

### CountSort

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class08/Code03_CountSort.java">测试链接</a>

- 内容：

  > 计数排序 0~200

- 思路：

  > 记录0~200每个数字出现的次数，再放回原数组中

- 代码：

  <details>
  <summary>计数排序代码</summary>
  <p> - 代码实现</p>
  <pre><code>public static void countSort(int[] arr) {
  		if (arr == null || arr.length < 2) {
  			return;
  		}
  		int max = Integer.MIN_VALUE;
  		for (int i = 0; i < arr.length; i++) {
  			max = Math.max(max, arr[i]);
  		}
  		int[] bucket = new int[max + 1];
  		for (int i = 0; i < arr.length; i++) {
  			bucket[arr[i]]++;
  		}
  		int i = 0;
  		for (int j = 0; j < bucket.length; j++) {
  			while (bucket[j]-- > 0) {
  				arr[i++] = j;
  			}
  		}
  	}</code>  </pre>
  </details>

### RadixSort

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class08/Code04_RadixSort.java">测试链接</a>

- 内容：

  > 桶排序 数据全为正数

- 思路：

  > 从低到高，对每一位进行入桶出桶操作，直到结束

  为什么每次出桶前都要记录一下前缀和呢？

  >使用一组数据 3 6 7 23 56 132 63
  >
  >| 第几次入桶 | 0              | 1    | 2    | 3         | 4    | 5    | 6     | 7    | 8    | 9    | 出桶顺序             |
  >| ---------- | -------------- | ---- | ---- | --------- | ---- | ---- | ----- | ---- | ---- | ---- | -------------------- |
  >| 1          |                |      | 132  | 3，23，63 |      |      | 6，56 | 7    |      |      | 132,3,23,63,6,56,7   |
  >| 2          | 3,6,7          |      | 23   | 132       |      | 56   | 63,6  |      |      |      | 3,6,7,23,132,56,63,6 |
  >| 3          | 3,6,7,23,56,63 | 132  |      |           |      |      |       |      |      |      | 3,6,7,23,56,63,132   |
  >
  >以第2次入桶为例
  >
  >**前缀和数组为 3 3 4 5 5 6 7 7 7 7**
  >
  >从后往前遍历上一次的出桶顺序 
  >
  >第一个 7 此时7的第二位为0，0号桶为3个，说明7要放在3-1的位置上 此时0号桶为2
  >
  >第二个 56 此时56的第二位为5，5号桶为6个，说明56要放在6-1的位置上 此时5号桶为6
  >
  >....
  >
  >第七个 132 此时132的第二位为3，3号桶为5个，说明132要放在5-1的位置上 此时3号桶为4
  >
  >**前缀和数组保证了数据所在准确的出桶的位置**

- 代码：

  <details>
  <summary>桶排序代码</summary>
  <p> - 代码实现</p>
  <pre><code>// only for no-negative value
      public static void radixSort(int[] arr) {
          if(arr == null || arr.length < 2) return;
          radixSort(arr,0,arr.length-1,maxBits(arr));
      }
      // 最长的位数
      public static int maxBits(int[] arr){
          int max = Integer.MIN_VALUE;
          for (int i = 0; i < arr.length; i++) {
              max = Math.max(max,arr[i]);
          }
          int bits = 0;
          while (max != 0) {
              bits++;
              max /= 10;
          }
          return bits;
      }
      // arr[L..R]排序  ,  最大值的十进制位数MaxBit
      public static void radixSort(int[] arr,int L,int R,int MaxBit){
          final int radix = 10;//10个桶
          int i = 0,j = 0;
          int[] help = new int[R - L + 1];// 记录每次出桶的顺序
          for (int d = 1; d <= MaxBit; d++) {
              int[] count = new int[radix];
              for(i = L;i <= R; i++){
                  count[getDigit(arr[i],d)]++;
              }
              // 出桶准备
              for(i = 1;i < radix;i++){
                  count[i] += count[i-1];
              }
              // 出桶
              for (i = R; i >= L; i--) { // 这里看解释
                  j = getDigit(arr[i],d);
                  help[count[j] - 1] = arr[i];
                  count[j]--;
              }
              for(i=L,j=0;i<=R;i++,j++){
                  arr[i] = help[j];
              }
          }
      }
      // value的第bit位的值
      public static int getDigit(int value,int bit){
          return ((value / (int)Math.pow(10,bit-1))) % 10;
      }</code>  </pre>
  </details>

### ShellSort

- 链接：<a href="https://leetcode.cn/problems/sort-an-array/description/">升序测试</a>

- 内容：

  > 给你一个整数数组 `nums`，请你将该数组升序排列。
  >
  > **示例 1：**
  >
  > ```
  > 输入：nums = [5,2,3,1]
  > 输出：[1,2,3,5]
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：nums = [5,1,1,2,0,0]
  > 输出：[0,0,1,1,2,5]
  > ```

- 思路：

  > 使用步长对数据进行逐一变化，核心还是插入排序

- 代码：

  <details>
  <summary>希尔排序代码</summary>
  <p> - 插入排序的优化实现</p>
  <pre><code>// 希尔排序为插入排序的优化
      public static void shellSort(int[] arr) {
          if (arr == null || arr.length < 2) {
              return;
          }
          int len = arr.length;
          int stepSize = len / 2;
          while (stepSize != 0) {
              for (int i = stepSize; i < len; i++) {
                  int value = arr[i];
                  int j;
                  for (j = i - stepSize; j >= 0 && arr[j] > value; j-=stepSize) {
                      arr[j + stepSize] = arr[j];
                  }
                  arr[j + stepSize] = value;
              }
              stepSize /= 2;
          }
      }
      public static void swap(int[] arr, int i, int j) {
          int tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
      }</code>  </pre>
  </details>