# 暴力递归到动态规划四

## 基本内容

- 暴力递归就是尝试

  > 1，把问题转化为规模缩小了的同类问题的子问题
  >
  > 2，有明确的不需要继续进行递归的条件(base case)
  >
  > 3，有当得到了子问题的结果之后的决策过程
  >
  > 4，不记录每一个子问题的解

- 动态规划

  > 动态规划（Dynamic Programming,DP）算法通常用于求解某种具有最优性质的问题。在这类问题中，可能会有许多可行解，每一个解都对应一个值，我们希望找到具有最优值的解。
  > 动态规划算法与分治法类似，其基本思想也是将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解中 得到原有问题的解。与分治法不同的是，动态规划经分解后得到的**子问题往往不是相互独立的。**

- 暴力递归与动态规划的关系

  > 递归包含了含有**重复子问题的递归**与**不含有重复子问题的递归**
  >
  > **动态规划**只与**重复子问题的递归**有关系
  >
  > **所有动态规划问题全部可以由递归实现，但只有含有重复子问题的递归才能由动态规划实现。**

- 怎么尝试—件事?

  > 1）有经验但是没有方法论?
  >
  > 2）怎么判断一个尝试就是最优尝试?
  >
  > 3）难道尝试这件事真的只能拼天赋?那我咋搞定我的面试?
  >
  > 4）动态规划是啥?好高端的样子哦…可是我不会啊!和尝试有什么关系?

- 什么暴力递归可以继续优化?

  > 有**重复调用**同一个子问题的解，这种递归可以优化
  >
  > 如果每一个子问题都是不同的解，无法优化也不用优化

- 面试题和动态规划的关系

  > 解决一个问题，可能有很多尝试方法
  >
  > 可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式
  >
  > **一个问题可能有若干种动态规划的解法**

- 如何找到某个问题的动态规划方式?

  > 1）设计暴力递归∶重要原则+4种常见尝试模型!重点!
  >
  > 2）分析有没有重复解︰套路解决
  >
  > 3）用记忆化搜索->用严格表结构实现动态规划∶套路解决
  >
  > 4）看看能否继续优化∶套路解决

- 面试中设计暴力递归过程的原则

  > 1）每一个可变参数的类型，一定不要比int类型更加复杂
  >
  > 2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数
  >
  > 3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可
  >
  > 4）可变参数的个数，能少则少

- 知道了面试中设计暴力递归过程的原则，然后呢?

  > 一定要逼自己找到不违反原则情况下的暴力尝试!
  >
  > 如果你找到的暴力尝试，不符合原则，马上舍弃!找新的!
  >
  > 如果某个题目突破了设计原则，一定极难极难，面试中出现**概率低于5%** !

- 常见的4种尝试模型

  > 1）从左往右的尝试模型
  >
  > 2）范围上的尝试模型
  >
  > 3）多样本位置全对应的尝试模型
  >
  > 4）寻找业务限制的尝试模型

- 如何分析有没有重复解

  > 列出调用过程，可以只列出前几层
  >
  > 有没有重复解，一看便知

- 暴力递归到动态规划的套路

  > 1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用
  >
  > 2）找到哪些参数的变化会影响返回值，对每一个列出变化范围
  >
  > 3）参数间的所有的组合数量，意味着表大小
  >
  > 4）记忆化搜索的方法就是傻缓存，非常容易得到
  >
  > 5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解
  >
  > 6）对于有枚举行为的决策过程，进一步优化

- 动态规划的进一步优化

  > 1）空间压缩
  >
  > 2）状态化简
  >
  > 3）四边形不等式
  >
  > 4）其他优化技巧

## 问题集合

### MinPathSum

- 链接：<a href="https://leetcode.cn/problems/minimum-path-sum/description/">测试链接</a>

- 内容：

  > 给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
  >
  > **说明：**每次只能向下或者向右移动一步。
  >
  > **示例 1：**
  >
  > ![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)
  >
  > ```
  > 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
  > 输出：7
  > 解释：因为路径 1→3→1→1→1 的总和最小。
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：grid = [[1,2,3],[4,5,6]]
  > 输出：12
  > ```

- 思路：

  > dp 二维
  >
  > dp 二维压缩为一维

- 代码：

  <details>
  <summary>dp二维</summary>
  <p> - 获取最小距离累加和</p>
  <pre><code>public static int minPathSum1(int[][] m) {
  		if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
  			return 0;
  		}
  		int row = m.length;
  		int col = m[0].length;
  		int[][] dp = new int[row][col];
  		dp[0][0] = m[0][0];
  		for (int i = 1; i < row; i++) {
  			dp[i][0] = dp[i - 1][0] + m[i][0];
  		}
  		for (int j = 1; j < col; j++) {
  			dp[0][j] = dp[0][j - 1] + m[0][j];
  		}
  		for (int i = 1; i < row; i++) {
  			for (int j = 1; j < col; j++) {
  				dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + m[i][j];
  			}
  		}
  		return dp[row - 1][col - 1];
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp一维压缩</summary>
  <p> - 获取最小距离累加和</p>
  <pre><code>public static int minPathSum2(int[][] m) {
  		if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
  			return 0;
  		}
  		int row = m.length;
  		int col = m[0].length;
  		int[] dp = new int[col];
  		dp[0] = m[0][0];
  		for (int j = 1; j < col; j++) {
  			dp[j] = dp[j - 1] + m[0][j];
  		}
  		for (int i = 1; i < row; i++) {
  			dp[0] += m[i][0];
  			for (int j = 1; j < col; j++) {
  				dp[j] = Math.min(dp[j - 1], dp[j]) + m[i][j];
  			}
  		}
  		return dp[col - 1];
  	}</code>  </pre>
  </details>

### CoinsWayEveryPaperDifferent

- 链接：<a href="https://leetcode.cn/problems/coin-change-ii/description/">测试链接</a>

- 内容：

  > arr是货币数组，其中的值都是正数。
  >
  > 再给定一个正数aim。每个值都认为是一张货币，
  >
  > 即便是值相同的货币也认为每一张都是不同的，返回组成aim的方法数
  >
  > 例如∶ arr= {1,1,1}，aim = 2
  >
  > 第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2
  >
  > 一共就3种方法，所以返回3。

- 思路：

  > 递归
  >
  > dp

- 代码：

  <details>
  <summary>递归</summary>
  <p> - 获取不同的方法数</p>
  <pre><code>	public static int coinWays(int[] arr, int aim) {
  		return process(arr, 0, aim);
  	}
  	// arr[index....] 组成正好rest这么多的钱，有几种方法
  	public static int process(int[] arr, int index, int rest) {
  		if (rest < 0) {
  			return 0;
  		}
  		if (index == arr.length) { // 没钱了！
  			return rest == 0 ? 1 : 0;
  		} else {
  			return process(arr, index + 1, rest) + process(arr, index + 1, rest - arr[index]);
  		}
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp</summary>
  <p> - 获取不同的方法数</p>
  <pre><code>public static int dp(int[] arr, int aim) {
  		if (aim == 0) {
  			return 1;
  		}
  		int N = arr.length;
  		int[][] dp = new int[N + 1][aim + 1];
  		dp[N][0] = 1;
  		for (int index = N - 1; index >= 0; index--) {
  			for (int rest = 0; rest <= aim; rest++) {
  				dp[index][rest] = dp[index + 1][rest] + (rest - arr[index] >= 0 ? dp[index + 1][rest - arr[index]] : 0);
  			}
  		}
  		return dp[0][aim];
  	}</code>  </pre>
  </details>

### CoinsWayNoLimit

- 链接：<a href="https://leetcode.cn/problems/coin-change-ii/description/">测试链接</a>

- 内容：

  > 给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。
  >
  > 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。
  >
  > 假设每一种面额的硬币有无限个。 
  >
  > 题目数据保证结果符合 32 位带符号整数。
  >
  > **示例 1：**
  >
  > ```
  > 输入：amount = 5, coins = [1, 2, 5]
  > 输出：4
  > 解释：有四种方式可以凑成总金额：
  > 5=5
  > 5=2+2+1
  > 5=2+1+1+1
  > 5=1+1+1+1+1
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：amount = 3, coins = [2]
  > 输出：0
  > 解释：只用面额 2 的硬币不能凑成总金额 3 。
  > ```
  >
  > **示例 3：**
  >
  > ```
  > 输入：amount = 10, coins = [10] 
  > 输出：1
  > ```

- 思路：

  > 递归
  >
  > dp
  >
  > dp枚举优化

- 代码：

  <details>
  <summary>递归</summary>
  <p> - 获取不同的方法数</p>
  <pre><code>	public static int coinsWay(int[] arr, int aim) {
  		if (arr == null || arr.length == 0 || aim < 0) {
  			return 0;
  		}
  		return process(arr, 0, aim);
  	}
  	// arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好rest这么多钱，方法数多少？
  	public static int process(int[] arr, int index, int rest) {
  		if (index == arr.length) { // 没钱了
  			return rest == 0 ? 1 : 0;
  		}
  		int ways = 0;
  		for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
  			ways += process(arr, index + 1, rest - (zhang * arr[index]));
  		}
  		return ways;
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp</summary>
  <p> - 获取不同的方法数</p>
  <pre><code>public static int dp1(int[] arr, int aim) {
  		if (arr == null || arr.length == 0 || aim < 0) {
  			return 0;
  		}
  		int N = arr.length;
  		int[][] dp = new int[N + 1][aim + 1];
  		dp[N][0] = 1;
  		for (int index = N - 1; index >= 0; index--) {
  			for (int rest = 0; rest <= aim; rest++) {
  				int ways = 0;
  				for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
  					ways += dp[index + 1][rest - (zhang * arr[index])];
  				}
  				dp[index][rest] = ways;
  			}
  		}
  		return dp[0][aim];
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp枚举优化</summary>
  <p> - 获取不同的方法数</p>
  <pre><code>public static int dp2(int[] arr, int aim) {
  		if (arr == null || arr.length == 0 || aim < 0) {
  			return 0;
  		}
  		int N = arr.length;
  		int[][] dp = new int[N + 1][aim + 1];
  		dp[N][0] = 1;
  		for (int index = N - 1; index >= 0; index--) {
  			for (int rest = 0; rest <= aim; rest++) {
  				dp[index][rest] = dp[index + 1][rest];
  				if (rest - arr[index] >= 0) {
  					dp[index][rest] += dp[index][rest - arr[index]];
  				}
  			}
  		}
  		return dp[0][aim];
  	}</code>  </pre>
  </details>

### CoinsWaySameValueSamePapper

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class21/Code04_CoinsWaySameValueSamePapper.java">测试链接</a>

- 内容：

  > arr是货币数组，其中的值都是正数。
  >
  > 再给定一个正数aim。每个值都认为是一张货币，认为值相同的货币没有任何不同，
  >
  > 返回组成aim的方法数
  >
  > 例如: arr = [1,2,1,1,2,1.2]， aim = 4
  >
  > 方法∶1+1+1+1、1+1+2、2+2—共就3种方法，所以返回3。

- 思路：

  > 递归
  >
  > dp
  >
  > dp枚举优化

- 代码：

  <details>
  <summary>递归</summary>
  <p> - 获取不同的方法数</p>
  <pre><code>	public static class Info {
  		public int[] coins;
  		public int[] zhangs;
  		public Info(int[] c, int[] z) {
  			coins = c;
  			zhangs = z;
  		}
  	}
  	public static Info getInfo(int[] arr) {
  		HashMap<Integer, Integer> counts = new HashMap<>();
  		for (int value : arr) {
  			if (!counts.containsKey(value)) {
  				counts.put(value, 1);
  			} else {
  				counts.put(value, counts.get(value) + 1);
  			}
  		}
  		int N = counts.size();
  		int[] coins = new int[N];
  		int[] zhangs = new int[N];
  		int index = 0;
  		for (Map.Entry<Integer, Integer> entry : counts.entrySet()) {
  			coins[index] = entry.getKey();
  			zhangs[index++] = entry.getValue();
  		}
  		return new Info(coins, zhangs);
  	}
  	public static int coinsWay(int[] arr, int aim) {
  		if (arr == null || arr.length == 0 || aim < 0) {
  			return 0;
  		}
  		Info info = getInfo(arr);
  		return process(info.coins, info.zhangs, 0, aim);
  	}
  	// coins 面值数组，正数且去重
  	// zhangs 每种面值对应的张数
  	public static int process(int[] coins, int[] zhangs, int index, int rest) {
  		if (index == coins.length) {
  			return rest == 0 ? 1 : 0;
  		}
  		int ways = 0;
  		for (int zhang = 0; zhang * coins[index] <= rest && zhang <= zhangs[index]; zhang++) {
  			ways += process(coins, zhangs, index + 1, rest - (zhang * coins[index]));
  		}
  		return ways;
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp</summary>
  <p> - 获取不同的方法数</p>
  <pre><code>public static int dp1(int[] arr, int aim) {
  		if (arr == null || arr.length == 0 || aim < 0) {
  			return 0;
  		}
  		Info info = getInfo(arr);
  		int[] coins = info.coins;
  		int[] zhangs = info.zhangs;
  		int N = coins.length;
  		int[][] dp = new int[N + 1][aim + 1];
  		dp[N][0] = 1;
  		for (int index = N - 1; index >= 0; index--) {
  			for (int rest = 0; rest <= aim; rest++) {
  				int ways = 0;
  				for (int zhang = 0; zhang * coins[index] <= rest && zhang <= zhangs[index]; zhang++) {
  					ways += dp[index + 1][rest - (zhang * coins[index])];
  				}
  				dp[index][rest] = ways;
  			}
  		}
  		return dp[0][aim];
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp枚举优化</summary>
  <p> - 获取不同的方法数</p>
  <pre><code>public static int dp2(int[] arr, int aim) {
  		if (arr == null || arr.length == 0 || aim < 0) {
  			return 0;
  		}
  		Info info = getInfo(arr);
  		int[] coins = info.coins;
  		int[] zhangs = info.zhangs;
  		int N = coins.length;
  		int[][] dp = new int[N + 1][aim + 1];
  		dp[N][0] = 1;
  		for (int index = N - 1; index >= 0; index--) {
  			for (int rest = 0; rest <= aim; rest++) {
  				dp[index][rest] = dp[index + 1][rest];
  				if (rest - coins[index] >= 0) {
  					dp[index][rest] += dp[index][rest - coins[index]];
  				}
  				if (rest - coins[index] * (zhangs[index] + 1) >= 0) {
  					dp[index][rest] -= dp[index + 1][rest - coins[index] * (zhangs[index] + 1)];
  				}
  			}
  		}
  		return dp[0][aim];
  	}</code>  </pre>
  </details>

### BobDie

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class21/Code05_BobDie.java">测试链接</a>

- 内容：

  > 给定5个参数，N,M,row,col,k
  > 表示在N * M的区域上，醉汉Bob初始在(row,col)位置
  > Bob一共要迈出k步，且每步都会等概率向上下左右四个方向走一个单位
  >
  > 任何时候Bob只要离开N * M的区域，就直接死亡
  >
  > 返回k步之后，Bob还在N * M的区域的概率

- 思路：

  > 递归
  >
  > dp
  >

- 代码：

  <details>
  <summary>递归</summary>
  <p> - 获取存活的概率</p>
  <pre><code>		public static double livePosibility1(int row, int col, int k, int N, int M) {
  		return (double) process(row, col, k, N, M) / Math.pow(4, k);
  	}
  	// 目前在row，col位置，还有rest步要走，走完了如果还在棋盘中就获得1个生存点，返回总的生存点数
  	public static long process(int row, int col, int rest, int N, int M) {
  		if (row < 0 || row == N || col < 0 || col == M) {
  			return 0;
  		}
  		// 还在棋盘中！
  		if (rest == 0) {
  			return 1;
  		}
  		// 还在棋盘中！还有步数要走
  		long up = process(row - 1, col, rest - 1, N, M);
  		long down = process(row + 1, col, rest - 1, N, M);
  		long left = process(row, col - 1, rest - 1, N, M);
  		long right = process(row, col + 1, rest - 1, N, M);
  		return up + down + left + right;
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp</summary>
  <p> - 获取存活的概率</p>
  <pre><code>public static double livePosibility2(int row, int col, int k, int N, int M) {
  		long[][][] dp = new long[N][M][k + 1];
  		for (int i = 0; i < N; i++) {
  			for (int j = 0; j < M; j++) {
  				dp[i][j][0] = 1;
  			}
  		}
  		for (int rest = 1; rest <= k; rest++) {
  			for (int r = 0; r < N; r++) {
  				for (int c = 0; c < M; c++) {
  					dp[r][c][rest] = pick(dp, N, M, r - 1, c, rest - 1);
  					dp[r][c][rest] += pick(dp, N, M, r + 1, c, rest - 1);
  					dp[r][c][rest] += pick(dp, N, M, r, c - 1, rest - 1);
  					dp[r][c][rest] += pick(dp, N, M, r, c + 1, rest - 1);
  				}
  			}
  		}
  		return (double) dp[row][col][k] / Math.pow(4, k);
  	}
  	public static long pick(long[][][] dp, int N, int M, int r, int c, int rest) {
  		if (r < 0 || r == N || c < 0 || c == M) {
  			return 0;
  		}
  		return dp[r][c][rest];
  	}</code>  </pre>
  </details>
