# 子数组达到规定累加和的最大长度系列

## 基本内容

- 总结

  > 题目一主要技巧︰利用单调性优化
  > 题目二主要技巧∶利用预处理结构优化+讨论开头结尾
  > 题目三主要技巧∶假设答案法+淘汰可能性(很难，以后还会见到)

## 问题集合

### LongestSumSubArrayLengthInPositiveArray

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class40/Code01_LongestSumSubArrayLengthInPositiveArray.java">测试链接</a>

- 内容：

  > 给定一个正整数组成的无序数组arr，给定一个正整数值K
  >
  > 找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的返回其长度。
  
- 思路：

  > 滑动窗口 L,R初始为0，[L,R]内的值为sum
  >
  > **当sum < K R++**
  >
  > **当sum = K 时记录，且R++** (**arr[R+1] = 0 may be**)
  >
  > **当sum > K时，L++**
  
- 代码：

  <details>
  <summary>滑动窗口</summary>
  <p> - 等于K的最大长度</p>
  <pre><code>	public static int getMaxLength(int[] arr, int K) {
  		if (arr == null || arr.length == 0 || K <= 0) {
  			return 0;
  		}
  		int left = 0;
  		int right = 0;
  		int sum = arr[0];
  		int len = 0;
  		while (right < arr.length) {
  			if (sum == K) {
  				len = Math.max(len, right - left + 1);
  				sum -= arr[left++];
  			} else if (sum < K) {
  				right++;
  				if (right == arr.length) {
  					break;
  				}
  				sum += arr[right];
  			} else {
  				sum -= arr[left++];
  			}
  		}
  		return len;
  	}</code>  </pre>
  </details>

### LongestSumSubArrayLength

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class40/Code02_LongestSumSubArrayLength.java">测试链接</a>

- 内容：

  > 给定一个整数组成的无序数组arr，值可能正、可能负、可能0，给定一个整数值K
  >
  > 找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的返回其长度。

- 思路：

  > 使用前缀和，辅助
  >
  > 当前缀和包含K - arr[i],则记录
  >
  > 否则记录当前sum值及其出现最早的index

- 代码：

  <details>
  <summary>前缀和记录</summary>
  <p> - 等于K的最大长度</p>
  <pre><code>	public static int maxLength(int[] arr, int k) {
  		if (arr == null || arr.length == 0) {
  			return 0;
  		}
  		// key:前缀和
  		// value : 0~value这个前缀和是最早出现key这个值的
  		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
  		map.put(0, -1); // important
  		int len = 0;
  		int sum = 0;
  		for (int i = 0; i < arr.length; i++) {
  			sum += arr[i];
  			if (map.containsKey(sum - k)) {
  				len = Math.max(i - map.get(sum - k), len);
  			}
  			if (!map.containsKey(sum)) {
  				map.put(sum, i);
  			}
  		}
  		return len;
  	}</code>  </pre>
  </details>

### LongestLessSumSubArrayLength

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class40/Code03_LongestLessSumSubArrayLength.java">测试链接</a>

- 内容：

  > 给定一个整数组成的无序数组arr，值可能正、可能负、可能0给定一个整数值K
  > 找到arr的所有子数组里，哪个子数组的累加和<=K，并且是长度最大的返回其长度。

- 思路：

  > 滑动窗口，要有辅助信息
  >
  > 1、生成两个和arr数组长度相等的数组，分别为minSums和minSumEnds
  >
  > ​	minSums[i]表示i~n-1这个区间中以i为头的，最小值
  >
  > ​	minSumEnds[i]表示i~n-1这个区间中以i为头的，最小值所压中的右边界位置
  >
  > 2、滑动窗口开始滑动（初始i=0,end=0,为窗口的左右边界）
  >
  > ​	1、ans默认为0,sum默认为0,end默认为0
  >
  > ​	2、若sum+minSums[end] <= K,且end < n,表明以当前L为首的数组，可以填充数据以end+1的数组
  >
  > ​	3、记录ans
  >
  > ​	4、sum -=arr[i],i++,查看以i开头的数据，最长能扩多远
  >
  > ​	5、最后返回ans
  >
  > **从始至终end不回退，**(**可能存在以i开头，到end结束但是<K的情况，不用管，以i开头的数据的真实答案，因为这个值肯定不可能超过之前的i~end这个区间的长度，我们只关心最长的长度**)
  >
  > 时间复杂度O(N)

- 代码：

  <details>
  <summary>滑动窗口+最小值记录</summary>
  <p> - <=K的最大长度</p>
  <pre><code>	public static int maxLengthAwesome(int[] arr, int k) {
  		if (arr == null || arr.length == 0) {
  			return 0;
  		}
  		int[] minSums = new int[arr.length];
  		int[] minSumEnds = new int[arr.length];
  		minSums[arr.length - 1] = arr[arr.length - 1];
  		minSumEnds[arr.length - 1] = arr.length - 1;
  		for (int i = arr.length - 2; i >= 0; i--) {
  			if (minSums[i + 1] < 0) {
  				minSums[i] = arr[i] + minSums[i + 1];
  				minSumEnds[i] = minSumEnds[i + 1];
  			} else {
  				minSums[i] = arr[i];
  				minSumEnds[i] = i;
  			}
  		}
  		// 迟迟扩不进来那一块儿的开头位置
  		int end = 0;
  		int sum = 0;
  		int ans = 0;
  		for (int i = 0; i < arr.length; i++) {
  			// while循环结束之后：
  			// 1) 如果以i开头的情况下，累加和<=k的最长子数组是arr[i..end-1]，看看这个子数组长度能不能更新res；
  			// 2) 如果以i开头的情况下，累加和<=k的最长子数组比arr[i..end-1]短，更新还是不更新res都不会影响最终结果；
  			while (end < arr.length && sum + minSums[end] <= k) {
  				sum += minSums[end];
  				end = minSumEnds[end] + 1;
  			}
  			ans = Math.max(ans, end - i);
  			if (end > i) { // 还有窗口，哪怕窗口没有数字 [i~end) [4,4)
  				sum -= arr[i];
  			} else { // i == end,  即将 i++, i > end, 此时窗口概念维持不住了，所以end跟着i一起走
  				end = i + 1;
  			}
  		}
  		return ans;
  	}</code>  </pre>
  </details>

### AvgLessEqualValueLongestSubarray

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class40/Code04_AvgLessEqualValueLongestSubarray.java">测试链接</a>

- 内容：

  > 给定一个数组arr，值v
  >
  > 求子数组平均值小于等于v的最长子数组长度。

- 思路：

  > 先处理一下，原数组全部-v得到一个新数组
  >
  > 求新数组的子数组和 <= 0 的长度
  >
  > 思路同**longestLessSumSubArrayLength**，把K变为0

- 代码：

  <details>
  <summary>滑动窗口+最小值记录</summary>
  <p> - 小于等于v的最大长度</p>
  <pre><code>public static int ways3(int[] arr, int v) {
  		if (arr == null || arr.length == 0) {
  			return 0;
  		}
  		for (int i = 0; i < arr.length; i++) {
  			arr[i] -= v;
  		}
  		return maxLengthAwesome(arr, 0);
  	}
  	// 找到数组中累加和<=k的最长子数组
  	public static int maxLengthAwesome(int[] arr, int k) {
  		int N = arr.length;
  		int[] sums = new int[N];
  		int[] ends = new int[N];
  		sums[N - 1] = arr[N - 1];
  		ends[N - 1] = N - 1;
  		for (int i = N - 2; i >= 0; i--) {
  			if (sums[i + 1] < 0) {
  				sums[i] = arr[i] + sums[i + 1];
  				ends[i] = ends[i + 1];
  			} else {
  				sums[i] = arr[i];
  				ends[i] = i;
  			}
  		}
  		int end = 0;
  		int sum = 0;
  		int res = 0;
  		for (int i = 0; i < N; i++) {
  			while (end < N && sum + sums[end] <= k) {
  				sum += sums[end];
  				end = ends[end] + 1;
  			}
  			res = Math.max(res, end - i);
  			if (end > i) {
  				sum -= arr[i];
  			} else {
  				end = i + 1;
  			}
  		}
  		return res;
  	}</code>  </pre>
  </details>

### PrintMatrixSpiralOrder

- 链接：<a href="https://leetcode.cn/problems/spiral-matrix/description/">测试链接</a>

- 内容：

  > 给定一个正方形矩阵matrix，打印其内容
  >
  > | 1    | 2    | 3    | 4    |
  > | ---- | ---- | ---- | ---- |
  > | 5    | 6    | 7    | 8    |
  > | 9    | 10   | 11   | 12   |
  > | 13   | 14   | 15   | 16   |
  >
  > => 1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10 

- 思路：

  > 每一层运行完后，下一层的起点就是(0,0)(1,1)...
  >
  > 每次以向右运行，运行不动了向下，向下不动了向左，向左不动了，向上
  >
  > (0,0)->(0,n-1)->(m-1,n-1)->(m-1,0)->(1,0)
  >
  > (i,i)->(i,n-1-i)->(m-1-i,n-1-i)->(m-1-i,i)->(i+1,i)

- 代码：

  <details>
  <summary>打印数据</summary>
  <p> - 螺旋剥洋葱</p>
  <pre><code>public static void spiralOrderPrint(int[][] matrix) {
  		int tR = 0;
  		int tC = 0;
  		int dR = matrix.length - 1;
  		int dC = matrix[0].length - 1;
  		while (tR <= dR && tC <= dC) {
  			printEdge(matrix, tR++, tC++, dR--, dC--);
  		}
  	}
  	public static void printEdge(int[][] m, int tR, int tC, int dR, int dC) {
  		if (tR == dR) {
  			for (int i = tC; i <= dC; i++) {
  				System.out.print(m[tR][i] + " ");
  			}
  		} else if (tC == dC) {
  			for (int i = tR; i <= dR; i++) {
  				System.out.print(m[i][tC] + " ");
  			}
  		} else {
  			int curC = tC;
  			int curR = tR;
  			while (curC != dC) {
  				System.out.print(m[tR][curC] + " ");
  				curC++;
  			}
  			while (curR != dR) {
  				System.out.print(m[curR][dC] + " ");
  				curR++;
  			}
  			while (curC != tC) {
  				System.out.print(m[dR][curC] + " ");
  				curC--;
  			}
  			while (curR != tR) {
  				System.out.print(m[curR][tC] + " ");
  				curR--;
  			}
  		}
  	}</code>  </pre>
  </details>

### RotateMatrix

- 链接：<a href="https://leetcode.cn/problems/rotate-image/description/">测试链接</a>

- 内容：

  > 给定一个正方形矩阵matrix，打印其内容
  >
  > | 1    | 2    | 3    | 4    |
  > | ---- | ---- | ---- | ---- |
  > | 5    | 6    | 7    | 8    |
  > | 9    | 10   | 11   | 12   |
  > | 13   | 14   | 15   | 16   |
  >
  > =>
  >
  > | 13   | 9    | 5    | 1    |
  > | ---- | ---- | ---- | ---- |
  > | 14   | 10   | 6    | 2    |
  > | 15   | 11   | 7    | 3    |
  > | 16   | 12   | 8    | 4    |
  >
  > 

- 思路：

  > 思路一：可以先把原数组沿对角线互换，再沿中间对称轴交换左右(略)
  >
  > 思路二：分析每一层的位置变换，一共有长度-1个变换，每4个值顺序交换值。

- 代码：

  <details>
  <summary>原地更改数据</summary>
  <p> - 螺旋剥洋葱</p>
  <pre><code>public static void rotate(int[][] matrix) {
  		int a = 0;
  		int b = 0;
  		int c = matrix.length - 1;
  		int d = matrix[0].length - 1;
  		while (a < c) {
  			rotateEdge(matrix, a++, b++, c--, d--);
  		}
  	}
  	public static void rotateEdge(int[][] m, int a, int b, int c, int d) {
  		int tmp = 0;
  		for (int i = 0; i < d - b; i++) {
  			tmp = m[a][b + i];
  			m[a][b + i] = m[c - i][b];
  			m[c - i][b] = m[c][d - i];
  			m[c][d - i] = m[a + i][d];
  			m[a + i][d] = tmp;
  		}
  	}</code>  </pre>
  </details>

### ZigZagPrintMatrix

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class40/Code07_ZigZagPrintMatrix.java">测试链接</a>

- 内容：

  > 给定一个正方形矩阵matrix，打印其内容
  >
  > | 1    | 2    | 3    | 4    |
  > | ---- | ---- | ---- | ---- |
  > | 5    | 6    | 7    | 8    |
  > | 9    | 10   | 11   | 12   |
  >
  > => 1 2 5 9 6 3 4 7 10 11 8 12 

- 思路：

  > 从(0,0)开始打印，以对角线为对称轴的边界上的两点连成一线
  >
  > 从左下到右上，从右上到左下，依次进行打印
  >
  > 下面一直向下，不能向下了，则一直向右
  >
  > 上面一直向右，不能向右了，则一直向下

- 代码：

  <details>
  <summary>打印数据</summary>
  <p> - 斜线打印，上下交替</p>
  <pre><code>	public static void printMatrixZigZag(int[][] matrix) {
  		int tR = 0;
  		int tC = 0;
  		int dR = 0;
  		int dC = 0;
  		int endR = matrix.length - 1;
  		int endC = matrix[0].length - 1;
  		boolean fromUp = false;
  		while (tR != endR + 1) {
  			printLevel(matrix, tR, tC, dR, dC, fromUp);
  			tR = tC == endC ? tR + 1 : tR;
  			tC = tC == endC ? tC : tC + 1;
  			dC = dR == endR ? dC + 1 : dC;
  			dR = dR == endR ? dR : dR + 1;
  			fromUp = !fromUp;
  		}
  		System.out.println();
  	}
  	public static void printLevel(int[][] m, int tR, int tC, int dR, int dC, boolean f) {
  		if (f) {
  			while (tR != dR + 1) {
  				System.out.print(m[tR++][tC--] + " ");
  			}
  		} else {
  			while (dR != tR - 1) {
  				System.out.print(m[dR--][dC++] + " ");
  			}
  		}
  	}</code>  </pre>
  </details>

### PrintStar

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class40/Code08_PrintStar.java">测试链接</a>

- 内容：

  > 给定一个正方形矩阵matrix，打印其内容
  >
  > 按顺序规则打印二维表中的值
  >
  > 0 0 0 0 0 0 
  >
  > 0 0 0 0 0 0 
  >
  > 0 0 0 0 0 0 
  >
  > 0 0 0 0 0 0 
  >
  > 0 0 0 0 0 0
  >
  > 0 0 0 0 0 0
  >
  > =》
  >
  > 1 1 1 1 1 1 
  >
  > 0 0 0 0 0 1 
  >
  > 0 2 2 2 0 1 
  >
  > 0 2 0 2 0 1 
  >
  > 0 2 0 0 0 1
  >
  > 0 1 1 1 1 1
  >
  > ```java
  > * * * * * 
  >         * 
  >   * *   * 
  >   *     * 
  >   * * * * 
  > ```

- 思路：

  > 按照环的打印规则
  >
  > 环最后有一个边不用，只需要打印三个边即可

- 代码：

  <details>
  <summary>打印数据</summary>
  <p> - 螺旋</p>
  <pre><code>public static void printStar(int N) {
  		int leftUp = 0;
  		int rightDown = N - 1;
  		char[][] m = new char[N][N];
  		for (int i = 0; i < N; i++) {
  			for (int j = 0; j < N; j++) {
  				m[i][j] = ' ';
  			}
  		}
  		while (leftUp <= rightDown) {
  			set(m, leftUp, rightDown);
  			leftUp += 2;
  			rightDown -= 2;
  		}
  		for (int i = 0; i < N; i++) {
  			for (int j = 0; j < N; j++) {
  				System.out.print(m[i][j] + " ");
  			}
  			System.out.println();
  		}
  	}
  	public static void set(char[][] m, int leftUp, int rightDown) {
  		for (int col = leftUp; col <= rightDown; col++) {
  			m[leftUp][col] = '*';
  		}
  		for (int row = leftUp + 1; row <= rightDown; row++) {
  			m[row][rightDown] = '*';
  		}
  		for (int col = rightDown - 1; col > leftUp; col--) {
  			m[rightDown][col] = '*';
  		}
  		for (int row = rightDown - 1; row > leftUp + 1; row--) {
  			m[row][leftUp + 1] = '*';
  		}
  	}</code>  </pre>
  </details>

