# 二叉树递归套路续，贪心算法上

## 基本内容

- 递归套路

  > 1）假设以X节点为头，假设可以向X左树和X右树要任何信息
  >
  > 2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）
  >
  > 3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息
  >
  > 4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S
  >
  > 5）递归函数都返回S，每一棵子树都这么要求
  >
  > 6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息

- 贪心算法

  > 1）最自然智慧的算法
  >
  > 2）用一种局部最功利的标准，总是做出在当前看来是最好的选择
  >
  > 3）难点在于证明局部最功利的标准可以得到全局最优解
  >
  > 4）对于贪心算法的学习主要以增加阅历和经验为主

## 问题集合

### MaxSubBSTHead

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class13/Code01_MaxSubBSTHead.java">测试链接</a>

- 内容：

  > 最大（子结点最多）的二叉搜索子树的头节点

- 思路：

  > 思路一：
  >
  > ​	递归获取头节点及其左右节点
  >
  > ​	获取以当前节点为头的中序遍历集合，返回其严格递增的数量
  >
  > ​	返回其最大值
  >
  > 思路二：二叉树的递归套路
  >
  > ​	使用辅助类记录以此节点为头的子树的信息，如**最大值，最小值，最大子BST的头和大小**
  >
  > ​	有以下几种情况
  >
  > ​	最大值为左右子树及头的最大值（若存在）
  >
  > ​	最小值为左右子树及头的最小值（若存在）
  >
  > ​	要先判断以此节点为头的节点是否为bst
  >
  > ​		满足以下条件
  >
  > ​			左树为空或左树的subBstHead为head.left并且l.max < head.val
  >
  > ​			右树为空或右树的subBstHead为head.right并且r.min> head.val
  >
  > ​	以此节点为头若为bst，则更新subBstHead和subBstSize
  >
  > ​	封装信息返回

- 代码：

  <details>
    <summary>存储中序遍历数组判断</summary>
    <p> - 返回最大的子树的头节点</p>
    <pre><code> public static int getBSTSize(Node head) {
  		if (head == null) {
  			return 0;
  		}
  		ArrayList<Node> arr = new ArrayList<>();
  		in(head, arr);
  		for (int i = 1; i < arr.size(); i++) {
  			if (arr.get(i).value <= arr.get(i - 1).value) {
  				return 0;
  			}
  		}
  		return arr.size();
  	}
  	public static void in(Node head, ArrayList<Node> arr) {
  		if (head == null) {
  			return;
  		}
  		in(head.left, arr);
  		arr.add(head);
  		in(head.right, arr);
  	}
  	public static Node maxSubBSTHead1(Node head) {
  		if (head == null) {
  			return null;
  		}
  		if (getBSTSize(head) != 0) {
  			return head;
  		}
  		Node leftAns = maxSubBSTHead1(head.left);
  		Node rightAns = maxSubBSTHead1(head.right);
  		return getBSTSize(leftAns) >= getBSTSize(rightAns) ? leftAns : rightAns;
  	}</code>  </pre>
    </details>
  <details>
    <summary>二叉树递归套路</summary>
    <p> - 返回最大的子树的头节点</p>
    <pre><code> public static Node maxSubBSTHead2(Node head) {
  		if (head == null) {
  			return null;
  		}
  		return process(head).maxSubBSTHead;
  	}
  	// 每一棵子树
  	public static class Info {
  		public Node maxSubBSTHead;
  		public int maxSubBSTSize;
  		public int min;
  		public int max;
  		public Info(Node h, int size, int mi, int ma) {
  			maxSubBSTHead = h;
  			maxSubBSTSize = size;
  			min = mi;
  			max = ma;
  		}
  	}
  	public static Info process(Node X) {
  		if (X == null) {
  			return null;
  		}
  		Info leftInfo = process(X.left);
  		Info rightInfo = process(X.right);
  		int min = X.value;
  		int max = X.value;
  		Node maxSubBSTHead = null;
  		int maxSubBSTSize = 0;
  		if (leftInfo != null) {
  			min = Math.min(min, leftInfo.min);
  			max = Math.max(max, leftInfo.max);
  			maxSubBSTHead = leftInfo.maxSubBSTHead;
  			maxSubBSTSize = leftInfo.maxSubBSTSize;
  		}
  		if (rightInfo != null) {
  			min = Math.min(min, rightInfo.min);
  			max = Math.max(max, rightInfo.max);
  			if (rightInfo.maxSubBSTSize > maxSubBSTSize) {
  				maxSubBSTHead = rightInfo.maxSubBSTHead;
  				maxSubBSTSize = rightInfo.maxSubBSTSize;
  			}
  		}
  		if ((leftInfo == null ? true : (leftInfo.maxSubBSTHead == X.left && leftInfo.max < X.value))
  				&& (rightInfo == null ? true : (rightInfo.maxSubBSTHead == X.right && rightInfo.min > X.value))) {
  			maxSubBSTHead = X;
  			maxSubBSTSize = (leftInfo == null ? 0 : leftInfo.maxSubBSTSize)
  					+ (rightInfo == null ? 0 : rightInfo.maxSubBSTSize) + 1;
  		}
  		return new Info(maxSubBSTHead, maxSubBSTSize, min, max);
  	}</code>  </pre>
    </details>

### LowestAncestor

- 链接：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">测试链接</a>

- 内容：

  > 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
  >
  > [百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”
  >
  > **示例 1：**
  >
  > ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
  >
  > ```
  > 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
  > 输出：3
  > 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
  > ```
  >
  > **示例 2：**
  >
  > ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
  >
  > ```
  > 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
  > 输出：5
  > 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
  > ```
  >
  > **示例 3：**
  >
  > ```
  > 输入：root = [1,2], p = 1, q = 2
  > 输出：1
  > ```

- 思路：

  > 思路一：
  >
  > ​	递归获取节点的父信息，并存储在map中
  >
  > ​	两个节点根据map一直向上，直到遇见存在的节点
  >
  > ​	返回其所有向上的次数-1
  >
  > 思路二：二叉树的递归套路
  >
  > ​	使用辅助类记录以此节点为头的子树的信息，如**isExistA,isExistB,lowestNode**
  >
  > ​	有以下几种情况
  >
  > ​	如果当前lowestNode不为空，则直接返回
  >
  > ​	如果当前节点等于A，则isExist=true;B也是如此
  >
  > ​	封装信息返回

- 代码：

  <details>
    <summary>map存储父子节点判断</summary>
    <p> - 返回最低公共祖先节点</p>
    <pre><code> public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          return lowestCommonAncestor1(root,p,q);
      }
      public TreeNode lowestCommonAncestor1(TreeNode root, TreeNode p, TreeNode q) {
          if(p == q) return p;
          Map<TreeNode, TreeNode> map = new HashMap<>();
          process(root,map,null);
          return getLowestNode(p,q,map);
      }
      public static void process(TreeNode cur,Map<TreeNode, TreeNode> map,TreeNode pre){
          if(cur == null) return;
          map.put(cur,pre);
          process(cur.left,map,cur);
          process(cur.right,map,cur);
      }
      public static TreeNode getLowestNode(TreeNode p,TreeNode q,Map<TreeNode,TreeNode> map){
          Set<TreeNode> exists = new HashSet<>();
          TreeNode cur = p;
          while (cur != null){
              exists.add(cur);
              cur = map.get(cur);
          }
          cur = q;
          while (!exists.contains(cur)){
              cur = map.get(cur);
          }
          return cur;
      }</code>  </pre>
    </details>
  <details>
    <summary>二叉树递归套路</summary>
    <p> - 返回最低公共祖先节点</p>
    <pre><code> public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          return lowestCommonAncestor2(root,p,q);
      }
      public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) {
          return process(root,p,q).lowestNode;
      }
      static class Info{
          public boolean isExistP;
          public boolean isExistQ;
          public TreeNode lowestNode;
          public Info(){}
          public Info(boolean p,boolean q,TreeNode lowestNode){isExistP=p;isExistQ=q;this.lowestNode=lowestNode;}
      }
      public static Info process(TreeNode cur,TreeNode p,TreeNode q){
          if(cur == null) return new Info(false,false,null);
          Info lInfo = process(cur.left, p, q);
          Info rInfo = process(cur.right, p, q);
          if(lInfo.lowestNode != null || rInfo.lowestNode != null){
              return lInfo.lowestNode != null ? lInfo : rInfo;
          }
          boolean isP = lInfo.isExistP || rInfo.isExistP || p == cur, isQ = lInfo.isExistQ || rInfo.isExistQ || q == cur;
          TreeNode lowestNode = null;
          if(isQ && isP) return new Info(true,true,cur);
          else return new Info(isP,isQ,lowestNode);
      }</code>  </pre>
    </details>

### MaxHappy

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class13/Code03_MaxHappy.java">测试链接</a>

- 内容：

  > 员工信息的定义如下：
  >
  > ```java
  > Class Employee{
  > 　　public int happy; //快乐值
  > 　　public List<Employee> subordinates; //该员工的直接下属
  > }
  > ```
  >
  > 公司的每个员工都符合上述类的描述。整个公司的人员结构都可看成是一棵标准的、没有环的多叉树。
  >
  > 树的头结点是整个公司唯一的老板，除老板之外的员工都有唯一的直接上级。
  >
  > 叶子结点是没有任何下属的基层员工（subordinates列表为空），除基层员工外，每个员工都有一个或多个直接下级。
  >
  > 这个公司现在要办party，你可以决定哪些员工来，哪些员工不来。但要遵循如下规则：
  >
  > **1.如果某个员工来了，那么这个员工的所有直接下级都不能来。**
  >
  > **2.派对的整体快乐值是所有到场员工全部快乐值的累加。**
  >
  > **3.你的目标是让派对的整体快乐值尽可能地大。**
  >
  > 给定一棵多叉树的头结点boss，请返回派对的最大快乐值。

- 思路：

  > **当上级来的话，直属下级一定不能来**
  >
  > **当上级不来的话，直属下级不一定要来**
  >
  > 思路一：暴力递归
  >
  > 思路二：二叉树的递归套路
  >
  > ​	使用辅助类记录以此节点为头的子树的信息，如**no,yes**
  >
  > ​	记录所有子节点在no情况下的最大值，及yes情况下的最大值
  >
  > ​	封装信息返回

- 代码：

  <details>
    <summary>暴力递归</summary>
    <p> - 返回最大happy值</p>
    <pre><code> public static int maxHappy1(Employee boss){
          if(boss == null) return 0;
          return process1(boss,false); // boss自由选择
      }
      // 当前来到的节点叫cur，
      // up表示cur的上级是否来，
      // 该函数含义：
      // 如果up为true，表示在cur上级已经确定来，的情况下，cur整棵树能够提供最大的快乐值是多少？
      // 如果up为false，表示在cur上级已经确定不来，的情况下，cur整棵树能够提供最大的快乐值是多少？
      public static int process1(Employee cur,boolean up){
          if(up){
              int ans = 0;
              for (Employee next : cur.nexts) {
                  ans += process1(next,false);
              }
              return ans;
          }else{ // 上级没来，下级可来可不来
              int p1 = cur.happy;
              int p2 = 0;
              for (Employee next : cur.nexts) {
                  p1 += process1(next,true);
                  p2 += process1(next,false);
              }
              return Math.max(p1,p2);
          }
      }
  </code>  </pre>
    </details>
  <details>
    <summary>二叉树递归套路</summary>
    <p> - 返回最大happy值</p>
    <pre><code> public static int maxHappy2(Employee boss){
          if(boss == null) return 0;
          Info info = process2(boss);
          return Math.max(info.no,info.yes);
      }
      public static class Info {
          public int no;
          public int yes;
          public Info(int n, int y) {
              no = n;
              yes = y;
          }
      }
      public static Info process2(Employee cur){
          if(cur == null) return new Info(0,0);
          int yes = cur.happy;
          int no = 0;
          for (Employee next : cur.nexts) {
              Info nextInfo = process2(next);
              no += Math.max(nextInfo.yes,nextInfo.no);
              yes += nextInfo.no;
          }
          return new Info(no,yes);
      }</code>  </pre>
    </details>

### LowestLexicography

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class13/Code05_LowestLexicography.java">测试链接</a>

- 内容：

  > 给定一个由字符串组成的数组strs,必须把所有的字符串拼接起来，
  > 返回所有可能的拼接结果中，字典序最小的结果

- 思路：

  > 思路一：暴力尝试，把所有的字符串全排列得到并收集起来比较，得到最小的字符串
  >
  > 思路二：贪心算法
  >
  > ​	任一两个字符串ab,bc，因为ab在bc之前，所以abbc < bcab的
  >
  > ​	我们可以把字符串先排序，拼接后能直接得到最小的字典序结果

- 代码：

  <details>
    <summary>暴力尝试</summary>
    <p> - 返回最小字典序字符串</p>
    <pre><code> public static String lowestString1(String[] strs) {
  		if (strs == null || strs.length == 0) {
  			return "";
  		}
  		TreeSet<String> ans = process(strs);
  		return ans.size() == 0 ? "" : ans.first();
  	}
  	// strs中所有字符串全排列，返回所有可能的结果
  	public static TreeSet<String> process(String[] strs) {
  		TreeSet<String> ans = new TreeSet<>();
  		if (strs.length == 0) {
  			ans.add("");
  			return ans;
  		}
  		for (int i = 0; i < strs.length; i++) {
  			String first = strs[i];
  			String[] nexts = removeIndexString(strs, i);
  			TreeSet<String> next = process(nexts);
  			for (String cur : next) {
  				ans.add(first + cur);
  			}
  		}
  		return ans;
  	}
  	// {"abc", "cks", "bct"}
  	// 0 1 2
  	// removeIndexString(arr , 1) -> {"abc", "bct"}
  	public static String[] removeIndexString(String[] arr, int index) {
  		int N = arr.length;
  		String[] ans = new String[N - 1];
  		int ansIndex = 0;
  		for (int i = 0; i < N; i++) {
  			if (i != index) {
  				ans[ansIndex++] = arr[i];
  			}
  		}
  		return ans;
  	}</code>  </pre>
    </details>
  <details>
    <summary>贪心算法</summary>
    <p> - 返回最小字典序字符串</p>
    <pre><code> public static class MyComparator implements Comparator<String>{
  		@Override
  		public int compare(String o1, String o2) {
  			return (o1+o2).compareTo(o2+o1);
  		}
  	}
  	public static String lowestString2(String[] strs) {
  		if(strs == null || strs.length == 0) return "";
  		Arrays.sort(strs,new MyComparator());
  		StringBuilder sb = new StringBuilder();
  		for (int i = 0; i < strs.length; i++) {
  			sb.append(strs[i]);
  		}
  		return sb.toString();
  	}</code>  </pre>
    </details>