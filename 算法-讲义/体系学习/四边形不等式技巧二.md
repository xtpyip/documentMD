# 四边形不等式技巧二

## 基本内容

- 区间划分问题中划分点不回退的现象

- 四边形不等式技巧特征

  > 1，两个可变参数的区间划分问题
  >
  > 2，每个格子有枚举行为
  >
  > 3，当两个可变参数固定一个，另一个参数和答案之间存在单调性关系
  >
  > 4，而且往往是反向单调关系
  >
  > 5，枚举加速的位置对:上+右，或者，左+下
  >
  > 6，不要证明!用对数器验证!
  >
  > 7，可以把时间复杂度降低一阶

- 四边形不等式技巧注意点

  > 1，不要证明!用对数器验证!
  >
  > 2，枚举的时候面对最优答案相等的时候怎么处理?都试试!
  >
  > 3，可以把时间复杂度降低一阶
  > O(N^3) -> O(N^2)
  >
  > O(N^2 * M)->O(N*M)
  >
  > O(N * M^2) -> O(N*M)
  >
  > 4，四边形不等式有些时候是最优解，有些时候不是不是的原因:尝试思路，在根儿上不够好

## 问题集合

### PostOfficeProblem

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class42/Code01_PostOfficeProblem.java">测试链接</a>

- 内容：

  > 一条直线上有居民点，邮局只能建在居民点上。
  >
  > 给定一个有序正数数组arr，每个值表示居民点的一维坐标，再给定一个正数num，表示邮局数量。
  >
  > 选择num个居民点建立num个邮局，使所有的居民点到最近邮局的总距离最短，返回最短的总距离
  >
  > 【举例】
  > arr=[1,2,3,4,5,1000]，num=2。
  >
  > 第一个邮局建立在3位置，第二个邮局建立在1000位置。那么1位置到邮局的距离为2，2位置到邮局距离为1，3位置到邮局的距离为0，4位置到邮局的距离为1，5位置到邮局的距离为2，1000位置到邮局的距离为0。
  >
  > 这种方案下的总距离为6，其他任何方案的总距离都不会比该方案的总距离更短，所以返回6
  
- 思路：

  > 思路一：dp dp[i] [j]表示0~i区间使用j个邮局的子数组的最小距离值
  >
  > 思路二：dp优化 (四边形不等式技巧)
  
- 代码：

  <details>
  <summary>dp</summary>
  <p> - 最小距离值</p>
  <pre><code>public static int min1(int[] arr, int num) {
  		if (arr == null || num < 1 || arr.length < num) {
  			return 0;
  		}
  		int N = arr.length;
  		int[][] w = new int[N + 1][N + 1];
  		for (int L = 0; L < N; L++) {
  			for (int R = L + 1; R < N; R++) {
  				w[L][R] = w[L][R - 1] + arr[R] - arr[(L + R) >> 1];
  			}
  		}
  		int[][] dp = new int[N][num + 1];
  		for (int i = 0; i < N; i++) {
  			dp[i][1] = w[0][i];
  		}
  		for (int i = 1; i < N; i++) {
  			for (int j = 2; j <= Math.min(i, num); j++) {
  				int ans = Integer.MAX_VALUE;
  				for (int k = 0; k <= i; k++) {
  					ans = Math.min(ans, dp[k][j - 1] + w[k + 1][i]);
  				}
  				dp[i][j] = ans;
  			}
  		}
  		return dp[N - 1][num];
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp优化</summary>
  <p> - 最小距离值</p>
  <pre><code>public static int min2(int[] arr, int num) {
  		if (arr == null || num < 1 || arr.length < num) {
  			return 0;
  		}
  		int N = arr.length;
  		int[][] w = new int[N + 1][N + 1];
  		for (int L = 0; L < N; L++) {
  			for (int R = L + 1; R < N; R++) {
  				w[L][R] = w[L][R - 1] + arr[R] - arr[(L + R) >> 1];
  			}
  		}
  		int[][] dp = new int[N][num + 1];
  		int[][] best = new int[N][num + 1];
  		for (int i = 0; i < N; i++) {
  			dp[i][1] = w[0][i];
  			best[i][1] = -1;
  		}
  		for (int j = 2; j <= num; j++) {
  			for (int i = N - 1; i >= j; i--) {
  				int down = best[i][j - 1];
  				int up = i == N - 1 ? N - 1 : best[i + 1][j];
  				int ans = Integer.MAX_VALUE;
  				int bestChoose = -1;
  				for (int leftEnd = down; leftEnd <= up; leftEnd++) {
  					int leftCost = leftEnd == -1 ? 0 : dp[leftEnd][j - 1];
  					int rightCost = leftEnd == i ? 0 : w[leftEnd + 1][i];
  					int cur = leftCost + rightCost;
  					if (cur <= ans) {
  						ans = cur;
  						bestChoose = leftEnd;
  					}
  				}
  				dp[i][j] = ans;
  				best[i][j] = bestChoose;
  			}
  		}
  		return dp[N - 1][num];
  	}</code>  </pre>
  </details>

### ThrowChessPiecesProblem

- 链接：<a href="https://leetcode.cn/problems/super-egg-drop/description/">测试链接</a>

- 内容：

  > 给你 `k` 枚相同的鸡蛋，并可以使用一栋从第 `1` 层到第 `n` 层共有 `n` 层楼的建筑。
  >
  > 已知存在楼层 `f` ，满足 `0 <= f <= n` ，任何从 **高于** `f` 的楼层落下的鸡蛋都会碎，从 `f` 楼层或比它低的楼层落下的鸡蛋都不会破。
  >
  > 每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 `x` 扔下（满足 `1 <= x <= n`）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 **重复使用** 这枚鸡蛋。
  >
  > 请你计算并返回要确定 `f` **确切的值** 的 **最小操作次数** 是多少？
  >
  > **示例 1：**
  >
  > ```
  > 输入：k = 1, n = 2
  > 输出：2
  > 解释：
  > 鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 
  > 否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 
  > 如果它没碎，那么肯定能得出 f = 2 。 
  > 因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：k = 2, n = 6
  > 输出：3
  > ```
  >
  > **示例 3：**
  >
  > ```
  > 输入：k = 3, n = 14
  > 输出：4
  > ```

- 思路：

  > 思路一：暴力递归
  >
  > 思路二：dp dp[i] [j]表示到达i层使用j个鸡蛋的最小操作次数
  >
  > 思路三：dp优化 (四边形不等式技巧)
  >
  > 思路四：dp[i] [j] 表示i个鸡蛋使用j次确定的楼层数

- 代码：

  <details>
  <summary>暴力递归</summary>
  <p> - 最小操作次数</p>
  <pre><code>public static int superEggDrop1(int kChess, int nLevel) {
  		if (nLevel < 1 || kChess < 1) {
  			return 0;
  		}
  		return Process1(nLevel, kChess);
  	}
  	// rest还剩多少层楼需要去验证
  	// k还有多少颗棋子能够使用
  	// 一定要验证出最高的不会碎的楼层！但是每次都是坏运气。
  	// 返回至少需要扔几次？
  	public static int Process1(int rest, int k) {
  		if (rest == 0) {
  			return 0;
  		}
  		if (k == 1) {
  			return rest;
  		}
  		int min = Integer.MAX_VALUE;
  		for (int i = 1; i != rest + 1; i++) { // 第一次扔的时候，仍在了i层
  			min = Math.min(min, Math.max(Process1(i - 1, k - 1), Process1(rest - i, k)));
  		}
  		return min + 1;
  	}
  </code>  </pre>
  </details>

  <details>
  <summary>dp</summary>
  <p> - 最小操作次数</p>
  <pre><code>	public static int superEggDrop2(int kChess, int nLevel) {
  		if (nLevel < 1 || kChess < 1) {
  			return 0;
  		}
  		if (kChess == 1) {
  			return nLevel;
  		}
  		int[][] dp = new int[nLevel + 1][kChess + 1];
  		for (int i = 1; i != dp.length; i++) {
  			dp[i][1] = i;
  		}
  		for (int i = 1; i != dp.length; i++) {
  			for (int j = 2; j != dp[0].length; j++) {
  				int min = Integer.MAX_VALUE;
  				for (int k = 1; k != i + 1; k++) {
  					min = Math.min(min, Math.max(dp[k - 1][j - 1], dp[i - k][j]));
  				}
  				dp[i][j] = min + 1;
  			}
  		}
  		return dp[nLevel][kChess];
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp优化</summary>
  <p> - 最小操作次数</p>
  <pre><code>public static int superEggDrop3(int kChess, int nLevel) {
  		if (nLevel < 1 || kChess < 1) {
  			return 0;
  		}
  		if (kChess == 1) {
  			return nLevel;
  		}
  		int[][] dp = new int[nLevel + 1][kChess + 1];
  		for (int i = 1; i != dp.length; i++) {
  			dp[i][1] = i;
  		}
  		int[][] best = new int[nLevel + 1][kChess + 1];
  		for (int i = 1; i != dp[0].length; i++) {
  			dp[1][i] = 1;
  			best[1][i] = 1;
  		}
  		for (int i = 2; i < nLevel + 1; i++) {
  			for (int j = kChess; j > 1; j--) {
  				int ans = Integer.MAX_VALUE;
  				int bestChoose = -1;
  				int down = best[i - 1][j];
  				int up = j == kChess ? i : best[i][j + 1];
  				for (int first = down; first <= up; first++) {
  					int cur = Math.max(dp[first - 1][j - 1], dp[i - first][j]);
  					if (cur <= ans) {
  						ans = cur;
  						bestChoose = first;
  					}
  				}
  				dp[i][j] = ans + 1;
  				best[i][j] = bestChoose;
  			}
  		}
  		return dp[nLevel][kChess];
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp一维</summary>
  <p> - 最小操作次数</p>
  <pre><code>public static int superEggDrop4(int kChess, int nLevel) {
  		if (nLevel < 1 || kChess < 1) {
  			return 0;
  		}
  		int[] dp = new int[kChess];
  		int res = 0;
  		while (true) {
  			res++;
  			int previous = 0;
  			for (int i = 0; i < dp.length; i++) {
  				int tmp = dp[i];
  				dp[i] = dp[i] + previous + 1;
  				previous = tmp;
  				if (dp[i] >= nLevel) {
  					return res;
  				}
  			}
  		}
  	}</code>  </pre>
  </details>
