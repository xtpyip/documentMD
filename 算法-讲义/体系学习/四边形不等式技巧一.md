# 四边形不等式技巧一

## 基本内容

- 区间划分问题中划分点不回退的现象

- 四边形不等式技巧特征

  > 1，两个可变参数的区间划分问题
  >
  > 2，每个格子有枚举行为
  >
  > 3，当两个可变参数固定一个，另一个参数和答案之间存在单调性关系
  >
  > 4，而且往往是反向单调关系
  >
  > 5，枚举加速的位置对:上+右，或者，左+下
  >
  > 6，不要证明!用对数器验证!
  >
  > 7，可以把时间复杂度降低一阶

- 四边形不等式技巧注意点

  > 1，不要证明!用对数器验证!
  >
  > 2，枚举的时候面对最优答案相等的时候怎么处理?都试试!
  >
  > 3，可以把时间复杂度降低一阶
  > O(N^3) -> O(N^2)
  >
  > O(N^2 * M)->O(N*M)
  >
  > O(N * M^2) -> O(N*M)
  >
  > 4，四边形不等式有些时候是最优解，有些时候不是不是的原因:尝试思路，在根儿上不够好

## 问题集合

### BestSplitForAll

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class41/Code01_BestSplitForAll.java">测试链接</a>

- 内容：

  > 在一个数组中，求此数组划分的两个子数组的最小值的最大值
  >
  > 即 ans = Max{min{a,b}}
  
- 思路：

  > 思路一：暴力计算(略)
  >
  > 思路二：总和辅助
  
- 代码：

  <details>
  <summary>使用和Sum辅助计算</summary>
  <p> - 最小值的最大值</p>
  <pre><code>public static int bestSplit2(int[] arr) {
  		if (arr == null || arr.length < 2) {
  			return 0;
  		}
  		int N = arr.length;
  		int sumAll = 0;
  		for (int num : arr) {
  			sumAll += num;
  		}
  		int ans = 0;
  		int sumL = 0;
  		// [0...s]  [s+1...N-1]
  		for (int s = 0; s < N - 1; s++) {
  			sumL += arr[s];
  			int sumR = sumAll - sumL;
  			ans = Math.max(ans, Math.min(sumL, sumR));
  		}
  		return ans;
  	}</code>  </pre>
  </details>

### BestSplitForEveryPosition

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class41/Code02_BestSplitForEveryPosition.java">测试链接</a>

- 内容：

  > 把**BestSplitForAll**中提到的，min{左部分累加和，右部分累加和}，定义为S(N-1)。
  >
  > 也就是说︰
  >
  > S(N-1)∶在arr[0…N-1]范围上，做最优划分所得到的min{左部分累加和，右部分累加和}的最大值
  >
  > 现在要求返回一个长度为N的s数组
  >
  > s[i]在arr[0…i]范围上，做最优划分所得到的min{左部分累加和，右部分累加和的最大值
  >
  > 得到整个s数组的过程,做到时间复杂度O(N)

- 思路：

  > 思路一：暴力计算(略)
  >
  > 思路二：总和辅助
  >
  > 思路三：dp优化 (划分点不回退)

- 代码：

  <details>
  <summary>使用总和辅助计算</summary>
  <p> - 每个位置的最小值的最大值</p>
  <pre><code>	public static int sum(int[] sum, int L, int R) {
  		return sum[R + 1] - sum[L];
  	}
  	public static int[] bestSplit2(int[] arr) {
  		if (arr == null || arr.length == 0) {
  			return new int[0];
  		}
  		int N = arr.length;
  		int[] ans = new int[N];
  		ans[0] = 0;
  		int[] sum = new int[N + 1];
  		for (int i = 0; i < N; i++) {
  			sum[i + 1] = sum[i] + arr[i];
  		}
  		for (int range = 1; range < N; range++) {
  			for (int s = 0; s < range; s++) {
  				int sumL = sum(sum, 0, s);
  				int sumR = sum(sum, s + 1, range);
  				ans[range] = Math.max(ans[range], Math.min(sumL, sumR));
  			}
  		}
  		return ans;
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp优化</summary>
  <p> - 每个位置的最小值的最大值</p>
  <pre><code>	public static int[] bestSplit3(int[] arr) {
  		if (arr == null || arr.length == 0) {
  			return new int[0];
  		}
  		int N = arr.length;
  		int[] ans = new int[N];
  		ans[0] = 0;
  		// arr =   {5, 3, 1, 3}
  		//          0  1  2  3
  		// sum ={0, 5, 8, 9, 12}
  		//       0  1  2  3   4
  		// 0~2 ->  sum[3] - sum[0]
  		// 1~3 ->  sum[4] - sum[1]
  		int[] sum = new int[N + 1];
  		for (int i = 0; i < N; i++) {
  			sum[i + 1] = sum[i] + arr[i];
  		}
  		// 最优划分
  		// 0~range-1上，最优划分是左部分[0~best]  右部分[best+1~range-1]
  		int best = 0;
  		for (int range = 1; range < N; range++) {
  			while (best + 1 < range) {
  				int before = Math.min(sum(sum, 0, best), sum(sum, best + 1, range));
  				int after = Math.min(sum(sum, 0, best + 1), sum(sum, best + 2, range));
  				// 注意，一定要是>=，只是>会出错
  				// 课上会讲解
  				if (after >= before) {
  					best++;
  				} else {
  					break;
  				}
  			}
  			ans[range] = Math.min(sum(sum, 0, best), sum(sum, best + 1, range));
  		}
  		return ans;
  	}</code>  </pre>
  </details>

### StoneMerge

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class41/Code03_StoneMerge.java">测试链接</a>

- 内容：

  > 摆放着n堆石子。
  >
  > 现要将石子有次序地合并成一堆
  >
  > 规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分
  >
  > 求出将n堆石子合并成一堆的最小得分(或最大得分)合并方案

- 思路：

  > 思路一：暴力递归
  >
  > 思路二：dp dp[i] [j]为从合并i~j的最小得分数
  >
  > 思路三：dp优化 (四边形不等式技巧)

- 代码：

  <details>
  <summary>暴力递归</summary>
  <p> - 合并成一堆的最小得分</p>
  <pre><code>	public static int[] sum(int[] arr) {
  		int N = arr.length;
  		int[] s = new int[N + 1];
  		s[0] = 0;
  		for (int i = 0; i < N; i++) {
  			s[i + 1] = s[i] + arr[i];
  		}
  		return s;
  	}
  	public static int w(int[] s, int l, int r) {
  		return s[r + 1] - s[l];
  	}
  	public static int min1(int[] arr) {
  		if (arr == null || arr.length < 2) {
  			return 0;
  		}
  		int N = arr.length;
  		int[] s = sum(arr);
  		return process1(0, N - 1, s);
  	}
  	public static int process1(int L, int R, int[] s) {
  		if (L == R) {
  			return 0;
  		}
  		int next = Integer.MAX_VALUE;
  		for (int leftEnd = L; leftEnd < R; leftEnd++) {
  			next = Math.min(next, process1(L, leftEnd, s) + process1(leftEnd + 1, R, s));
  		}
  		return next + w(s, L, R);
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp</summary>
  <p> - 最小得分合并方案</p>
  <pre><code>	public static int sum(int[] sum, int L, int R) {
  		return sum[R + 1] - sum[L];
  	}
  	public static int[] bestSplit2(int[] arr) {
  		if (arr == null || arr.length == 0) {
  			return new int[0];
  		}
  		int N = arr.length;
  		int[] ans = new int[N];
  		ans[0] = 0;
  		int[] sum = new int[N + 1];
  		for (int i = 0; i < N; i++) {
  			sum[i + 1] = sum[i] + arr[i];
  		}
  		for (int range = 1; range < N; range++) {
  			for (int s = 0; s < range; s++) {
  				int sumL = sum(sum, 0, s);
  				int sumR = sum(sum, s + 1, range);
  				ans[range] = Math.max(ans[range], Math.min(sumL, sumR));
  			}
  		}
  		return ans;
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp优化</summary>
  <p> - 最小得分合并方案</p>
  <pre><code>	public static int min3(int[] arr) {
  		if (arr == null || arr.length < 2) {
  			return 0;
  		}
  		int N = arr.length;
  		int[] s = sum(arr);
  		int[][] dp = new int[N][N];
  		int[][] best = new int[N][N];
  		for (int i = 0; i < N - 1; i++) {
  			best[i][i + 1] = i;
  			dp[i][i + 1] = w(s, i, i + 1);
  		}
  		for (int L = N - 3; L >= 0; L--) {
  			for (int R = L + 2; R < N; R++) {
  				int next = Integer.MAX_VALUE;
  				int choose = -1;
  				for (int leftEnd = best[L][R - 1]; leftEnd <= best[L + 1][R]; leftEnd++) {
  					int cur = dp[L][leftEnd] + dp[leftEnd + 1][R];
  					if (cur <= next) {
  						next = cur;
  						choose = leftEnd;
  					}
  				}
  				best[L][R] = choose;
  				dp[L][R] = next + w(s, L, R);
  			}
  		}
  		return dp[0][N - 1];
  	}</code>  </pre>
  </details>

### SplitArrayLargestSum

- 链接：<a href="https://leetcode.cn/problems/split-array-largest-sum/description/">测试链接</a>

- 内容：

  > 给定一个非负整数数组 `nums` 和一个整数 `k` ，你需要将这个数组分成 `k` 个非空的连续子数组。
  >
  > 设计一个算法使得这 `k` 个子数组各自和的最大值最小。
  >
  > **示例 1：**
  >
  > ```
  > 输入：nums = [7,2,5,10,8], k = 2
  > 输出：18
  > 解释：
  > 一共有四种方法将 nums 分割为 2 个子数组。 
  > 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。
  > 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：nums = [1,2,3,4,5], k = 2
  > 输出：9
  > ```
  >
  > **示例 3：**
  >
  > ```
  > 输入：nums = [1,4,4], k = 3
  > 输出：4
  > ```

- 思路：

  > 思路一：dp dp[i] [j]表示0~i区间使用j个来分割的子数组的最小最大值
  >
  > 思路二：dp优化 (四边形不等式技巧)
  >
  > 思路三：二分思想
  >
  > ​	如果arr数组为1,3,6,2,3,4,3,2
  >
  > ​	如果要arr必须要以4来划分，那么1,3为一个,6不能单独划分，所以4来划分不可能
  >
  > ​	如果要arr必须要以6来划分，那么1,3为一个,6一个,2,3一个,4一个,3,2一个,则k=5时的最小划分值为6
  >
  > ​	则如果用7，其k值一定<=用6的k值
  >
  > ​	可以对使用的数字划分这个参数进行二分，当且仅当当前这个数字的k值为所求，求其各个部分的max的最小

- 代码：

  <details>
  <summary>dp</summary>
  <p> - 分割的子数组的最小最大值</p>
  <pre><code>		// 求原数组arr[L...R]的累加和
  	public static int sum(int[] sum, int L, int R) {
  		return sum[R + 1] - sum[L];
  	}
  	// 不优化枚举的动态规划方法，O(N^2 * K)
  	public static int splitArray1(int[] nums, int K) {
  		int N = nums.length;
  		int[] sum = new int[N + 1];
  		for (int i = 0; i < N; i++) {
  			sum[i + 1] = sum[i] + nums[i];
  		}
  		int[][] dp = new int[N][K + 1];
  		for (int j = 1; j <= K; j++) {
  			dp[0][j] = nums[0];
  		}
  		for (int i = 1; i < N; i++) {
  			dp[i][1] = sum(sum, 0, i);
  		}
  		// 每一行从上往下
  		// 每一列从左往右
  		// 根本不去凑优化位置对儿！
  		for (int i = 1; i < N; i++) {
  			for (int j = 2; j <= K; j++) {
  				int ans = Integer.MAX_VALUE;
  				// 枚举是完全不优化的！
  				for (int leftEnd = 0; leftEnd <= i; leftEnd++) {
  					int leftCost = leftEnd == -1 ? 0 : dp[leftEnd][j - 1];
  					int rightCost = leftEnd == i ? 0 : sum(sum, leftEnd + 1, i);
  					int cur = Math.max(leftCost, rightCost);
  					if (cur < ans) {
  						ans = cur;
  					}
  				}
  				dp[i][j] = ans;
  			}
  		}
  		return dp[N - 1][K];
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp优化</summary>
  <p> - 分割的子数组的最小最大值</p>
  <pre><code>	public static int splitArray2(int[] nums, int K) {
  		int N = nums.length;
  		int[] sum = new int[N + 1];
  		for (int i = 0; i < N; i++) {
  			sum[i + 1] = sum[i] + nums[i];
  		}
  		int[][] dp = new int[N][K + 1];
  		int[][] best = new int[N][K + 1];
  		for (int j = 1; j <= K; j++) {
  			dp[0][j] = nums[0];
  			best[0][j] = -1;
  		}
  		for (int i = 1; i < N; i++) {
  			dp[i][1] = sum(sum, 0, i);
  			best[i][1] = -1;
  		}
  		// 从第2列开始，从左往右
  		// 每一列，从下往上
  		// 为什么这样的顺序？因为要去凑（左，下）优化位置对儿！
  		for (int j = 2; j <= K; j++) {
  			for (int i = N - 1; i >= 1; i--) {
  				int down = best[i][j - 1];
  				// 如果i==N-1，则不优化上限
  				int up = i == N - 1 ? N - 1 : best[i + 1][j];
  				int ans = Integer.MAX_VALUE;
  				int bestChoose = -1;
  				for (int leftEnd = down; leftEnd <= up; leftEnd++) {
  					int leftCost = leftEnd == -1 ? 0 : dp[leftEnd][j - 1];
  					int rightCost = leftEnd == i ? 0 : sum(sum, leftEnd + 1, i);
  					int cur = Math.max(leftCost, rightCost);
  					// 注意下面的if一定是 < 课上的错误就是此处！当时写的 <= ！
  					// 也就是说，只有取得明显的好处才移动！
  					// 举个例子来说明，比如[2,6,4,4]，3个画匠时候，如下两种方案都是最优:
  					// (2,6) (4) 两个画匠负责 | (4) 最后一个画匠负责
  					// (2,6) (4,4)两个画匠负责 | 最后一个画匠什么也不负责
  					// 第一种方案划分为，[0~2] [3~3]
  					// 第二种方案划分为，[0~3] [无]
  					// 两种方案的答案都是8，但是划分点位置一定不要移动!
  					// 只有明显取得好处时(<)，划分点位置才移动!
  					// 也就是说后面的方案如果==前面的最优，不要移动！只有优于前面的最优，才移动
  					// 比如上面的两个方案，如果你移动到了方案二，你会得到:
  					// [2,6,4,4] 三个画匠时，最优为[0~3](前两个画家) [无](最后一个画家)，
  					// 最优划分点为3位置(best[3][3])
  					// 那么当4个画匠时，也就是求解dp[3][4]时
  					// 因为best[3][3] = 3，这个值提供了dp[3][4]的下限
  					// 而事实上dp[3][4]的最优划分为:
  					// [0~2]（三个画家处理） [3~3] (一个画家处理)，此时最优解为6
  					// 所以，你就得不到dp[3][4]的最优解了，因为划分点已经越过2了
  					// 提供了对数器验证，你可以改成<=，对数器和leetcode都过不了
  					// 这里是<，对数器和leetcode都能通过
  					// 这里面会让同学们感到困惑的点：
  					// 为啥==的时候，不移动，只有<的时候，才移动呢？例子懂了，但是道理何在？
  					// 哈哈哈哈哈，看了邮局选址问题，你更懵，请看42节！
  					if (cur < ans) {
  						ans = cur;
  						bestChoose = leftEnd;
  					}
  				}
  				dp[i][j] = ans;
  				best[i][j] = bestChoose;
  			}
  		}
  		return dp[N - 1][K];
  	}</code>  </pre>
  </details>

  <details>
  <summary>二分思想</summary>
  <p> - 分割的子数组的最小最大值</p>
  <pre><code>	public static int splitArray3(int[] nums, int M) {
  		long sum = 0;
  		for (int i = 0; i < nums.length; i++) {
  			sum += nums[i];
  		}
  		long l = 0;
  		long r = sum;
  		long ans = 0;
  		while (l <= r) {
  			long mid = (l + r) / 2;
  			long cur = getNeedParts(nums, mid);
  			if (cur <= M) {
  				ans = mid;
  				r = mid - 1;
  			} else {
  				l = mid + 1;
  			}
  		}
  		return (int) ans;
  	}
  	public static int getNeedParts(int[] arr, long aim) {
  		for (int i = 0; i < arr.length; i++) {
  			if (arr[i] > aim) {
  				return Integer.MAX_VALUE;
  			}
  		}
  		int parts = 1;
  		int all = arr[0];
  		for (int i = 1; i < arr.length; i++) {
  			if (all + arr[i] > aim) {
  				parts++;
  				all = arr[i];
  			} else {
  				all += arr[i];
  			}
  		}
  		return parts;
  	}</code>  </pre>
  </details>
