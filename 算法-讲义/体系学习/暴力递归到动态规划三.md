# 暴力递归到动态规划三

## 基本内容

- 暴力递归就是尝试

  > 1，把问题转化为规模缩小了的同类问题的子问题
  >
  > 2，有明确的不需要继续进行递归的条件(base case)
  >
  > 3，有当得到了子问题的结果之后的决策过程
  >
  > 4，不记录每一个子问题的解

- 动态规划

  > 动态规划（Dynamic Programming,DP）算法通常用于求解某种具有最优性质的问题。在这类问题中，可能会有许多可行解，每一个解都对应一个值，我们希望找到具有最优值的解。
  > 动态规划算法与分治法类似，其基本思想也是将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解中 得到原有问题的解。与分治法不同的是，动态规划经分解后得到的**子问题往往不是相互独立的。**

- 暴力递归与动态规划的关系

  > 递归包含了含有**重复子问题的递归**与**不含有重复子问题的递归**
  >
  > **动态规划**只与**重复子问题的递归**有关系
  >
  > **所有动态规划问题全部可以由递归实现，但只有含有重复子问题的递归才能由动态规划实现。**

- 怎么尝试—件事?

  > 1）有经验但是没有方法论?
  >
  > 2）怎么判断一个尝试就是最优尝试?
  >
  > 3）难道尝试这件事真的只能拼天赋?那我咋搞定我的面试?
  >
  > 4）动态规划是啥?好高端的样子哦…可是我不会啊!和尝试有什么关系?

- 什么暴力递归可以继续优化?

  > 有**重复调用**同一个子问题的解，这种递归可以优化
  >
  > 如果每一个子问题都是不同的解，无法优化也不用优化

- 面试题和动态规划的关系

  > 解决一个问题，可能有很多尝试方法
  >
  > 可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式
  >
  > **一个问题可能有若干种动态规划的解法**

- 如何找到某个问题的动态规划方式?

  > 1）设计暴力递归∶重要原则+4种常见尝试模型!重点!
  >
  > 2）分析有没有重复解︰套路解决
  >
  > 3）用记忆化搜索->用严格表结构实现动态规划∶套路解决
  >
  > 4）看看能否继续优化∶套路解决

- 面试中设计暴力递归过程的原则

  > 1）每一个可变参数的类型，一定不要比int类型更加复杂
  >
  > 2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数
  >
  > 3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可
  >
  > 4）可变参数的个数，能少则少

- 知道了面试中设计暴力递归过程的原则，然后呢?

  > 一定要逼自己找到不违反原则情况下的暴力尝试!
  >
  > 如果你找到的暴力尝试，不符合原则，马上舍弃!找新的!
  >
  > 如果某个题目突破了设计原则，一定极难极难，面试中出现**概率低于5%** !

- 常见的4种尝试模型

  > 1）从左往右的尝试模型
  >
  > 2）范围上的尝试模型
  >
  > 3）多样本位置全对应的尝试模型
  >
  > 4）寻找业务限制的尝试模型

- 如何分析有没有重复解

  > 列出调用过程，可以只列出前几层
  >
  > 有没有重复解，一看便知

- 暴力递归到动态规划的套路

  > 1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用
  >
  > 2）找到哪些参数的变化会影响返回值，对每一个列出变化范围
  >
  > 3）参数间的所有的组合数量，意味着表大小
  >
  > 4）记忆化搜索的方法就是傻缓存，非常容易得到
  >
  > 5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解
  >
  > 6）对于有枚举行为的决策过程，进一步优化

- 动态规划的进一步优化

  > 1）空间压缩
  >
  > 2）状态化简
  >
  > 3）四边形不等式
  >
  > 4）其他优化技巧

## 问题集合

### PalindromeSubsequence

- 链接：<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">测试链接</a>

- 内容：

  > 给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。
  >
  > 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
  >
  > **示例 1：**
  >
  > ```
  > 输入：s = "bbbab"
  > 输出：4
  > 解释：一个可能的最长回文子序列为 "bbbb" 。
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：s = "cbbd"
  > 输出：2
  > 解释：一个可能的最长回文子序列为 "bb" 。
  > ```

- 思路：

  > 递归 
  >
  > dp
  >
  > 逆序最长公共子序列 求最长回文子序列等价于求其与其逆序串的最长公共子序列的长度

- 代码：

  <details>
  <summary>递归</summary>
  <p> - 获取长度</p>
  <pre><code>    public static int lpsl1(String s) {
          if (s == null || s.length() == 0) {
              return 0;
          }
          char[] str = s.toCharArray();
          return f(str, 0, str.length - 1);
      }
      // str[L..R]最长回文子序列长度返回
      public static int f(char[] str, int L, int R) {
          if (L == R) {
              return 1;
          }
          if (L == R - 1) {
              return str[L] == str[R] ? 2 : 1;
          }
          int p1 = f(str, L + 1, R - 1);
          int p2 = f(str, L, R - 1);
          int p3 = f(str, L + 1, R);
          int p4 = str[L] != str[R] ? 0 : (2 + f(str, L + 1, R - 1));
          return Math.max(Math.max(p1, p2), Math.max(p3, p4));
      }</code>  </pre>
  </details>

  <details>
  <summary>dp</summary>
  <p> - 获取长度</p>
  <pre><code> public static int lpsl2(String s) {
          if (s == null || s.length() == 0) {
              return 0;
          }
          char[] str = s.toCharArray();
          int N = str.length;
          int[][] dp = new int[N][N];
          dp[N - 1][N - 1] = 1;
          for (int i = 0; i < N - 1; i++) {
              dp[i][i] = 1;
              dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;
          }
          for (int L = N - 3; L >= 0; L--) {
              for (int R = L + 2; R < N; R++) {
                  dp[L][R] = Math.max(dp[L][R - 1], dp[L + 1][R]);
                  if (str[L] == str[R]) {
                      dp[L][R] = Math.max(dp[L][R], 2 + dp[L + 1][R - 1]);
                  }
              }
          }
          return dp[0][N - 1];
      }</code>  </pre>
  </details>

  <details>
  <summary>逆序最长公共子序列</summary>
  <p> - 获取长度</p>
  <pre><code> public static int longestPalindromeSubseq1(String s) {
          if (s == null || s.length() == 0) {
              return 0;
          }
          if (s.length() == 1) {
              return 1;
          }
          char[] str = s.toCharArray();
          char[] reverse = reverse(str);
          return longestCommonSubsequence(str, reverse);
      }
      public static char[] reverse(char[] str) {
          int N = str.length;
          char[] reverse = new char[str.length];
          for (int i = 0; i < str.length; i++) {
              reverse[--N] = str[i];
          }
          return reverse;
      }
      public static int longestCommonSubsequence(char[] str1, char[] str2) {
          int N = str1.length;
          int M = str2.length;
          int[][] dp = new int[N][M];
          dp[0][0] = str1[0] == str2[0] ? 1 : 0;
          for (int i = 1; i < N; i++) {
              dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0];
          }
          for (int j = 1; j < M; j++) {
              dp[0][j] = str1[0] == str2[j] ? 1 : dp[0][j - 1];
          }
          for (int i = 1; i < N; i++) {
              for (int j = 1; j < M; j++) {
                  dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                  if (str1[i] == str2[j]) {
                      dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);
                  }
              }
          }
          return dp[N - 1][M - 1];
      }</code>  </pre>
  </details>

### HorseJump

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class20/Code02_HorseJump.java">测试链接</a>

- 内容：

  > 自行搜索或者想象一个象棋的棋盘，然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置
  >
  > 那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域
  >
  > 给你三个参数x, y, k
  >
  > 返回“马”从(0,0)位置出发，必须走k步最后落在(x,y)上的方法数有多少种?

- 思路：

  > 递归 
  >
  > dp

- 代码：

  <details>
  <summary>递归</summary>
  <p> - 获取种类</p>
  <pre><code>// 当前来到的位置是（x,y）
      // 还剩下rest步需要跳
      // 跳完rest步，正好跳到a，b的方法数是多少？
      // 10 * 9
      public static int jump(int a, int b, int k) {
          return process(0, 0, k, a, b);
      }
      public static int process(int x, int y, int rest, int a, int b) {
          if (x < 0 || x > 9 || y < 0 || y > 8) {
              return 0;
          }
          if (rest == 0) {
              return (x == a && y == b) ? 1 : 0;
          }
          int ways = process(x + 2, y + 1, rest - 1, a, b);
          ways += process(x + 1, y + 2, rest - 1, a, b);
          ways += process(x - 1, y + 2, rest - 1, a, b);
          ways += process(x - 2, y + 1, rest - 1, a, b);
          ways += process(x - 2, y - 1, rest - 1, a, b);
          ways += process(x - 1, y - 2, rest - 1, a, b);
          ways += process(x + 1, y - 2, rest - 1, a, b);
          ways += process(x + 2, y - 1, rest - 1, a, b);
          return ways;
      }</code>  </pre>
  </details>

  <details>
  <summary>dp</summary>
  <p> - 获取种类</p>
  <pre><code>public static int dp(int a, int b, int k) {
          int[][][] dp = new int[10][9][k + 1];
          dp[a][b][0] = 1;
          for (int rest = 1; rest <= k; rest++) {
              for (int x = 0; x < 10; x++) {
                  for (int y = 0; y < 9; y++) {
                      int ways = pick(dp, x + 2, y + 1, rest - 1);
                      ways += pick(dp, x + 1, y + 2, rest - 1);
                      ways += pick(dp, x - 1, y + 2, rest - 1);
                      ways += pick(dp, x - 2, y + 1, rest - 1);
                      ways += pick(dp, x - 2, y - 1, rest - 1);
                      ways += pick(dp, x - 1, y - 2, rest - 1);
                      ways += pick(dp, x + 1, y - 2, rest - 1);
                      ways += pick(dp, x + 2, y - 1, rest - 1);
                      dp[x][y][rest] = ways;
                  }
              }
          }
          return dp[0][0][k];
      }</code>  </pre>
  </details>

### Coffee

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class20/Code03_Coffee.java">测试链接</a>

- 内容：

  > 给定一个数组arr,arr[i]]代表第i号咖啡机泡一杯咖啡的时间
  >
  > 给定一个正数N，表示N个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯
  >
  > 每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发
  >
  > 假设所有人拿到咖啡之后立刻喝干净，返回从开始等到所有咖啡机变干净的最短时间
  >
  > 三个参数:int[] arr、int N, int a、int b。。

- 思路：

  > 暴力递归 略
  >
  > 递归 + 贪心
  >
  > dp

- 代码：

  <details>
  <summary>递归+贪心</summary>
  <p> - 最短时间</p>
  <pre><code> // 以下为贪心+优良暴力
      public static class Machine {
          public int timePoint;
          public int workTime;
          public Machine(int t, int w) {
              timePoint = t;
              workTime = w;
          }
      }
      public static class MachineComparator implements Comparator<Machine> {
          @Override
          public int compare(Machine o1, Machine o2) {
              return (o1.timePoint + o1.workTime) - (o2.timePoint + o2.workTime);
          }
      }
      // 优良一点的暴力尝试的方法
      public static int minTime1(int[] arr, int n, int a, int b) {
          PriorityQueue<Machine> heap = new PriorityQueue<Machine>(new MachineComparator());
          for (int i = 0; i < arr.length; i++) {
              heap.add(new Machine(0, arr[i]));
          }
          int[] drinks = new int[n];
          for (int i = 0; i < n; i++) {
              Machine cur = heap.poll();
              cur.timePoint += cur.workTime;
              drinks[i] = cur.timePoint;
              heap.add(cur);
          }
          return bestTime(drinks, a, b, 0, 0);
      }
      // drinks 所有杯子可以开始洗的时间
      // wash 单杯洗干净的时间（串行）
      // air 挥发干净的时间(并行)
      // free 洗的机器什么时候可用
      // drinks[index.....]都变干净，最早的结束时间（返回）
      public static int bestTime(int[] drinks, int wash, int air, int index, int free) {
          if (index == drinks.length) {
              return 0;
          }
          // index号杯子 决定洗
          int selfClean1 = Math.max(drinks[index], free) + wash;
          int restClean1 = bestTime(drinks, wash, air, index + 1, selfClean1);
          int p1 = Math.max(selfClean1, restClean1);
          // index号杯子 决定挥发
          int selfClean2 = drinks[index] + air;
          int restClean2 = bestTime(drinks, wash, air, index + 1, free);
          int p2 = Math.max(selfClean2, restClean2);
          return Math.min(p1, p2);
      }</code>  </pre>
  </details>
  
  <details>
  <summary>dp</summary>
  <p> - 获取最短时间</p>
  <pre><code>// 贪心+优良尝试改成动态规划
      public static int minTime2(int[] arr, int n, int a, int b) {
          PriorityQueue<Machine> heap = new PriorityQueue<Machine>(new MachineComparator());
          for (int i = 0; i < arr.length; i++) {
              heap.add(new Machine(0, arr[i]));
          }
          int[] drinks = new int[n];
          for (int i = 0; i < n; i++) {
              Machine cur = heap.poll();
              cur.timePoint += cur.workTime;
              drinks[i] = cur.timePoint;
              heap.add(cur);
          }
          return bestTimeDp(drinks, a, b);
      }
      public static int bestTimeDp(int[] drinks, int wash, int air) {
          int N = drinks.length;
          int maxFree = 0;
          for (int i = 0; i < drinks.length; i++) {
              maxFree = Math.max(maxFree, drinks[i]) + wash;
          }
          int[][] dp = new int[N + 1][maxFree + 1];
          for (int index = N - 1; index >= 0; index--) {
              for (int free = 0; free <= maxFree; free++) {
                  int selfClean1 = Math.max(drinks[index], free) + wash;
                  if (selfClean1 > maxFree) {
                      break; // 因为后面的也都不用填了
                  }
                  // index号杯子 决定洗
                  int restClean1 = dp[index + 1][selfClean1];
                  int p1 = Math.max(selfClean1, restClean1);
                  // index号杯子 决定挥发
                  int selfClean2 = drinks[index] + air;
                  int restClean2 = dp[index + 1][free];
                  int p2 = Math.max(selfClean2, restClean2);
                  dp[index][free] = Math.min(p1, p2);
              }
          }
          return dp[0][0];
      }</code>  </pre>
  </details>