# 单调栈

## 基本内容

- 什么是单调栈？

  > 从名字上就听的出来，单调栈中存放的数据应该是有序的，所以单调栈也分为**单调递增栈**和**单调递减栈**

  - 单调递增栈：单调递增栈就是从栈底到栈顶数据是从大到小
  - 单调递减栈：单调递减栈就是从栈底到栈顶数据是从小到大


## 问题集合

### MonotonousStack

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class25/Code01_MonotonousStack.java">测试链接</a>

- 内容：

  > 实现一个单调栈
  >
  > ```java
  >     // arr = [ 3, 1, 2, 3]
  >     //         0  1  2  3
  >     //  [
  >     //     0 : [-1,  1]
  >     //     1 : [-1, -1]
  >     //     2 : [ 1, -1]
  >     //     3 : [ 2, -1]
  >     //  ]
  > ```

- 思路：

  > 实现无重复数据的单调栈
  >
  > 实现有重复数据的单调栈
  
- 代码：

  <details>
  <summary>无重复数据单调栈</summary>
  <p> - 单调栈</p>
  <pre><code>	public static int[][] getNearLessNoRepeat(int[] arr) {  // 无重复数据的单调栈
          // res[i][0]为 > arr[i] 的左侧下标，不存在则为-1
          // res[i][1]为 > arr[i] 的右侧下标，不存在则为-1
          int[][] res = new int[arr.length][2];
          // 存储下标
          Stack<Integer> stack = new Stack<Integer>();
          for (int i = 0; i < arr.length; i++) {
              while (!stack.isEmpty() && arr[stack.peek()] > arr[i]){
                  Integer index = stack.pop();
                  res[index][0] = stack.isEmpty() ? -1 : stack.peek();
                  res[index][1] = i;
              }
              stack.push(i);
          }
          // 还有元素未出栈,则剩余的元素的右全为-1
          while (!stack.isEmpty()) {
              Integer cur = stack.pop();
              res[cur][0] = stack.isEmpty() ? -1 : stack.peek();
              res[cur][1] = -1;
          }
          return res;
      }</code>  </pre>
  </details>
  
  <details>
  <summary>重复数据单调栈</summary>
  <p> - 单调栈</p>
  <pre><code>	// 存在重复值时
      public static int[][] getNearLess(int[] arr) {
          int[][] res = new int[arr.length][2];
          Stack<List<Integer>> stack = new Stack<>();
          for (int i = 0; i < arr.length; i++) {
              while (!stack.isEmpty() && arr[stack.peek().get(0)] > arr[i]) {
                  List<Integer> popValue = stack.pop();
                  for (int j = 0; j < popValue.size(); j++) {
                      Integer index = popValue.get(j);
                      res[index][0] = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size()-1);
                      res[index][1] = i;
                  }
              }
              if(!stack.isEmpty() && arr[i] == arr[stack.peek().get(0)]){
                  stack.peek().add(i);
              }else{
                  ArrayList<Integer> next = new ArrayList<>();
                  next.add(i);
                  stack.push(next);
              }
          }
          while (!stack.isEmpty()) {
              List<Integer> popValue = stack.pop();
              for (int j = 0; j < popValue.size(); j++) {
                  Integer index = popValue.get(j);
                  res[index][0] = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size()-1);
                  res[index][1] = -1;
              }
          }
          return res;
      }</code>  </pre>
  </details>

### AllTimesMinToMax

- 链接：<a href="https://leetcode.cn/problems/maximum-subarray-min-product/description/">测试链接</a>

- 内容：

  > 一个数组的 **最小乘积** 定义为这个数组中 **最小值** **乘以** 数组的 **和** 。
  >
  > - 比方说，数组 `[3,2,5]` （最小值是 `2`）的最小乘积为 `2 * (3+2+5) = 2 * 10 = 20` 。
  >
  > 给你一个正整数数组 `nums` ，请你返回 `nums` 任意 **非空子数组** 的**最小乘积** 的 **最大值** 。由于答案可能很大，请你返回答案对 `109 + 7` **取余** 的结果。
  >
  > 请注意，最小乘积的最大值考虑的是取余操作 **之前** 的结果。题目保证最小乘积的最大值在 **不取余** 的情况下可以用 **64 位有符号整数** 保存。
  >
  > **子数组** 定义为一个数组的 **连续** 部分。
  >
  > **示例 1：**
  >
  > ```
  > 输入：nums = [1,2,3,2]
  > 输出：14
  > 解释：最小乘积的最大值由子数组 [2,3,2] （最小值是 2）得到。
  > 2 * (2+3+2) = 2 * 7 = 14 。
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：nums = [2,3,3,1,2]
  > 输出：18
  > 解释：最小乘积的最大值由子数组 [3,3] （最小值是 3）得到。
  > 3 * (3+3) = 3 * 6 = 18 。
  > ```
  >
  > **示例 3：**
  >
  > ```
  > 输入：nums = [3,1,5,6,4,2]
  > 输出：60
  > 解释：最小乘积的最大值由子数组 [5,6,4] （最小值是 4）得到。
  > 4 * (5+6+4) = 4 * 15 = 60 。
  > ```

- 思路：

  > 思路一：暴力尝试 
  >
  > 思路二：单调栈（stack实现）
  >
  > 思路三：单调栈（数组实现）

- 代码：

  <details>
  <summary>暴力尝试</summary>
  <p> - 最小乘积的最大值</p>
  <pre><code>	public static int max1(int[] arr) {
  		int max = Integer.MIN_VALUE;
  		for (int i = 0; i < arr.length; i++) {
  			for (int j = i; j < arr.length; j++) {
  				int minNum = Integer.MAX_VALUE;
  				int sum = 0;
  				for (int k = i; k <= j; k++) {
  					sum += arr[k];
  					minNum = Math.min(minNum, arr[k]);
  				}
  				max = Math.max(max, minNum * sum);
  			}
  		}
  		return max;
  	}</code>  </pre>
  </details>

  <details>
  <summary>单调栈stack</summary>
  <p> - 最小乘积的最大值</p>
  <pre><code>// 当值出栈时，我们可以得到其左右边界，及以此为最小值的最大范围
  	public static int max2(int[] arr) {
  		int ans = Integer.MIN_VALUE, n = arr.length;
  		int[] help = new int[n];
  		help[0] = arr[0];
  		for (int i = 1; i < n; i++) {
  			help[i] += help[i-1] + arr[i];
  		}
  		Stack<Integer> indexStack = new Stack<>();
  		for (int i = 0; i < n; i++) {
  			while (!indexStack.isEmpty() && arr[indexStack.peek()] >= arr[i]){
  				Integer j = indexStack.pop();
  				ans = Math.max(ans,(indexStack.isEmpty() ? help[i-1] : help[i-1] - help[indexStack.peek()]) * arr[j]);
  			}
  			indexStack.push(i);
  		}
  		while(!indexStack.isEmpty()){
  			Integer j = indexStack.pop();
  			ans = Math.max(ans,(indexStack.isEmpty() ? help[n-1] : help[n-1] - help[indexStack.peek()]) * arr[j]);
  		}
  		return ans;
  	}</code>  </pre>
  </details>

  <details>
  <summary>单调栈arr</summary>
  <p> - 最小乘积的最大值</p>
  <pre><code>public static int maxSumMinProduct(int[] arr) {
  		int size = arr.length;
  		long[] sums = new long[size];
  		sums[0] = arr[0];
  		for (int i = 1; i < size; i++) {
  			sums[i] = sums[i - 1] + arr[i];
  		}
  		long max = Long.MIN_VALUE;
  		int[] stack = new int[size];
  		int stackSize = 0;
  		for (int i = 0; i < size; i++) {
  			while (stackSize != 0 && arr[stack[stackSize - 1]] >= arr[i]) {
  				int j = stack[--stackSize];
  				max = Math.max(max,
  						(stackSize == 0 ? sums[i - 1] : (sums[i - 1] - sums[stack[stackSize - 1]])) * arr[j]);
  			}
  			stack[stackSize++] = i;
  		}
  		while (stackSize != 0) {
  			int j = stack[--stackSize];
  			max = Math.max(max,
  					(stackSize == 0 ? sums[size - 1] : (sums[size - 1] - sums[stack[stackSize - 1]])) * arr[j]);
  		}
  		return (int) (max % 1000000007);
  	}</code>  </pre>
  </details>

### LargestRectangleInHistogram

- 链接：<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">测试链接</a>

- 内容：

  > 给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
  >
  > 求在该柱状图中，能够勾勒出来的矩形的最大面积。
  >
  > **示例 1:**
  >
  > ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)
  >
  > ```
  > 输入：heights = [2,1,5,6,2,3]
  > 输出：10
  > 解释：最大的矩形为图中红色区域，面积为 10
  > ```
  >
  > **示例 2：**
  >
  > ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)
  >
  > ```
  > 输入： heights = [2,4]
  > 输出： 4
  > ```

- 思路：

  > 思路一：单调栈（stack实现）
  >
  > 思路二：单调栈（数组实现）

- 代码：

  <details>
  <summary>单调栈stack</summary>
  <p> - 矩形的最大面积</p>
  <pre><code>	public static int largestRectangleArea1(int[] height) {
  		if (height == null || height.length == 0) {
  			return 0;
  		}
  		int maxArea = 0;
  		Stack<Integer> stack = new Stack<Integer>();
  		for (int i = 0; i < height.length; i++) {
  			while (!stack.isEmpty() && height[i] <= height[stack.peek()]) {
  				int j = stack.pop();
  				int k = stack.isEmpty() ? -1 : stack.peek();
  				int curArea = (i - k - 1) * height[j];
  				maxArea = Math.max(maxArea, curArea);
  			}
  			stack.push(i);
  		}
  		while (!stack.isEmpty()) {
  			int j = stack.pop();
  			int k = stack.isEmpty() ? -1 : stack.peek();
  			int curArea = (height.length - k - 1) * height[j];
  			maxArea = Math.max(maxArea, curArea);
  		}
  		return maxArea;
  	}</code>  </pre>
  </details>

  <details>
  <summary>单调栈arr</summary>
  <p> - 矩形的最大面积</p>
  <pre><code>public static int largestRectangleArea2(int[] height) {
  		if (height == null || height.length == 0) {
  			return 0;
  		}
  		int N = height.length;
  		int[] stack = new int[N];
  		int si = -1;
  		int maxArea = 0;
  		for (int i = 0; i < height.length; i++) {
  			while (si != -1 && height[i] <= height[stack[si]]) {
  				int j = stack[si--];
  				int k = si == -1 ? -1 : stack[si];
  				int curArea = (i - k - 1) * height[j];
  				maxArea = Math.max(maxArea, curArea);
  			}
  			stack[++si] = i;
  		}
  		while (si != -1) {
  			int j = stack[si--];
  			int k = si == -1 ? -1 : stack[si];
  			int curArea = (height.length - k - 1) * height[j];
  			maxArea = Math.max(maxArea, curArea);
  		}
  		return maxArea;
  	}</code>  </pre>
  </details>

### MaximalRectangle

- 链接：<a href="https://leetcode.cn/problems/maximal-rectangle/description/">测试链接</a>

- 内容：

  > 给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。
  >
  > **示例 1：**
  >
  > ![img](https://pic.leetcode.cn/1722912576-boIxpm-image.png)
  >
  > ```
  > 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
  > 输出：6
  > 解释：最大矩形如上图所示。
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：matrix = [["0"]]
  > 输出：0
  > ```
  >
  > **示例 3：**
  >
  > ```
  > 输入：matrix = [["1"]]
  > 输出：1
  > ```

- 思路：

  > 单调栈+迭代实现

- 代码：

  <details>
  <summary>单调栈+迭代实现</summary>
  <p> - 矩形的最大面积</p>
  <pre><code>public static int maximalRectangle(char[][] map) {
  		if (map == null || map.length == 0 || map[0].length == 0) return 0;
  		int maxArea = 0;
  		int m = map.length,n = map[0].length;
  		int[] height = new int[n];
  		for (int i = 0; i < m; i++) {
  			for (int j = 0; j < n; j++) {
  				height[j] = map[i][j] == '0' ? 0 : height[j] + 1;
  			}
  		    maxArea = Math.max(maxRecFromBottom(height),maxArea);
  		}
  		return maxArea;
  	}
  	// height是正方图数组
  	public static int maxRecFromBottom(int[] height) {
  		if (height == null || height.length == 0) {
  			return 0;
  		}
  		int maxArea = 0;
  		Stack<Integer> stack = new Stack<Integer>();
  		for (int i = 0; i < height.length; i++) {
  			while (!stack.isEmpty() && height[i] <= height[stack.peek()]) {
  				int j = stack.pop();
  				int k = stack.isEmpty() ? -1 : stack.peek();
  				int curArea = (i - k - 1) * height[j];
  				maxArea = Math.max(maxArea, curArea);
  			}
  			stack.push(i);
  		}
  		while (!stack.isEmpty()) {
  			int j = stack.pop();
  			int k = stack.isEmpty() ? -1 : stack.peek();
  			int curArea = (height.length - k - 1) * height[j];
  			maxArea = Math.max(maxArea, curArea);
  		}
  		return maxArea;
  	}</code>  </pre>
  </details>

### CountSubmatricesWithAllOnes

- 链接：<a href="https://leetcode.cn/problems/count-submatrices-with-all-ones/description/">测试链接</a>

- 内容：

  > 给你一个 `m x n` 的二进制矩阵 `mat` ，请你返回有多少个 **子矩形** 的元素全部都是 1 。
  >
  >  
  >
  > **示例 1：**
  >
  > ![img](https://assets.leetcode.com/uploads/2021/10/27/ones1-grid.jpg)
  >
  > ```
  > 输入：mat = [[1,0,1],[1,1,0],[1,1,0]]
  > 输出：13
  > 解释：
  > 有 6 个 1x1 的矩形。
  > 有 2 个 1x2 的矩形。
  > 有 3 个 2x1 的矩形。
  > 有 1 个 2x2 的矩形。
  > 有 1 个 3x1 的矩形。
  > 矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13 。
  > ```
  >
  > **示例 2：**
  >
  > ![img](https://assets.leetcode.com/uploads/2021/10/27/ones2-grid.jpg)
  >
  > ```
  > 输入：mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]
  > 输出：24
  > 解释：
  > 有 8 个 1x1 的子矩形。
  > 有 5 个 1x2 的子矩形。
  > 有 2 个 1x3 的子矩形。
  > 有 4 个 2x1 的子矩形。
  > 有 2 个 2x2 的子矩形。
  > 有 2 个 3x1 的子矩形。
  > 有 1 个 3x2 的子矩形。
  > 矩形数目总共 = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24 。
  > ```

- 思路：

  > 单调栈+迭代实现，同**MaximalRectangle**

- 代码：

  <details>
  <summary>单调栈+迭代实现</summary>
  <p> - 子矩阵的数量</p>
  <pre><code>public static int numSubmat(int[][] mat) {
  		if (mat == null || mat.length == 0 || mat[0].length == 0) {
  			return 0;
  		}
  		int nums = 0;
  		int[] height = new int[mat[0].length];
  		for (int i = 0; i < mat.length; i++) {
  			for (int j = 0; j < mat[0].length; j++) {
  				height[j] = mat[i][j] == 0 ? 0 : height[j] + 1;
  			}
  			nums += countFromBottom(height);
  		}
  		return nums;

  	}
  	// 比如
  	//              1
  	//              1
  	//              1         1
  	//    1         1         1
  	//    1         1         1
  	//    1         1         1
  	//             
  	//    2  ....   6   ....  9
  	// 如上图，假设在6位置，1的高度为6
  	// 在6位置的左边，离6位置最近、且小于高度6的位置是2，2位置的高度是3
  	// 在6位置的右边，离6位置最近、且小于高度6的位置是9，9位置的高度是4
  	// 此时我们求什么？
  	// 1) 求在3~8范围上，必须以高度6作为高的矩形，有几个？
  	// 2) 求在3~8范围上，必须以高度5作为高的矩形，有几个？
  	// 也就是说，<=4的高度，一律不求
  	// 那么，1) 求必须以位置6的高度6作为高的矩形，有几个？
  	// 3..3  3..4  3..5  3..6  3..7  3..8
  	// 4..4  4..5  4..6  4..7  4..8
  	// 5..5  5..6  5..7  5..8
  	// 6..6  6..7  6..8
  	// 7..7  7..8
  	// 8..8
  	// 这么多！= 21 = (9 - 2 - 1) * (9 - 2) / 2
  	// 这就是任何一个数字从栈里弹出的时候，计算矩形数量的方式
  	public static int countFromBottom(int[] height) {
  		if (height == null || height.length == 0) {
  			return 0;
  		}
  		int nums = 0;
  		int[] stack = new int[height.length];
  		int si = -1;
  		for (int i = 0; i < height.length; i++) {
  			while (si != -1 && height[stack[si]] >= height[i]) {
  				int cur = stack[si--];
  				if (height[cur] > height[i]) {
  					int left = si == -1 ? -1 : stack[si];
  					int n = i - left - 1;
  					int down = Math.max(left == -1 ? 0 : height[left], height[i]);
  					nums += (height[cur] - down) * num(n);
  				}
  	
  			}
  			stack[++si] = i;
  		}
  		while (si != -1) {
  			int cur = stack[si--];
  			int left = si == -1  ? -1 : stack[si];
  			int n = height.length - left - 1;
  			int down = left == -1 ? 0 : height[left];
  			nums += (height[cur] - down) * num(n);
  		}
  		return nums;
  	}
  	public static int num(int n) {
  		return ((n * (1 + n)) >> 1);
  	}</code>  </pre>
  </details>