# 二叉树基本算法上

## 基本内容

- 二叉树

  >  二叉树是每个节点最多有两个子树的树结构。
  >
  > 它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；活着左、右子树。

- 二叉树的性质

  > 性质1：二叉树第i层上的节点数目最多为 2{i-1} (i≥1)。
  >    
  >    性质2：深度为k的二叉树至多有2{k}-1个节点（k>=1）。
  >    
  >    性质3：包含n个节点的二叉树的高度至少为log2 (n+1)。
  > 
  >性质4：在任意一颗二叉树中，若终端节点的个数为n0，度为2的节点数为n2，则n0=n2+1。



## 问题集合

### FindFirstIntersectNode

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class10/Code01_FindFirstIntersectNode.java">测试链接</a>

- 内容：

  > 给定两个可能有环也可能无环的单链表，头节点head1和head2。
  >
  > 请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null
  >
  > 【要求】如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。
  >

- 思路：

  > 两个链表是否相交，可以先判断是否有环，只有两个同时有环或无环，才可能相交。
  >
  > 1）**无环**，先得到各自的长度，长度长的那个先前进n-m，然后两个链表同时向后移动，当移动过程中两个链表的节点相等，则返回，直到最后都不相等则返回null。
  >
  > 2）**有环，相交节点可能在入环前，也可能在环中**
  >
  > ​	1、得到各自到入环节点的距离，同1）思路
  >
  > ​	2、如果在入环前不存在，则在环内判断，一个在入环节点处，一个遍历其本身环内，直到一圈，若相等，则返回。最后，仍不相等，则返回null

- 代码：

  <details>
  <summary>第一个相交节点代码</summary>
  <p> - 链表coding</p>
  <pre><code> public static SingleNode getIntersectNode(SingleNode head1, SingleNode head2) {
  		if (head1 == null || head2 == null) {
  			return null;
  		}
  		SingleNode loop1 = getLoopNode(head1);
  		SingleNode loop2 = getLoopNode(head2);
  		if (loop1 == null && loop2 == null) {
  			return noLoop(head1, head2);
  		}
  		if (loop1 != null && loop2 != null) {
  			return bothLoop(head1, loop1, head2, loop2);
  		}
  		return null;
  	}
  	// 找到链表第一个入环节点，如果无环，返回null
  public static SingleNode getLoopNode(SingleNode head) {
  		if (head == null || head.next == null || head.next.next == null) {
  			return null;
  		}
  		// n1 慢  n2 快
  		SingleNode slow = head.next; // n1 -> slow
  		SingleNode fast = head.next.next; // n2 -> fast
  		while (slow != fast) {
  			if (fast.next == null || fast.next.next == null) {
  				return null;
  			}
  			fast = fast.next.next;
  			slow = slow.next;
  		}
  		// slow fast  相遇
  		fast = head; // n2 -> walk again from head
  		while (slow != fast) {
  			slow = slow.next;
  			fast = fast.next;
  		}
  		return slow;
  	}
  	// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null
  public static SingleNode noLoop(SingleNode head1, SingleNode head2) {
  		if (head1 == null || head2 == null) {
  			return null;
  		}
  		SingleNode cur1 = head1;
  		SingleNode cur2 = head2;
  		int n = 0;
  		while (cur1.next != null) {
  			n++;
  			cur1 = cur1.next;
  		}
  		while (cur2.next != null) {
  			n--;
  			cur2 = cur2.next;
  		}
  		if (cur1 != cur2) {
  			return null;
  		}
  		// n  :  链表1长度减去链表2长度的值
  		cur1 = n > 0 ? head1 : head2; // 谁长，谁的头变成cur1
  		cur2 = cur1 == head1 ? head2 : head1; // 谁短，谁的头变成cur2
  		n = Math.abs(n);
  		while (n != 0) {
  			n--;
  			cur1 = cur1.next;
  		}
  		while (cur1 != cur2) {
  			cur1 = cur1.next;
  			cur2 = cur2.next;
  		}
  		return cur1;
  	}
  	// 两个有环链表，返回第一个相交节点，如果不想交返回null
  public static SingleNode bothLoop(SingleNode head1, SingleNode loop1, SingleNode head2, SingleNode loop2) {
  		SingleNode cur1 = null;
  		SingleNode cur2 = null;
  		if (loop1 == loop2) {
  			cur1 = head1;
  			cur2 = head2;
  			int n = 0;
  			while (cur1 != loop1) {
  				n++;
  				cur1 = cur1.next;
  			}
  			while (cur2 != loop2) {
  				n--;
  				cur2 = cur2.next;
  			}
  			cur1 = n > 0 ? head1 : head2;
  			cur2 = cur1 == head1 ? head2 : head1;
  			n = Math.abs(n);
  			while (n != 0) {
  				n--;
  				cur1 = cur1.next;
  			}
  			while (cur1 != cur2) {
  				cur1 = cur1.next;
  				cur2 = cur2.next;
  			}
  			return cur1;
  		} else {
  			cur1 = loop1.next;
  			while (cur1 != loop1) {
  				if (cur1 == loop2) {
  					return loop1;
  				}
  				cur1 = cur1.next;
  			}
  			return null;
  		}
  	}</code>  </pre>
  </details>

### RecursiveTraversalBT

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class10/Code02_RecursiveTraversalBT.java">测试链接</a>

- 内容：

  > 递归打印二叉树的前中后序

- 思路：

  > 思路略

- 代码：

  <details>
  <summary>前中后序遍历打印代码</summary>
  <p> - 递归实现</p>
  <pre><code>public static void f(Node head) {
  		if (head == null) {
  			return;
  		}
  		// 1 pre
  		f(head.left);
  		// 2 in
  		f(head.right);
  		// 3 pos
  	}
  	// 先序打印所有节点
  public static void pre(Node head) {
  		if (head == null) {
  			return;
  		}
  		System.out.println(head.value);
  		pre(head.left);
  		pre(head.right);
  	}
  public static void in(Node head) {
  		if (head == null) {
  			return;
  		}
  		in(head.left);
  		System.out.println(head.value);
  		in(head.right);
  	}
  public static void pos(Node head) {
  		if (head == null) {
  			return;
  		}
  		pos(head.left);
  		pos(head.right);
  		System.out.println(head.value);
  	}</code>  </pre>
  </details>

### UnRecursiveTraversalBT

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class10/Code03_UnRecursiveTraversalBT.java">测试链接</a>

- 内容：

  > 非递归打印二叉树的前中后序

- 思路：

  > 思路略

- 代码：

  <details>
  <summary>前中后序遍历打印代码</summary>
  <p> - 使用栈实现</p>
  <pre><code>public static void pre(Node head) {
          System.out.print("pre-order: ");
          if (head != null) {
              Stack<Node> stack = new Stack<Node>();
              stack.push(head);
              while (!stack.isEmpty()) {
                  head = stack.pop();
                  System.out.print(head.value + " ");
                  if (head.right != null) {
                      stack.push(head.right);
                  }
                  if (head.left != null) {
                      stack.push(head.left);
                  }
              }
          }
          System.out.println();
      }
  public static void in(Node cur) {
          System.out.print("in-order: ");
          if (cur != null) {
              Stack<Node> stack = new Stack<Node>();
              while (!stack.isEmpty() || cur != null) {
                  if (cur != null) {
                      stack.push(cur);
                      cur = cur.left;
                  } else {
                      cur = stack.pop();
                      System.out.print(cur.value + " ");
                      cur = cur.right;
                  }
              }
          }
          System.out.println();
      }
  public static void pos1(Node head) {
          System.out.print("pos-order: ");
          if(head != null){
              Stack<Node> s1 = new Stack<>();
              Stack<Node> s2 = new Stack<>();
              s1.add(head);
              // 进入s1时使用头 右 左
              while (!s1.isEmpty()) {
                  Node cur = s1.pop(); // 头 右 左
                  s2.push(cur);
                  if(cur.left != null){
                      s1.add(cur.left);
                  }
                  if(cur.right != null){
                      s1.add(cur.right);
                  }
              }
              while (!s2.isEmpty()){
                  System.out.print(s2.pop().value+" ");
              }
          }
          System.out.println();
      }
  public static void pos2(Node h) {
          System.out.print("pos-order: ");
          if(h != null){
              Stack<Node> stack = new Stack<>();
              stack.add(h);
              Node cur = null;
              while (!stack.isEmpty()){
                  cur = stack.peek();
                  if(cur.left != null && cur.left != h && cur.right != h){
                      stack.push(cur.left);
                  }else if(cur.right != null && cur.right != h){
                      stack.push(cur.right);
                  }else{
                      System.out.print(stack.pop().value +" ");
                      h = cur;
                  }
              }
          }
          System.out.println();
      }</code>  </pre>
  </details>

