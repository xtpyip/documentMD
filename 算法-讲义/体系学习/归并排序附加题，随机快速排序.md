# 归并排序附加题，随机快速排序

## 快速排序

- 算法思路

  > 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

- 快速排序算法通过多次比较和交换来实现排序，其排序流程如下：

  > 1、首先设定一个分界值，通过该分界值将数组分成左右两部分。
  >
  > 2、将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。
  >
  > 3、然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。
  >
  > 4、重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。

  概括来说为 挖坑填数 + 分治法。

## 问题集合

### CountOfRangeSum

- 链接：<a href="https://leetcode.com/problems/count-of-range-sum/">指定范围内的数量</a>

- 内容：

  > 给你一个整数数组 `nums` 以及两个整数 `lower` 和 `upper` 。求数组中，值位于范围 `[lower, upper]` （包含 `lower` 和 `upper`）之内的 **区间和的个数** 。
  >
  > **区间和** `S(i, j)` 表示在 `nums` 中，位置从 `i` 到 `j` 的元素之和，包含 `i` 和 `j` (`i` ≤ `j`)。
  >
  > **示例 1：**
  >
  > ```
  > 输入：nums = [-2,5,-1], lower = -2, upper = 2
  > 输出：3
  > 解释：存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：nums = [0], lower = 0, upper = 0
  > 输出：1
  > ```

- 思路：

  > 归并+前缀和
  >
  > 求0~i范围内值处于lower与upper的子数组，等价于求前缀和数组中 0 <= j <= i的j~i范围内为[sum - upper, sum - lower]这个范围的子数组
  >
  > 例如，arr = 3，4，-5，7，2，8，5，9 lower=4 ，upper=10
  >
  > preSum =  3，7，2，9，11，19，24，33
  >
  > 分：
  >
  > ​	3，                 7，               2，            9                                  11，         19，         24，          33
  >
  > ​         3，7                                   2，9                                                11，   19                   24 ，   33
  >
  > ​          3         7      2            9        11           19          24              33
  >
  > 合
  >
  > | 操作   | 针对的数据              | 位置                                                         | 数量    |
  > | ------ | ----------------------- | ------------------------------------------------------------ | ------- |
  > | 第一次 | 3 7 2 9 11 19 24 33     |                                                              | 2       |
  > | 第二次 | 3,7  2,9  11,19  24,33  | 3,7 要在[-3,3]中，R-L = 1<br/>2,9要在[-1,5]中，R-L = 1<br/>11,19要在[9,15]中，R-L = 1<br/>24,33要在[23,29]中，R-L = 1 | 2+4     |
  > | 第三次 | 2,3,7,9  11,19,24,33    | 2,3,7要在[-3,3]中，R-L = 1<br/>2,3,7,9要在[-1,5]中，R-L= 1<br/>11,19,24要在[14,20]中，R-L=1<br/>11,19,24,33要在[23,29]中，R-L=0 | 2+4+3   |
  > | 第四次 | 2,3,7,9 ,11,19,24,33    | 2,3,7,9 ,11要在[1,7]中，R-L=3<br/>2,3,7,9,11,19要在[9,15]中，R-L=0<br/>2,3,7,9,11,19,24要在[14,20]中，R-L=0<br/>2,3,7,9,11,19,24,33要在[23,29]中，R-L=0 | 2+4+3+3 |
  > | 默认   | 3，4，-5，7，2，8，5，9 | 4  7  8   5  9<br/>3,4  7,2  2,8 <br/>4,-5,7  -5,7,2 <br/>3,4,-5,7  4,-5,7,2 | 12      |

  

- 代码：

  <details>
  <summary>范围内的区间数量代码</summary>
  <p> - 归并排序</p>
  <pre><code>	public static int countRangeSum(int[] nums, int lower, int upper) {
          int n = nums.length;
          if(nums == null || n < 1) return 0;
          long[] preSum = new long[n];
          preSum[0] = nums[0];
          for (int i = 1; i < n; i++) {
              preSum[i] = preSum[i - 1] + nums[i];
          }
          return process(0,n-1,preSum,lower,upper);
      }
      public static int process(int L,int R,long[] preSum,int lower,int upper){
          // 只有一个元素时，判断是否符合要求
          if(L == R) return preSum[L] <= upper && preSum[L] >= lower ? 1 : 0;
          int mid = (R - L)/2 + L; //归并查询
          return process(L,mid,preSum,lower,upper)
                  + process(mid+1,R,preSum,lower,upper)
                  +merge(L,mid,R,preSum,lower,upper);
      }
      public static int merge(int L,int M,int R,long[] preSum,int lower,int upper){
          int ans = 0;
          int windowL = L;
          int windowR = L;
          // [windowL, windowR)
          for (int i = M+1; i <= R; i++) {
              long min = preSum[i] - upper;
              long max = preSum[i] - lower;
              while(windowR <= M && preSum[windowR] <= max){
                  windowR++;
              }
              while (windowL <= M && preSum[windowL] < min){
                  windowL++;
              }
              ans += windowR - windowL;
          }
          long[] help = new long[R - L + 1];
          int i = 0;
          int p1 = L;
          int p2 = M + 1;
          while (p1 <= M && p2 <= R) {
              help[i++] = preSum[p1] <= preSum[p2] ? preSum[p1++] : preSum[p2++];
          }
          while (p1 <= M) {
              help[i++] = preSum[p1++];
          }
          while (p2 <= R) {
              help[i++] = preSum[p2++];
          }
          for (i = 0; i < help.length; i++) {
              preSum[L + i] = help[i];
          }
          return ans;
      } </code>  </pre>
  </details>

### QuickSort

- 链接：<a href="https://leetcode.cn/problems/sort-an-array/description/">排序测试链接</a>

- 内容：

  > 给你一个整数数组 `nums`，请你将该数组升序排列。
  >
  > **示例 1：**
  >
  > ```
  > 输入：nums = [5,2,3,1]
  > 输出：[1,2,3,5]
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：nums = [5,1,1,2,0,0]
  > 输出：[0,0,1,1,2,5]
  > ```

- 思路：

  > 思路一：二路归并+R划分
  >
  > 思路二：二路归并+荷兰国旗R划分
  >
  > 思路三：二路归并+荷兰国旗随机划分

  主体思路为划分 5,6,7,2,1,5,6,2,4 (以4做划分)

  | 当前索引i | less(小于区右边界) | more(大于区左边界) | 当前数组值        |
  | --------- | ------------------ | ------------------ | ----------------- |
  | 无        | -1                 | 8                  | 5,6,7,2,1,5,6,2,4 |
  | 0         | -1                 | 7                  | 2,6,7,2,1,5,6,5,4 |
  | 0         | 0                  | 7                  | 2,6,7,2,1,5,6,5,4 |
  | 1         | 0                  | 6                  | 2,6,7,2,1,5,6,5,4 |
  | 1         | 0                  | 5                  | 2,5,7,2,1,6,6,5,4 |
  | 1         | 0                  | 4                  | 2,1,7,2,5,6,6,5,4 |
  | 1         | 1                  | 4                  | 2,1,7,2,5,6,6,5,4 |
  | 2         | 1                  | 3                  | 2,1,2,7,5,6,6,5,4 |
  | 2         | 2                  | 3                  | 2,1,2,5,7,6,6,5,4 |
  |           |                    |                    |                   |
  | 交换      |                    |                    | 2,1,2,4,7,6,6,5,5 |

  

- 代码：

  <details>
  <summary>R划分</summary>
  <p> - 归并排序</p>
  <pre><code>	public static void quickSort1(int[] arr) {
          if (arr == null || arr.length < 2) {
              return;
          }
          process1(arr, 0, arr.length - 1);
      }
      public static void process1(int[] arr, int L, int R) {
          if (L >= R) {
              return;
          }
          // L..R partition arr[R] [ <=arr[R] arr[R] >arr[R] ]
          int M = partition(arr, L, R);
          process1(arr, L, M - 1);
          process1(arr, M + 1, R);
      }	
      public static int partition(int[] arr, int L, int R) {
          if (L > R) {
              return -1;
          }
          if (L == R) {
              return L;
          }
          int lessEqual = L - 1;
          int index = L;
          while (index < R) {
              if (arr[index] <= arr[R]) {
                  swap(arr, index, ++lessEqual);
              }
              index++;
          }
          swap(arr, ++lessEqual, R);
          return lessEqual;
      } </code>  </pre>
  </details>
  <details>
  <summary>荷兰国旗R划分</summary>
  <p> - 归并排序</p>
  <pre><code>	public static void quickSort2(int[] arr) {
          if (arr == null || arr.length < 2) {
              return;
          }
          process2(arr, 0, arr.length - 1);
      }
      // arr[L...R] 排有序，快排2.0方式
      public static void process2(int[] arr, int L, int R) {
          if (L >= R) {
              return;
          }
          // [ equalArea[0]  ,  equalArea[0]]
          int[] equalArea = netherlandsFlag(arr, L, R);
          process2(arr, L, equalArea[0] - 1);
          process2(arr, equalArea[1] + 1, R);
      }
     // arr[L...R] 玩荷兰国旗问题的划分，以arr[R]做划分值
      // <arr[R] == arr[R] > arr[R]
      public static int[] netherlandsFlag(int[] arr, int L, int R) {
          if (L > R) return new int[]{-1, -1};
          if (L == R) return new int[]{L, L};
          int cur = arr[R];
          int less = L - 1; // < 区右边界
          int more = R; // > 区左边界
          int i = L;
          while (i < more) {
              if (arr[i] < cur) {
                  swap(arr, ++less, i++);
              } else if (arr[i] == cur) {
                  i++;
              } else {
                  swap(arr, --more, i);
              }
          }
          swap(arr, more, R); // <[R]   =[R]   >[R]
          return new int[]{less+1,more};
      } </code>  </pre>
  </details>
  <details>
  <summary>荷兰国旗随机划分</summary>
  <p> - 归并排序</p>
  <pre><code>	public static void quickSort3(int[] arr) {
          if (arr == null || arr.length < 2) {
              return;
          }
          process3(arr, 0, arr.length - 1);
      }
      public static void process3(int[] arr, int L, int R) {
          if (L >= R) {
              return;
          }
          swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
          int[] equalArea = netherlandsFlag(arr, L, R);
          process3(arr, L, equalArea[0] - 1);
          process3(arr, equalArea[1] + 1, R);
      } </code>  </pre>
  </details>

### UnRecursiveQuickSort

- 链接：<a href="https://leetcode.cn/problems/sort-an-array/description/">排序测试链接</a>

- 内容：

  > 给你一个整数数组 `nums`，请你将该数组升序排列。
  >
  > **示例 1：**
  >
  > ```
  > 输入：nums = [5,2,3,1]
  > 输出：[1,2,3,5]
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：nums = [5,1,1,2,0,0]
  > 输出：[0,0,1,1,2,5]
  > ```

- 思路：

  > 上面的QuickSort为递归排序
  >
  > 下面这个是非递归，迭代排序
  >
  > 思路一：栈
  >
  > 思路二：队列

- 代码：

  <details>
  <summary>使用栈来迭代</summary>
  <p> - 荷兰划分</p>
  <pre><code>	// 快排非递归版本需要的辅助类
  	// 要处理的是什么范围上的排序
  	public static class Op {
  		public int l;
  		public int r;
  		public Op(int left, int right) {
  			l = left;
  			r = right;
  		}
  	}
  	// 快排3.0 非递归版本 用栈来执行
  	public static void quickSort2(int[] arr) {
  		if (arr == null || arr.length < 2) {
  			return;
  		}
  		int N = arr.length;
  		swap(arr, (int) (Math.random() * N), N - 1);
  		int[] equalArea = netherlandsFlag(arr, 0, N - 1);
  		int el = equalArea[0];
  		int er = equalArea[1];
  		Stack<Op> stack = new Stack<>();
  		stack.push(new Op(0, el - 1));
  		stack.push(new Op(er + 1, N - 1));
  		while (!stack.isEmpty()) {
  			Op op = stack.pop(); // op.l ... op.r
  			if (op.l < op.r) {
  				swap(arr, op.l + (int) (Math.random() * (op.r - op.l + 1)), op.r);
  				equalArea = netherlandsFlag(arr, op.l, op.r);
  				el = equalArea[0];
  				er = equalArea[1];
  				stack.push(new Op(op.l, el - 1));
  				stack.push(new Op(er + 1, op.r));
  			}
  		}
  	} </code>  </pre>
  </details>
  
  <details>
  <summary>使用队列来迭代</summary>
  <p> - 荷兰划分</p>
  <pre><code>	// 快排非递归版本需要的辅助类
  	// 要处理的是什么范围上的排序
  	public static class Op {
  		public int l;
  		public int r;
  		public Op(int left, int right) {
  			l = left;
  			r = right;
  		}
  	}
  	// 快排3.0 非递归版本 用队列来执行
  	public static void quickSort3(int[] arr) {
  		if (arr == null || arr.length < 2) {
  			return;
  		}
  		int N = arr.length;
  		swap(arr, (int) (Math.random() * N), N - 1);
  		int[] equalArea = netherlandsFlag(arr, 0, N - 1);
  		int el = equalArea[0];
  		int er = equalArea[1];
  		Queue<Op> queue = new LinkedList<>();
  		queue.offer(new Op(0, el - 1));
  		queue.offer(new Op(er + 1, N - 1));
  		while (!queue.isEmpty()) {
  			Op op = queue.poll();
  			if (op.l < op.r) {
  				swap(arr, op.l + (int) (Math.random() * (op.r - op.l + 1)), op.r);
  				equalArea = netherlandsFlag(arr, op.l, op.r);
  				el = equalArea[0];
  				er = equalArea[1];
  				queue.offer(new Op(op.l, el - 1));
  				queue.offer(new Op(er + 1, op.r));
  			}
  		}
  	} </code>  </pre>
  </details>