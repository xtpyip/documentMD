# 动态规划猜法中和外部信息简化的相关二

## 基本内容

- 动态规划猜法中和外部信息简化的相关问题

  > 单纯的使用func(L...R)无法确定出唯一的结果，因为外部信息会对其造成影响。
  >
  > 但如果添加一些外部信息，则又会导致数据的参数量急剧上升。
  >
  > 如何将外部信息简化为一个或两个参数(最多)，让func(L...R)能得到一个确定的答案，就变的尤为重要了。

## 问题集合

### StrangePrinter

- 链接：<a href="https://leetcode.cn/problems/strange-printer/description/">测试链接</a>

- 内容：

  > 有台奇怪的打印机有以下两个特殊要求：
  >
  > - 打印机每次只能打印由 **同一个字符** 组成的序列。
  > - 每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。
  >
  > 给你一个字符串 `s` ，你的任务是计算这个打印机打印它需要的最少打印次数。
  >
  > **示例 1：**
  >
  > ```
  > 输入：s = "aaabbb"
  > 输出：2
  > 解释：首先打印 "aaa" 然后打印 "bbb"。
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：s = "aba"
  > 输出：2
  > 解释：首先打印 "aaa" 然后在第二个位置打印 "b" 覆盖掉原来的字符 'a'。
  > ```
  
- 思路：

  > 思路一：递归
  >
  > 思路二：记忆化搜索
  >
  > 思路三：dp
  
- 代码：

  <details>
  <summary>递归</summary>
  <p> - 最少打印次数</p>
  <pre><code>public static int strangePrinter1(String s) {
  		if (s == null || s.length() == 0) {
  			return 0;
  		}
  		char[] str = s.toCharArray();
  		return process1(str, 0, str.length - 1);
  	}
  	// 要想刷出str[L...R]的样子！
  	// 返回最少的转数
  	public static int process1(char[] str, int L, int R) {
  		if (L == R) {
  			return 1;
  		}
  		// L...R
  		int ans = R - L + 1;
  		for (int k = L + 1; k <= R; k++) {
  			// L...k-1 k....R
  			ans = Math.min(ans, process1(str, L, k - 1) + process1(str, k, R) - (str[L] == str[k] ? 1 : 0));
  		}
  		return ans;
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>记忆化搜索</summary>
  <p> - 最少打印次数</p>
  <pre><code>public static int strangePrinter2(String s) {
  		if (s == null || s.length() == 0) {
  			return 0;
  		}
  		char[] str = s.toCharArray();
  		int N = str.length;
  		int[][] dp = new int[N][N];
  		return process2(str, 0, N - 1, dp);
  	}
  	public static int process2(char[] str, int L, int R, int[][] dp) {
  		if (dp[L][R] != 0) {
  			return dp[L][R];
  		}
  		int ans = R - L + 1;
  		if (L == R) {
  			ans = 1;
  		} else {
  			for (int k = L + 1; k <= R; k++) {
  				ans = Math.min(ans, process2(str, L, k - 1, dp) + process2(str, k, R, dp) - (str[L] == str[k] ? 1 : 0));
  			}
  		}
  		dp[L][R] = ans;
  		return ans;
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp</summary>
  <p> - 最少打印次数</p>
  <pre><code>public static int strangePrinter3(String s) {
  		if (s == null || s.length() == 0) {
  			return 0;
  		}
  		char[] str = s.toCharArray();
  		int N = str.length;
  		int[][] dp = new int[N][N];
  		dp[N - 1][N - 1] = 1;
  		for (int i = 0; i < N - 1; i++) {
  			dp[i][i] = 1;
  			dp[i][i + 1] = str[i] == str[i + 1] ? 1 : 2;
  		}
  		for (int L = N - 3; L >= 0; L--) {
  			for (int R = L + 2; R < N; R++) {
  				dp[L][R] = R - L + 1;
  				for (int k = L + 1; k <= R; k++) {
  					dp[L][R] = Math.min(dp[L][R], dp[L][k - 1] + dp[k][R] - (str[L] == str[k] ? 1 : 0));
  				}
  			}
  		}
  		return dp[0][N - 1];
  	}</code>  </pre>
  </details>

### RestoreWays

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class47/Code02_RestoreWays.java">测试链接</a>

- 内容：

  > 整型数组arr长度为n(3<= n <= 10^4)，最初每个数字是<=200的正数且满足如下条件
  >
  > 1.arr[0] <= arr[1]
  >
  > 2.arr[n-1] <= arr[n-2]
  >
  > 3.arr[i] <= max(arr[i-1], arr[i+1])
  >
  > 但是在arr有些数字丢失了，比如k位置的数字之前是正数,丢失之后k位置的数字为0。
  >
  > 请你根据上述条件,计算可能有多少种不同的arr可以满足以上条件。
  >
  > 比如[6.,0.9]只有还原成[6,9.9]满足全部三个条件，所以返回1种。

- 思路：

  > 思路一：递归
  >
  > 思路二：递归+状态记录
  >
  > ```java
  > // 如果i位置的数字变成了v,
  > // 并且arr[i]和arr[i+1]的关系为s，
  > // s==0，代表arr[i] < arr[i+1] 右大
  > // s==1，代表arr[i] == arr[i+1] 右=当前
  > // s==2，代表arr[i] > arr[i+1] 右小
  > ```
  >
  > 思路三：dp
  >
  > 思路四：dp+前缀和

- 代码：

  <details>
  <summary>递归</summary>
  <p> - 满足数量</p>
  <pre><code>public static int ways0(int[] arr) {
  		return process0(arr, 0);
  	}
  	public static int process0(int[] arr, int index) {
  		if (index == arr.length) {
  			return isValid(arr) ? 1 : 0;
  		} else {
  			if (arr[index] != 0) {
  				return process0(arr, index + 1);
  			} else {
  				int ways = 0;
  				for (int v = 1; v < 201; v++) {
  					arr[index] = v;
  					ways += process0(arr, index + 1);
  				}
  				arr[index] = 0;
  				return ways;
  			}
  		}
  	}
  	public static boolean isValid(int[] arr) {
  		if (arr[0] > arr[1]) {
  			return false;
  		}
  		if (arr[arr.length - 1] > arr[arr.length - 2]) {
  			return false;
  		}
  		for (int i = 1; i < arr.length - 1; i++) {
  			if (arr[i] > Math.max(arr[i - 1], arr[i + 1])) {
  				return false;
  			}
  		}
  		return true;
  	}</code>  </pre>
  </details>

  <details>
  <summary>递归+状态记录</summary>
  <p> - 满足数量</p>
  <pre><code>public static int ways1(int[] arr) {
  		int N = arr.length;
  		if (arr[N - 1] != 0) {
  			return process1(arr, N - 1, arr[N - 1], 2);
  		} else {
  			int ways = 0;
  			for (int v = 1; v < 201; v++) {
  				ways += process1(arr, N - 1, v, 2);
  			}
  			return ways;
  		}
  	}
  	// 如果i位置的数字变成了v,
  	// 并且arr[i]和arr[i+1]的关系为s，
  	// s==0，代表arr[i] < arr[i+1] 右大
  	// s==1，代表arr[i] == arr[i+1] 右=当前
  	// s==2，代表arr[i] > arr[i+1] 右小
  	// 返回0...i范围上有多少种有效的转化方式？
  	public static int process1(int[] arr, int i, int v, int s) {
  		if (i == 0) { // 0...i 只剩一个数了，0...0
  			return ((s == 0 || s == 1) && (arr[0] == 0 || v == arr[0])) ? 1 : 0;
  		}
  		// i > 0
  		if (arr[i] != 0 && v != arr[i]) {
  			return 0;
  		}
  		// i>0 ，并且， i位置的数真的可以变成V，
  		int ways = 0;
  		if (s == 0 || s == 1) { // [i] -> V <= [i+1]
  			for (int pre = 1; pre < 201; pre++) {
  				ways += process1(arr, i - 1, pre, pre < v ? 0 : (pre == v ? 1 : 2));
  			}
  		} else { // ? 当前 > 右 当前 <= max{左，右}
  			for (int pre = v; pre < 201; pre++) {
  				ways += process1(arr, i - 1, pre, pre == v ? 1 : 2);
  			}
  		}
  		return ways;
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp</summary>
  <p> - 满足数量</p>
  <pre><code>public static int ways2(int[] arr) {
  		int N = arr.length;
  		int[][][] dp = new int[N][201][3];
  		if (arr[0] != 0) {
  			dp[0][arr[0]][0] = 1;
  			dp[0][arr[0]][1] = 1;
  		} else {
  			for (int v = 1; v < 201; v++) {
  				dp[0][v][0] = 1;
  				dp[0][v][1] = 1;
  			}
  		}
  		for (int i = 1; i < N; i++) {
  			for (int v = 1; v < 201; v++) {
  				for (int s = 0; s < 3; s++) {
  					if (arr[i] == 0 || v == arr[i]) {
  						if (s == 0 || s == 1) {
  							for (int pre = 1; pre < v; pre++) {
  								dp[i][v][s] += dp[i - 1][pre][0];
  							}
  						}
  						dp[i][v][s] += dp[i - 1][v][1];
  						for (int pre = v + 1; pre < 201; pre++) {
  							dp[i][v][s] += dp[i - 1][pre][2];
  						}
  					}
  				}
  			}
  		}
  		if (arr[N - 1] != 0) {
  			return dp[N - 1][arr[N - 1]][2];
  		} else {
  			int ways = 0;
  			for (int v = 1; v < 201; v++) {
  				ways += dp[N - 1][v][2];
  			}
  			return ways;
  		}
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp+前缀和</summary>
  <p> - 满足数量</p>
  <pre><code>public static int ways3(int[] arr) {
  		int N = arr.length;
  		int[][][] dp = new int[N][201][3];
  		if (arr[0] != 0) {
  			dp[0][arr[0]][0] = 1;
  			dp[0][arr[0]][1] = 1;
  		} else {
  			for (int v = 1; v < 201; v++) {
  				dp[0][v][0] = 1;
  				dp[0][v][1] = 1;
  			}
  		}
  		int[][] presum = new int[201][3];
  		for (int v = 1; v < 201; v++) {
  			for (int s = 0; s < 3; s++) {
  				presum[v][s] = presum[v - 1][s] + dp[0][v][s];
  			}
  		}
  		for (int i = 1; i < N; i++) {
  			for (int v = 1; v < 201; v++) {
  				for (int s = 0; s < 3; s++) {
  					if (arr[i] == 0 || v == arr[i]) {
  						if (s == 0 || s == 1) {
  							dp[i][v][s] += sum(1, v - 1, 0, presum);
  						}
  						dp[i][v][s] += dp[i - 1][v][1];
  						dp[i][v][s] += sum(v + 1, 200, 2, presum);
  					}
  				}
  			}
  			for (int v = 1; v < 201; v++) {
  				for (int s = 0; s < 3; s++) {
  					presum[v][s] = presum[v - 1][s] + dp[i][v][s];
  				}
  			}
  		}
  		if (arr[N - 1] != 0) {
  			return dp[N - 1][arr[N - 1]][2];
  		} else {
  			return sum(1, 200, 2, presum);
  		}
  	}
  	public static int sum(int begin, int end, int relation, int[][] presum) {
  		return presum[end][relation] - presum[begin - 1][relation];
  	}</code>  </pre>
  </details>

### DinicAlgorithm

- 链接：<a href="https://lightoj.com/problem/internet-bandwidth">测试链接</a>

- 内容：

  > ![](http://8.130.177.90:9000/blog/24/alogrithm/wstx/class47/internet_bandwidth.png)
  >
  > On the Internet, machines (nodes) are richly interconnected, and many paths may exist between a given pair of nodes. The total message-carrying capacity (bandwidth) between two given nodes is the maximal amount of data per unit time that can be transmitted from one node to the other. Using a technique called packet switching; this data can be transmitted along several paths at the same time.
  >
  > For example, the figure shows a network with four nodes (shown as circles), with a total of five connections among them. Every connection is labeled with a bandwidth that represents its data-carrying capacity per unit time.
  >
  > In our example, the bandwidth between node 1 and node 4 is 25, which might be thought of as the sum of the bandwidths 10 along the path 1-2-4, 10 along the path 1-3-4, and 5 along the path 1-2-3-4. No other combination of paths between nodes 1 and 4 provides a larger bandwidth.
  >
  > You must write a program that computes the bandwidth between two given nodes in a network, given the individual bandwidths of all the connections in the network. In this problem, assume that the bandwidth of a connection is always the same in both directions (which is not necessarily true in the real world).
  >
  > #### Input
  >
  > Input starts with an integer **T (≤ 30)**, denoting the number of test cases.
  >
  > Every description starts with a line containing an integer **n (2 ≤ n ≤ 100)**, which is the number of nodes in the network. The nodes are numbered from **1** to **n**. The next line contains three numbers **s**, **t**, and **c**. The numbers **s** and **t** are the source and destination nodes, and the number **c (c ≤ 5000, s ≠ t)** is the total number of connections in the network. Following this are **c** lines describing the connections. Each of these lines contains three integers: the first two are the numbers of the connected nodes, and the third number is the bandwidth of the connection. The bandwidth is a non-negative number not greater than **1000**.
  >
  > There might be more than one connection between a pair of nodes, but a node cannot be connected to itself. All connections are bi-directional, i.e. data can be transmitted in both directions along a connection, but the sum of the amount of data transmitted in both directions must be less than the bandwidth.
  >
  > #### Output
  >
  > For each case of input, print the case number and the total bandwidth between the source node **s** and the destination node **t**.

- 思路：

  > 每完成一个任务，添加该任务的反向数据流向

- 代码：

  <details>
  <summary>宽度优先+深度优先+反向数据流向</summary>
  <p> - 最大流量</p>
  <pre><code>	public static void main(String[] args) throws IOException {
  		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  		StreamTokenizer in = new StreamTokenizer(br);
  		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
  		while (in.nextToken() != StreamTokenizer.TT_EOF) {
  			int cases = (int) in.nval;
  			for (int i = 1; i <= cases; i++) {
  				in.nextToken();
  				int n = (int) in.nval;
  				in.nextToken();
  				int s = (int) in.nval;
  				in.nextToken();
  				int t = (int) in.nval;
  				in.nextToken();
  				int m = (int) in.nval;
  				Dinic dinic = new Dinic(n);
  				for (int j = 0; j < m; j++) {
  					in.nextToken();
  					int from = (int) in.nval;
  					in.nextToken();
  					int to = (int) in.nval;
  					in.nextToken();
  					int weight = (int) in.nval;
  					dinic.addEdge(from, to, weight);
  					dinic.addEdge(to, from, weight);
  				}
  				int ans = dinic.maxFlow(s, t);
  				out.println("Case " + i + ": " + ans);
  				out.flush();
  			}
  		}
  	}
  	public static class Edge {
  		public int from;
  		public int to;
  		public int available;
  		public Edge(int a, int b, int c) {
  			from = a;
  			to = b;
  			available = c;
  		}
  	}
  	public static class Dinic {
  		private int N;
  		private ArrayList<ArrayList<Integer>> nexts;
  		private ArrayList<Edge> edges;
  		private int[] depth;
  		private int[] cur;
  		public Dinic(int nums) {
  			N = nums + 1;
  			nexts = new ArrayList<>();
  			for (int i = 0; i <= N; i++) {
  				nexts.add(new ArrayList<>());
  			}
  			edges = new ArrayList<>();
  			depth = new int[N];
  			cur = new int[N];
  		}
  		public void addEdge(int u, int v, int r) {
  			int m = edges.size();
  			edges.add(new Edge(u, v, r));
  			nexts.get(u).add(m);
  			edges.add(new Edge(v, u, 0));
  			nexts.get(v).add(m + 1);
  		}
  		public int maxFlow(int s, int t) {
  			int flow = 0;
  			while (bfs(s, t)) {
  				Arrays.fill(cur, 0);
  				flow += dfs(s, t, Integer.MAX_VALUE);
  				Arrays.fill(depth, 0);
  			}
  			return flow;
  		}
  		private boolean bfs(int s, int t) {
  			LinkedList<Integer> queue = new LinkedList<>();
  			queue.addFirst(s);
  			boolean[] visited = new boolean[N];
  			visited[s] = true;
  			while (!queue.isEmpty()) {
  				int u = queue.pollLast();
  				for (int i = 0; i < nexts.get(u).size(); i++) {
  					Edge e = edges.get(nexts.get(u).get(i));
  					int v = e.to;
  					if (!visited[v] && e.available > 0) {
  						visited[v] = true;
  						depth[v] = depth[u] + 1;
  						if (v == t) {
  							break;
  						}
  						queue.addFirst(v);
  					}
  				}
  			}
  			return visited[t];
  		}
  		// 当前来到了s点，s可变
  		// 最终目标是t，t固定参数
  		// r，收到的任务
  		// 收集到的流，作为结果返回，ans <= r
  		private int dfs(int s, int t, int r) {
  			if (s == t || r == 0) {
  				return r;
  			}
  			int f = 0;
  			int flow = 0;
  			// s点从哪条边开始试 -> cur[s]
  			for (; cur[s] < nexts.get(s).size(); cur[s]++) {
  				int ei = nexts.get(s).get(cur[s]);
  				Edge e = edges.get(ei);
  				Edge o = edges.get(ei ^ 1);
  				if (depth[e.to] == depth[s] + 1 && (f = dfs(e.to, t, Math.min(e.available, r))) != 0) {
  					e.available -= f;
  					o.available += f;
  					flow += f;
  					r -= f;
  					if (r <= 0) {
  						break;
  					}
  				}
  			}
  			return flow;
  		}
  	}</code>  </pre>
  </details>
