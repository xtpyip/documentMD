# 动态规划猜法中和外部信息简化的相关一

## 基本内容

- 动态规划猜法中和外部信息简化的相关问题

  > 单纯的使用func(L...R)无法确定出唯一的结果，因为外部信息会对其造成影响。
  >
  > 但如果添加一些外部信息，则又会导致数据的参数量急剧上升。
  >
  > 如何将外部信息简化为一个或两个参数(最多)，让func(L...R)能得到一个确定的答案，就变的尤为重要了。

## 问题集合

### BurstBalloons

- 链接：<a href="https://leetcode.cn/problems/burst-balloons/description/">测试链接</a>

- 内容：

  > 有 `n` 个气球，编号为`0` 到 `n - 1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。
  >
  > 现在要求你戳破所有的气球。戳破第 `i` 个气球，你可以获得 `nums[i - 1] * nums[i] * nums[i + 1]` 枚硬币。 这里的 `i - 1` 和 `i + 1` 代表和 `i` 相邻的两个气球的序号。如果 `i - 1`或 `i + 1` 超出了数组的边界，那么就当它是一个数字为 `1` 的气球。
  >
  > 求所能获得硬币的最大数量。
  >
  > **示例 1：**
  >
  > ```
  > 输入：nums = [3,1,5,8]
  > 输出：167
  > 解释：
  > nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
  > coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：nums = [1,5]
  > 输出：10
  > ```
  
- 思路：

  > 思路一：递归
  >
  > 思路二：dp
  >
  > 我们定义一个长为n+2的数组，两端均为1
  >
  > process(help, 1, n)表示从1到n+1都打破的硬币最大数量
  >
  > 返回max(先打破两端，选中间打破)
  
- 代码：

  <details>
  <summary>递归</summary>
  <p> - 硬币的最大数量</p>
  <pre><code>public static int maxCoins1(int[] arr) {
  		if (arr == null || arr.length == 0) {
  			return 0;
  		}
  		if (arr.length == 1) {
  			return arr[0];
  		}
  		int N = arr.length;
  		int[] help = new int[N + 2];
  		help[0] = 1;
  		help[N + 1] = 1;
  		for (int i = 0; i < N; i++) {
  			help[i + 1] = arr[i];
  		}
  		return process(help, 1, N);
  	}
  	// 打爆arr[L..R]范围上的所有气球，返回最大的分数
  	// 假设arr[L-1]和arr[R+1]一定没有被打爆
  	public static int process(int[] arr, int L, int R) {
  		if (L == R) {// 如果arr[L..R]范围上只有一个气球，直接打爆即可
  			return arr[L - 1] * arr[L] * arr[R + 1];
  		}
  		// 最后打爆arr[L]的方案，和最后打爆arr[R]的方案，先比较一下
  		int max = Math.max(arr[L - 1] * arr[L] * arr[R + 1] + process(arr, L + 1, R),
  				arr[L - 1] * arr[R] * arr[R + 1] + process(arr, L, R - 1));
  		// 尝试中间位置的气球最后被打爆的每一种方案
  		for (int i = L + 1; i < R; i++) {
  			max = Math.max(max, arr[L - 1] * arr[i] * arr[R + 1] + process(arr, L, i - 1) + process(arr, i + 1, R));
  		}
  		return max;
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp</summary>
  <p> - 硬币的最大数量</p>
  <pre><code>public static int maxCoins2(int[] arr) {
  		if (arr == null || arr.length == 0) {
  			return 0;
  		}
  		if (arr.length == 1) {
  			return arr[0];
  		}
  		int N = arr.length;
  		int[] help = new int[N + 2];
  		help[0] = 1;
  		help[N + 1] = 1;
  		for (int i = 0; i < N; i++) {
  			help[i + 1] = arr[i];
  		}
  		int[][] dp = new int[N + 2][N + 2];
  		for (int i = 1; i <= N; i++) {
  			dp[i][i] = help[i - 1] * help[i] * help[i + 1];
  		}
  		for (int L = N; L >= 1; L--) {
  			for (int R = L + 1; R <= N; R++) {
  				int ans = help[L - 1] * help[L] * help[R + 1] + dp[L + 1][R];
  				ans = Math.max(ans, help[L - 1] * help[R] * help[R + 1] + dp[L][R - 1]);
  				for (int i = L + 1; i < R; i++) {
  					ans = Math.max(ans, help[L - 1] * help[i] * help[R + 1] + dp[L][i - 1] + dp[i + 1][R]);
  				}
  				dp[L][R] = ans;
  			}
  		}
  		return dp[1][N];
  	}</code>  </pre>
  </details>

### RemoveBoxes

- 链接：<a href="https://leetcode.cn/problems/remove-boxes/description/">测试链接</a>

- 内容：

  > 给出一些不同颜色的盒子 `boxes` ，盒子的颜色由不同的正数表示。
  >
  > 你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 `k` 个盒子（`k >= 1`），这样一轮之后你将得到 `k * k` 个积分。
  >
  > 返回 *你能获得的最大积分和* 。
  >
  > **示例 1：**
  >
  > ```
  > 输入：boxes = [1,3,2,2,2,3,4,3,1]
  > 输出：23
  > 解释：
  > [1, 3, 2, 2, 2, 3, 4, 3, 1] 
  > ----> [1, 3, 3, 4, 3, 1] (3*3=9 分) 
  > ----> [1, 3, 3, 3, 1] (1*1=1 分) 
  > ----> [1, 1] (3*3=9 分) 
  > ----> [] (2*2=4 分)
  > ```
  >
  > **示例 2：**
  >
  > ```
  > 输入：boxes = [1,1,1]
  > 输出：9
  > ```
  >
  > **示例 3：**
  >
  > ```
  > 输入：boxes = [1]
  > 输出：1
  > ```

- 思路：

  > 思路一：递归
  >
  > 思路二：dp
  >
  > 我们定义一个函数fun(L,R,k)
  >
  > 表明在L到R这个区间中，在L之前紧挨着k个与arr[L]相等的数据
  >
  > 1、我们可以让第L个数据与前k个数据一起消除
  >
  > 2、也可以让L与前k个合并为k+1个数据，并和i来处理(隐含条件arr[i]==arr[L]且arr[i-1]!=arr[L])
  >
  > ​	其值为fun(arr, L + 1, i - 1, 0) + fun(arr, i, R, K + 1)
  >
  > 返回1与2的最大值

- 代码：

  <details>
  <summary>递归</summary>
  <p> - 最大积分和</p>
  <pre><code>	public static int removeBoxes1(int[] boxes) {
  		int N = boxes.length;
  		int[][][] dp = new int[N][N][N];
  		int ans = process1(boxes, 0, N - 1, 0, dp);
  		return ans;
  	}
  	public static int process1(int[] boxes, int L, int R, int K, int[][][] dp) {
  		if (L > R) {
  			return 0;
  		}
  		if (dp[L][R][K] > 0) {
  			return dp[L][R][K];
  		}
  		int ans = process1(boxes, L + 1, R, 0, dp) + (K + 1) * (K + 1);
  		for (int i = L + 1; i <= R; i++) {
  			if (boxes[i] == boxes[L]) {
  				ans = Math.max(ans, process1(boxes, L + 1, i - 1, 0, dp) + process1(boxes, i, R, K + 1, dp));
  			}
  		}
  		dp[L][R][K] = ans;
  		return ans;
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp</summary>
  <p> - 最大积分和</p>
  <pre><code>public static int removeBoxes2(int[] boxes) {
  		int N = boxes.length;
  		int[][][] dp = new int[N][N][N];
  		int ans = process2(boxes, 0, N - 1, 0, dp);
  		return ans;
  	}
  	public static int process2(int[] boxes, int L, int R, int K, int[][][] dp) {
  		if (L > R) {
  			return 0;
  		}
  		if (dp[L][R][K] > 0) {
  			return dp[L][R][K];
  		}
  		// 找到开头，
  		// 1,1,1,1,1,5
  		// 3 4 5 6 7 8
  		//         !
  		int last = L;
  		while (last + 1 <= R && boxes[last + 1] == boxes[L]) {
  			last++;
  		}
  		// K个1     (K + last - L) last
  		int pre = K + last - L;
  		int ans = (pre + 1) * (pre + 1) + process2(boxes, last + 1, R, 0, dp);
  		for (int i = last + 2; i <= R; i++) {
  			if (boxes[i] == boxes[L] && boxes[i - 1] != boxes[L]) {
  				ans = Math.max(ans, process2(boxes, last + 1, i - 1, 0, dp) + process2(boxes, i, R, pre + 1, dp));
  			}
  		}
  		dp[L][R][K] = ans;
  		return ans;
  	}</code>  </pre>
  </details>

### DeleteAdjacentSameCharacter

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class46/Code03_DeleteAdjacentSameCharacter.java">测试链接</a>

- 内容：

  > 如果一个字符相邻的位置没有相同字符，那么这个位置的字符出现不能被消掉
  >
  >  比如:"ab"，其中a和b都不能被消掉
  >
  > 如果一个字符相邻的位置有相同字符，就可以一起消掉
  >
  > 比如:"abbbc"，中间一串的b是可以被消掉的，消除之后剩下"ac"
  >
  > 某些字符如果消掉了，剩下的字符认为重新靠在一起
  >
  > **给定一个字符串，你可以决定每一步消除的顺序，目标是请尽可能多的消掉字符，返回最少的剩余字符数量**
  >
  > 比如："aacca", 如果先消掉最左侧的"aa"，那么将剩下"cca"，然后把"cc"消掉，剩下的"a"将无法再消除，返回1
  >
  > 但是如果先消掉中间的"cc"，那么将剩下"aaa"，最后都消掉就一个字符也不剩了，返回0，这才是最优解。
  >
  > 再比如："baaccabb"，
  >
  > 如果先消除最左侧的两个a，剩下"bccabb"，
  >
  > 如果再消除最左侧的两个c，剩下"babb"，
  >
  > 最后消除最右侧的两个b，剩下"ba"无法再消除，返回2
  >
  > 而最优策略是：
  >
  > 如果先消除中间的两个c，剩下"baaabb"，
  >
  > 如果再消除中间的三个a，剩下"bbb"，
  >
  > 最后消除三个b，不留下任何字符，返回0，这才是最优解

- 思路：

  > 思路一：暴力递归
  >
  > 思路二：暴力递归改良
  >
  > 思路三：dp

- 代码：

  <details>
  <summary>暴力递归</summary>
  <p> - 最少剩余字符串</p>
  <pre><code>// 暴力解
  	public static int restMin1(String s) {
  		if (s == null) {
  			return 0;
  		}
  		if (s.length() < 2) {
  			return s.length();
  		}
  		int minLen = s.length();
  		for (int L = 0; L < s.length(); L++) {
  			for (int R = L + 1; R < s.length(); R++) {
  				if (canDelete(s.substring(L, R + 1))) {
  					minLen = Math.min(minLen, restMin1(s.substring(0, L) + s.substring(R + 1, s.length())));
  				}
  			}
  		}
  		return minLen;
  	}
  	public static boolean canDelete(String s) {
  		char[] str = s.toCharArray();
  		for (int i = 1; i < str.length; i++) {
  			if (str[i - 1] != str[i]) {
  				return false;
  			}
  		}
  		return true;
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>暴力递归改良</summary>
  <p> - 最少剩余字符串</p>
  <pre><code>// 优良尝试的暴力递归版本
  	public static int restMin2(String s) {
  		if (s == null) {
  			return 0;
  		}
  		if (s.length() < 2) {
  			return s.length();
  		}
  		char[] str = s.toCharArray();
  		return process(str, 0, str.length - 1, false);
  	}
  	// str[L...R] 前面有没有跟着[L]字符，has T 有 F 无
  	// L,R,has
  	// 最少能剩多少字符，消不了
  	public static int process(char[] str, int L, int R, boolean has) {
  		if (L > R) {
  			return 0;
  		}
  		if (L == R) {
  			return has ? 0 : 1;
  		}
  		int index = L;
  		int K = has ? 1 : 0;
  		while (index <= R && str[index] == str[L]) {
  			K++;
  			index++;
  		}
  		// index表示，第一个不是[L]字符的位置
  		int way1 = (K > 1 ? 0 : 1) + process(str, index, R, false);
  		int way2 = Integer.MAX_VALUE;
  		for (int split = index; split <= R; split++) {
  			if (str[split] == str[L] && str[split] != str[split - 1]) {
  				if (process(str, index, split - 1, false) == 0) {
  					way2 = Math.min(way2, process(str, split, R, K != 0));
  				}
  			}
  		}
  		return Math.min(way1, way2);
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp</summary>
  <p> - 最少剩余字符串</p>
  <pre><code>// 优良尝试的动态规划版本
  	public static int restMin3(String s) {
  		if (s == null) {
  			return 0;
  		}
  		if (s.length() < 2) {
  			return s.length();
  		}
  		char[] str = s.toCharArray();
  		int N = str.length;
  		int[][][] dp = new int[N][N][2];
  		for (int i = 0; i < N; i++) {
  			for (int j = 0; j < N; j++) {
  				for (int k = 0; k < 2; k++) {
  					dp[i][j][k] = -1;
  				}
  			}
  		}
  		return dpProcess(str, 0, N - 1, false, dp);
  	}
  	public static int dpProcess(char[] str, int L, int R, boolean has, int[][][] dp) {
  		if (L > R) {
  			return 0;
  		}
  		int K = has ? 1 : 0;
  		if (dp[L][R][K] != -1) {
  			return dp[L][R][K];
  		}
  		int ans = 0;
  		if (L == R) {
  			ans = (K == 0 ? 1 : 0);
  		} else {
  			int index = L;
  			int all = K;
  			while (index <= R && str[index] == str[L]) {
  				all++;
  				index++;
  			}
  			int way1 = (all > 1 ? 0 : 1) + dpProcess(str, index, R, false, dp);
  			int way2 = Integer.MAX_VALUE;
  			for (int split = index; split <= R; split++) {
  				if (str[split] == str[L] && str[split] != str[split - 1]) {
  					if (dpProcess(str, index, split - 1, false, dp) == 0) {
  						way2 = Math.min(way2, dpProcess(str, split, R, all > 0, dp));
  					}
  				}
  			}
  			ans = Math.min(way1, way2);
  		}
  		dp[L][R][K] = ans;
  		return ans;
  	}</code>  </pre>
  </details>

### MaxSumLengthNoMore

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class46/Code04_MaxSumLengthNoMore.java">测试链接</a>

- 内容：

  > 给定一个数组arr，和一个正数M
  >
  > 返回在子数组长度不大于M的情况下，最大的子数组累加和

- 思路：

  > 使用前缀和数组，更改为子数组长度不大于M的情况下，求最大值(-开头位置)

- 代码：

  <details>
  <summary>前缀和</summary>
  <p> - 最大的子数组累加和</p>
  <pre><code>// O(N)的解法，最优解
  	public static int maxSum(int[] arr, int M) {
  		if (arr == null || arr.length == 0 || M < 1) {
  			return 0;
  		}
  		int N = arr.length;
  		int[] sum = new int[N];
  		sum[0] = arr[0];
  		for (int i = 1; i < N; i++) {
  			sum[i] = sum[i - 1] + arr[i];
  		}
  		LinkedList<Integer> qmax = new LinkedList<>();
  		int i = 0;
  		int end = Math.min(N, M);
  		for (; i < end; i++) {
  			while (!qmax.isEmpty() && sum[qmax.peekLast()] <= sum[i]) {
  				qmax.pollLast();
  			}
  			qmax.add(i);
  		}
  		int max = sum[qmax.peekFirst()];
  		int L = 0;
  		for (; i < N; L++, i++) {
  			if (qmax.peekFirst() == L) {
  				qmax.pollFirst();
  			}
  			while (!qmax.isEmpty() && sum[qmax.peekLast()] <= sum[i]) {
  				qmax.pollLast();
  			}
  			qmax.add(i);
  			max = Math.max(max, sum[qmax.peekFirst()] - sum[L]);
  		}
  		for (; L < N - 1; L++) {
  			if (qmax.peekFirst() == L) {
  				qmax.pollFirst();
  			}
  			max = Math.max(max, sum[qmax.peekFirst()] - sum[L]);
  		}
  		return max;
  	}</code>  </pre>
  </details>
