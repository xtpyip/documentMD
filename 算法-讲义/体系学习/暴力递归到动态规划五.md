# 暴力递归到动态规划五

## 基本内容

- 暴力递归就是尝试

  > 1，把问题转化为规模缩小了的同类问题的子问题
  >
  > 2，有明确的不需要继续进行递归的条件(base case)
  >
  > 3，有当得到了子问题的结果之后的决策过程
  >
  > 4，不记录每一个子问题的解

- 动态规划

  > 动态规划（Dynamic Programming,DP）算法通常用于求解某种具有最优性质的问题。在这类问题中，可能会有许多可行解，每一个解都对应一个值，我们希望找到具有最优值的解。
  > 动态规划算法与分治法类似，其基本思想也是将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解中 得到原有问题的解。与分治法不同的是，动态规划经分解后得到的**子问题往往不是相互独立的。**

- 暴力递归与动态规划的关系

  > 递归包含了含有**重复子问题的递归**与**不含有重复子问题的递归**
  >
  > **动态规划**只与**重复子问题的递归**有关系
  >
  > **所有动态规划问题全部可以由递归实现，但只有含有重复子问题的递归才能由动态规划实现。**

- 怎么尝试—件事?

  > 1）有经验但是没有方法论?
  >
  > 2）怎么判断一个尝试就是最优尝试?
  >
  > 3）难道尝试这件事真的只能拼天赋?那我咋搞定我的面试?
  >
  > 4）动态规划是啥?好高端的样子哦…可是我不会啊!和尝试有什么关系?

- 什么暴力递归可以继续优化?

  > 有**重复调用**同一个子问题的解，这种递归可以优化
  >
  > 如果每一个子问题都是不同的解，无法优化也不用优化

- 面试题和动态规划的关系

  > 解决一个问题，可能有很多尝试方法
  >
  > 可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式
  >
  > **一个问题可能有若干种动态规划的解法**

- 如何找到某个问题的动态规划方式?

  > 1）设计暴力递归∶重要原则+4种常见尝试模型!重点!
  >
  > 2）分析有没有重复解︰套路解决
  >
  > 3）用记忆化搜索->用严格表结构实现动态规划∶套路解决
  >
  > 4）看看能否继续优化∶套路解决

- 面试中设计暴力递归过程的原则

  > 1）每一个可变参数的类型，一定不要比int类型更加复杂
  >
  > 2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数
  >
  > 3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可
  >
  > 4）可变参数的个数，能少则少

- 知道了面试中设计暴力递归过程的原则，然后呢?

  > 一定要逼自己找到不违反原则情况下的暴力尝试!
  >
  > 如果你找到的暴力尝试，不符合原则，马上舍弃!找新的!
  >
  > 如果某个题目突破了设计原则，一定极难极难，面试中出现**概率低于5%** !

- 常见的4种尝试模型

  > 1）从左往右的尝试模型
  >
  > 2）范围上的尝试模型
  >
  > 3）多样本位置全对应的尝试模型
  >
  > 4）寻找业务限制的尝试模型

- 如何分析有没有重复解

  > 列出调用过程，可以只列出前几层
  >
  > 有没有重复解，一看便知

- 暴力递归到动态规划的套路

  > 1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用
  >
  > 2）找到哪些参数的变化会影响返回值，对每一个列出变化范围
  >
  > 3）参数间的所有的组合数量，意味着表大小
  >
  > 4）记忆化搜索的方法就是傻缓存，非常容易得到
  >
  > 5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解
  >
  > 6）对于有枚举行为的决策过程，进一步优化

- 动态规划的进一步优化

  > 1）空间压缩
  >
  > 2）状态化简
  >
  > 3）四边形不等式
  >
  > 4）其他优化技巧

## 问题集合

### KillMonster

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class22/Code01_KillMonster.java">测试链接</a>

- 内容：

  > 给定3个参数，N,M,K
  >
  > 怪兽有N滴血，等着英雄来砍自己
  >
  > 英雄每一次打击，都会让怪兽流失[0~M]的血量
  >
  > 到底流失多少?每一次在[0~M]上等概率的获得一个值
  >
  > 求K次打击之后，英雄把怪兽砍死的概率。

- 思路：

  > 递归
  >
  > dp 递归转化
  >
  > dp dp枚举优化

- 代码：

  <details>
  <summary>递归</summary>
  <p> - 怪兽死的概率</p>
  <pre><code>	public static double right(int N, int M, int K) {
  		if (N < 1 || M < 1 || K < 1) {
  			return 0;
  		}
  		long all = (long) Math.pow(M + 1, K);
  		long kill = process(K, M, N);
  		return (double) ((double) kill / (double) all);
  	}
  	// 怪兽还剩hp点血
  	// 每次的伤害在[0~M]范围上
  	// 还有times次可以砍
  	// 返回砍死的情况数！
  	public static long process(int times, int M, int hp) {
  		if (times == 0) {
  			return hp <= 0 ? 1 : 0;
  		}
  		if (hp <= 0) {
  			return (long) Math.pow(M + 1, times);
  		}
  		long ways = 0;
  		for (int i = 0; i <= M; i++) {
  			ways += process(times - 1, M, hp - i);
  		}
  		return ways;
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp</summary>
  <p> - 怪兽死的概率</p>
  <pre><code>public static double dp1(int N, int M, int K) {
  		if (N < 1 || M < 1 || K < 1) {
  			return 0;
  		}
  		long all = (long) Math.pow(M + 1, K);
  		long[][] dp = new long[K + 1][N + 1];
  		dp[0][0] = 1;
  		for (int times = 1; times <= K; times++) {
  			dp[times][0] = (long) Math.pow(M + 1, times);
  			for (int hp = 1; hp <= N; hp++) {
  				long ways = 0;
  				for (int i = 0; i <= M; i++) {
  					if (hp - i >= 0) {
  						ways += dp[times - 1][hp - i];
  					} else {
  						ways += (long) Math.pow(M + 1, times - 1);
  					}
  				}
  				dp[times][hp] = ways;
  			}
  		}
  		long kill = dp[K][N];
  		return (double) ((double) kill / (double) all);
  	}</code>  </pre>
  </details>

  <details>
  <summary>dp枚举优化</summary>
  <p> - 怪兽死的概率</p>
  <pre><code>	public static double dp2(int N, int M, int K) {
  		if (N < 1 || M < 1 || K < 1) {
  			return 0;
  		}
  		long all = (long) Math.pow(M + 1, K);
  		long[][] dp = new long[K + 1][N + 1];
  		dp[0][0] = 1;
  		for (int times = 1; times <= K; times++) {
  			dp[times][0] = (long) Math.pow(M + 1, times);
  			for (int hp = 1; hp <= N; hp++) {
  				dp[times][hp] = dp[times][hp - 1] + dp[times - 1][hp];
  				if (hp - 1 - M >= 0) {
  					dp[times][hp] -= dp[times - 1][hp - 1 - M];
  				} else {
  					dp[times][hp] -= Math.pow(M + 1, times - 1);
  				}
  			}
  		}
  		long kill = dp[K][N];
  		return (double) ((double) kill / (double) all);
  	}</code>  </pre>
  </details>

### MinCoinsNoLimit

- 链接：<a href="https://leetcode.cn/problems/coin-change/description/">测试链接</a>

- 内容：

  > arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。
  >
  > 每个值都认为是一种面值，且认为张数是无限的。
  >
  > 返回组成aim的最少货币数。

- 思路：

  > 递归
  >
  > dp 递归转化
  >
  > dp dp枚举优化

- 代码：

  <details>
  <summary>递归</summary>
  <p> - 组成aim的最少货币数</p>
  <pre><code>	public static int minCoins(int[] arr, int aim) {
  		return process(arr, 0, aim);
  	}
  	// arr[index...]面值，每种面值张数自由选择，
  	// 搞出rest正好这么多钱，返回最小张数
  	// 拿Integer.MAX_VALUE标记怎么都搞定不了
  	public static int process(int[] arr, int index, int rest) {
  		if (index == arr.length) {
  			return rest == 0 ? 0 : Integer.MAX_VALUE;
  		} else {
  			int ans = Integer.MAX_VALUE;
  			for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
  				int next = process(arr, index + 1, rest - zhang * arr[index]);
  				if (next != Integer.MAX_VALUE) {
  					ans = Math.min(ans, zhang + next);
  				}
  			}
  			return ans;
  		}
  	}</code>  </pre>
  </details>
  <details>
  <summary>dp</summary>
  <p> - 组成aim的最少货币数</p>
  <pre><code>	public static int dp1(int[] arr, int aim) {
  		if (aim == 0) {
  			return 0;
  		}
  		int N = arr.length;
  		int[][] dp = new int[N + 1][aim + 1];
  		dp[N][0] = 0;
  		for (int j = 1; j <= aim; j++) {
  			dp[N][j] = Integer.MAX_VALUE;
  		}
  		for (int index = N - 1; index >= 0; index--) {
  			for (int rest = 0; rest <= aim; rest++) {
  				int ans = Integer.MAX_VALUE;
  				for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
  					int next = dp[index + 1][rest - zhang * arr[index]];
  					if (next != Integer.MAX_VALUE) {
  						ans = Math.min(ans, zhang + next);
  					}
  				}
  				dp[index][rest] = ans;
  			}
  		}
  		return dp[0][aim];
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp枚举优化</summary>
  <p> - 组成aim的最少货币数</p>
  <pre><code>	public static int dp2(int[] arr, int aim) {
  		if (aim == 0) {
  			return 0;
  		}
  		int N = arr.length;
  		int[][] dp = new int[N + 1][aim + 1];
  		dp[N][0] = 0;
  		for (int j = 1; j <= aim; j++) {
  			dp[N][j] = Integer.MAX_VALUE;
  		}
  		for (int index = N - 1; index >= 0; index--) {
  			for (int rest = 0; rest <= aim; rest++) {
  				dp[index][rest] = dp[index + 1][rest];
  				if (rest - arr[index] >= 0 
  						&& dp[index][rest - arr[index]] != Integer.MAX_VALUE) {
  					dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - arr[index]] + 1);
  				}
  			}
  		}
  		return dp[0][aim];
  	}</code>  </pre>
  </details>

### SplitNumber

- 链接：<a href="https://github.com/xtpyip/blog-alogrithm/blob/main/alogrithm/src/main/java/blog/wstx/class22/Code03_SplitNumber.java">测试链接</a>

- 内容：

  > 给定一个正数1，裂开的方法有一种，(1)
  >  
  >   给定一个正数2，裂开的方法有两种，(1,1)、(2)
  >  
  >   给定一个正数3，裂开的方法有三种。(1,1,1)、(1,2)、[3)
  >  
  >    给定一个正故4，裂开的方法有五种,(1,1,1,1)、(1,1,2)、(1,3)、(2,2)、(4)
  >   
  >   给定一个正数n，求裂开的方法数。
  >   
  >    动态规划优化状态依赖的技巧。(后面的数字>=前面的数字)

- 思路：

  > 递归
  >
  > dp 递归转化
  >
  > dp dp枚举优化

- 代码：

  <details>
  <summary>递归</summary>
  <p> - 裂开的方法数</p>
  <pre><code>// n为正数
  	public static int ways(int n) {
  		if (n < 0) {
  			return 0;
  		}
  		if (n == 1) {
  			return 1;
  		}
  		return process(1, n);
  	}
  	// 上一个拆出来的数是pre
  	// 还剩rest需要去拆
  	// 返回拆解的方法数
  	public static int process(int pre, int rest) {
  		if (rest == 0) {
  			return 1;
  		}
  		if (pre > rest) {
  			return 0;
  		}
  		int ways = 0;
  		for (int first = pre; first <= rest; first++) {
  			ways += process(first, rest - first);
  		}
  		return ways;
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp</summary>
  <p> - 裂开的方法数</p>
  <pre><code>public static int dp1(int n) {
  		if (n < 0) {
  			return 0;
  		}
  		if (n == 1) {
  			return 1;
  		}
  		int[][] dp = new int[n + 1][n + 1];
  		for (int pre = 1; pre <= n; pre++) {
  			dp[pre][0] = 1;
  			dp[pre][pre] = 1;
  		}
  		for (int pre = n - 1; pre >= 1; pre--) {
  			for (int rest = pre + 1; rest <= n; rest++) {
  				int ways = 0;
  				for (int first = pre; first <= rest; first++) {
  					ways += dp[first][rest - first];
  				}
  				dp[pre][rest] = ways;
  			}
  		}
  		return dp[1][n];
  	}</code>  </pre>
  </details>
  
  <details>
  <summary>dp枚举优化</summary>
  <p> - 裂开的方法数</p>
  <pre><code>	public static int dp2(int n) {
  		if (n < 0) {
  			return 0;
  		}
  		if (n == 1) {
  			return 1;
  		}
  		int[][] dp = new int[n + 1][n + 1];
  		for (int pre = 1; pre <= n; pre++) {
  			dp[pre][0] = 1;
  			dp[pre][pre] = 1;
  		}
  		for (int pre = n - 1; pre >= 1; pre--) {
  			for (int rest = pre + 1; rest <= n; rest++) {
  				dp[pre][rest] = dp[pre + 1][rest];
  				dp[pre][rest] += dp[pre][rest - pre];
  			}
  		}
  		return dp[1][n];
  	}</code>  </pre>
  </details>